<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="[TOC]                     TCP&#x2F;IP 网络模型有哪几层？       4层：应用层、传输层、网络层、网络套接层                     流量控制和拥塞控制有什么区别？       流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的； 拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="保研复习之计算机网络">
<meta property="og:url" content="http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/index.html">
<meta property="og:site_name" content="时光cool的博客仓库">
<meta property="og:description" content="[TOC]                     TCP&#x2F;IP 网络模型有哪几层？       4层：应用层、传输层、网络层、网络套接层                     流量控制和拥塞控制有什么区别？       流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的； 拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210701184819348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-10-05T12:52:25.197Z">
<meta property="article:modified_time" content="2022-10-05T13:01:25.166Z">
<meta property="article:author" content="水水水">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70"><title>保研复习之计算机网络 | 时光cool的博客仓库</title><link ref="canonical" href="http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="时光cool的博客仓库" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">时光cool的博客仓库</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">保研复习之计算机网络</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><p>[TOC]</p>

        <h3 id="TCP-x2F-IP-网络模型有哪几层？"   >
          <a href="#TCP-x2F-IP-网络模型有哪几层？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h3>
      <p>4层：应用层、传输层、网络层、网络套接层</p>

        <h3 id="流量控制和拥塞控制有什么区别？"   >
          <a href="#流量控制和拥塞控制有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制和拥塞控制有什么区别？" class="headerlink" title="流量控制和拥塞控制有什么区别？"></a>流量控制和拥塞控制有什么区别？</h3>
      <p>流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的；</p>
<p>拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。 </p>

        <h3 id="https和http相比有什么区别"   >
          <a href="#https和http相比有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#https和http相比有什么区别" class="headerlink" title="https和http相比有什么区别"></a>https和http相比有什么区别</h3>
      <ol>
<li>建立连接时候：https 比 http多了 TLS 的握手过程；</li>
<li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li>
</ol>

        <h3 id="TCP-和-UDP-区别："   >
          <a href="#TCP-和-UDP-区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-和-UDP-区别：" class="headerlink" title="TCP 和 UDP 区别："></a><strong>TCP 和 UDP 区别：</strong></h3>
      <p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。慢开始、拥塞避免、快重传、快恢复 </li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>

        <h3 id="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"   >
          <a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="headerlink" title="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"></a><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></h3>
      <ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>

        <h3 id="不使用「两次握手」和「四次握手」的原因："   >
          <a href="#不使用「两次握手」和「四次握手」的原因：" class="heading-link"><i class="fas fa-link"></i></a><a href="#不使用「两次握手」和「四次握手」的原因：" class="headerlink" title="不使用「两次握手」和「四次握手」的原因："></a>不使用「两次握手」和「四次握手」的原因：</h3>
      <p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。 </p>
<p>（1）三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p>
<p>（2）三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>

        <h3 id="为什么需要-TIME-WAIT-状态"   >
          <a href="#为什么需要-TIME-WAIT-状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h3>
      <p>TIME_WAIT 状态持续 2MSL（最大报文存活时间），约4分钟才转换成CLOSE状态。由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接，TIME_WAIT 的主要作用有：</p>
<p>（1）重发丢失的 ACK 报文，保证连接可靠的关闭：</p>
<blockquote>
<p>由于网络等原因，无法保证最后一次挥手的 ACK 报文一定能传送给对方，如果 ACK 丢失，对方会超时重传 FIN，主动关闭端会再次响应ACK过去；如果没有 TIME_WAIT 状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。同时，服务器就因为接收不到客户端的信息而无法正常关闭。</p>
</blockquote>
<p>（2）保证本次连接的重复数据段从网络中消失：</p>
<blockquote>
<p>如果存在两个连接，第一个连接正常关闭，第二个相同的连接紧接着建立；如果第一个连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达，则会干扰第二连接，等待 2MSL 可以让上次连接的报文数据消逝在网络中。</p>
</blockquote>

        <h3 id="为什么需要四次挥手"   >
          <a href="#为什么需要四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3>
      <p>TCP 是全双工模式，并且支持半关闭特性，提供了连接的一端在结束发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>

        <h3 id="什么是拆包粘包："   >
          <a href="#什么是拆包粘包：" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是拆包粘包：" class="headerlink" title="什么是拆包粘包："></a><strong>什么是拆包粘包：</strong></h3>
      <p>拆包粘包在数据链路层、网络层以及传输层都可能存在。而在传输层中，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。 </p>

        <h3 id="网络层-IP数据报分片："   >
          <a href="#网络层-IP数据报分片：" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层-IP数据报分片：" class="headerlink" title="网络层 - IP数据报分片："></a><strong>网络层 - IP数据报分片：</strong></h3>
      <p>​	 MTU 是数据链路层中的网络对数据帧的一个限制（以太网中 MTU 为1500个字节），一个 IP 数据报在以太网中传输，如果它的长度大于 MTU 值，就要进行分片传输，使得每片数据报的长度小于 MTU。而分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装，IP数据报的分片与重组是在网络层进完成的。</p>
<p>​        前面提到，MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 在建立连接时通常会协商双方的 MSS 值（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（IP 数据包包头的大小 20 Bytes 和 TCP 数据段的包头 20 Bytes），TCP报文段的分段与重组是在传输层完成的。</p>
<blockquote>
<p>如果用链路层以太网，MSS的值往往为1460。而 Internet 上标准的 MTU（最小的 MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。</p>
</blockquote>
<p>​        到这里我们就能看出，TCP 分段的原因是 MSS，IP 分片的原因是 MTU，由于一直有 MSS &lt;&#x3D; MTU，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了，因此TCP报文段很少会发生IP分片的情况。</p>
<p>​        而由于 UDP 数据报不会自己进行分段，因此当长度超过了 MTU 时，会在网络层进行 IP 分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p>​        所以，总的来说，UDP 不会分段，就由 IP 来分，TCP会分段，当然就不用 IP 来分了！</p>

        <h3 id="IPv4和IPv6首部的差异"   >
          <a href="#IPv4和IPv6首部的差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4和IPv6首部的差异" class="headerlink" title="IPv4和IPv6首部的差异"></a>IPv4和IPv6首部的差异</h3>
      <p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>

        <h3 id="TCP-如何保证可靠性传输："   >
          <a href="#TCP-如何保证可靠性传输：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-如何保证可靠性传输：" class="headerlink" title="TCP 如何保证可靠性传输："></a>TCP 如何保证可靠性传输：</h3>
      <ul>
<li>（1）三次握手</li>
<li>（2）应答机制与超时重传：TCP接收端收到发送端的数据时，它将发送一个确认。当TCP发送端发出一个报文段后，它会启动一个定时器，等待接收端的确认报文段，如果不能及时收到一个确认，将重发这个报文段。</li>
<li>（3）数据包校验与丢弃重复数据：TCP会检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP会超时重发数据；对于重复数据，则进行丢弃；</li>
<li>（4）对失序数据包进行重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>（5）流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li>（6）拥塞控制：网络拥塞时，减少数据的发送。</li>
</ul>

        <h3 id="交换机和路由器的区别"   >
          <a href="#交换机和路由器的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3>
      <p>（1）工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层；</p>
<p>（2）寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址；</p>
<p>（3）转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</p>
<p>（4）交换机用于连接局域网，路由器用于连接外网和局域网</p>

        <h3 id="集线器和交换机的区别"   >
          <a href="#集线器和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器和交换机的区别" class="headerlink" title="集线器和交换机的区别"></a><strong>集线器和交换机的区别</strong></h3>
      <p>集线器和交换机都是工作在TCP&#x2F;IP协议的最后一层，数据链路（物理层），都是连接多个设备形成局域网的。<br>集线器会把接收到的数据包每次都广播给局域网局域网的所有计算机，而交换机只有首次在MAC地址表找不到记录才广播，其他时候是直接单独发送给对应MAC地址的计算机。交换机可以说是集线器的升级改良版，在集线器的基础上多了MAC地址表，可以分割冲突域，更加智能化。</p>
<p>集线器的数据传输方式是广播方式，而交换机的数据传输是有目的的，数据只对目的节点发送，只是在自己的MAC地址表中找不到的情况下第一次使用广播方式发送，然后因为交换机具有MAC地址学习功能，第二次以后就不再是广播发送了，又是有目的的发送。这样的好处是数据传输效率提高，不会出现广播风暴，在安全性方面也不会出现其它节点侦听的现象</p>

        <h3 id="网桥和交换机的区别"   >
          <a href="#网桥和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#网桥和交换机的区别" class="headerlink" title="网桥和交换机的区别"></a><strong>网桥和交换机的区别</strong></h3>
      <ul>
<li>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个输出输入端口，而交换机具有高密度的端口。所以一般的交换机，网桥就有桥接作用。</li>
<li>网桥主要由软件实现，交换机主要由硬件实现</li>
</ul>
<p>网桥也可以理解成只有两个端口的交换机，交换机可以理解成由多个网桥组成的 </p>

        <h3 id="介绍一下TCP的拥塞控制："   >
          <a href="#介绍一下TCP的拥塞控制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下TCP的拥塞控制：" class="headerlink" title="介绍一下TCP的拥塞控制："></a>介绍一下<strong>TCP的拥塞控制：</strong></h3>
      <p>拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。 </p>
<p><strong>（1）慢开始算法：</strong>当发送主机开始发送数据时，不要一开始就发送大量的数据，因为不清楚网络的拥塞情况，而是试探一下网络的拥塞情况，由小到大逐渐增大发送窗口。</p>
<p><strong>（2）拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p><strong>（3）快重传：</strong>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不必等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><strong>（4）快恢复：</strong>与快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减少”算法，把ssthresh门限设置为拥塞窗口cwnd的一半，但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法：因为如果网络出现拥塞的话，就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以此时并不执行慢开始算法，而是执行拥塞避免算法。</p>

        <h3 id="拥塞控制和流量控制的差别："   >
          <a href="#拥塞控制和流量控制的差别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制和流量控制的差别：" class="headerlink" title="拥塞控制和流量控制的差别："></a>拥塞控制和流量控制的差别：</h3>
      <p>（1）相同点：拥塞控制和流量控制的相同点都是控制丢包现象，实现机制都是让发送方发得慢一点。</p>
<p>（2）不同点：</p>
<p>① 拥塞控制是一个全局性的过程，防止过多的数据注入到网络中，造成网络拥塞</p>
<p>② 流量控制指点对点通信量的控制，要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
<p>如何判断多个数据包是属于同一个信息？以及他们的先后次序？</p>
<p>为什么网络传输中会出现丢包？</p>

        <h3 id="Ip协议中用来分片和重组的依据"   >
          <a href="#Ip协议中用来分片和重组的依据" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ip协议中用来分片和重组的依据" class="headerlink" title="Ip协议中用来分片和重组的依据"></a>Ip协议中用来分片和重组的依据</h3>
      <p>标志：根据DF来判断是否可以进行分片</p>
<p>标识：根据标识来判断原始报文和分片报文的关系</p>
<p>偏移量：收集所有的分片</p>
<p><img   src="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>
<p>一个表示网段地址、一个表示广播地址</p>
<p>网络号是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的第一个地址，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80" >广播地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E6%AE%B5&spm=1001.2101.3001.7020" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的最后一个地址，这两个地址是不能配置在计算机<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" >主机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的。 </p>

        <h3 id="DHCP协议"   >
          <a href="#DHCP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名称：动态主机配置协议</span><br><span class="line">作用：当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址</span><br><span class="line">协议：基于UDP</span><br><span class="line">工作方式：客户/服务段模式	C/S模式</span><br><span class="line">端口号：服务器在67号  客户端在68号</span><br><span class="line">过程：DHCPDISCOVER-&gt;DHCPOFFER-&gt;DHCPREQUEST-&gt;DHCPACK</span><br><span class="line">协议层：网络层</span><br></pre></td></tr></table></div></figure>




        <h3 id="ARP协议"   >
          <a href="#ARP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">名称：地址解析协议</span><br><span class="line">作用：根据IP地址获取物理地址的一个TCP/IP协议</span><br><span class="line">协议层：网络层</span><br><span class="line">过程：</span><br><span class="line">	A已知B的IP地址，需要获得B的MAC地址（物理地址）</span><br><span class="line">    如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取</span><br><span class="line">    如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组</span><br><span class="line">    在局域网上的所有节点都可以接收到ARP query</span><br><span class="line">    B接收到ARP query分组后，将自己的MAC地址发送给A</span><br><span class="line">    A在ARP表中缓存B的IP地址和MAC地址的映射关系</span><br><span class="line">    超时时删除</span><br></pre></td></tr></table></div></figure>




        <h3 id="ICMP协议"   >
          <a href="#ICMP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：互联网控制报文协议</span><br><span class="line">作用：ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</span><br><span class="line">ICMP 报文携带在IP 数据报中： IP上层协议号为1</span><br><span class="line">类型：差错报告报文、询问报文</span><br></pre></td></tr></table></div></figure>




        <h3 id="路由选择协议RIP"   >
          <a href="#路由选择协议RIP" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议RIP" class="headerlink" title="路由选择协议RIP"></a>路由选择协议RIP</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于：距离矢量算法</span><br><span class="line">衡量标准：跳数、即距离近</span><br><span class="line">基本思想：①只与邻居路由器交换信息②交换的是整个路由表</span><br><span class="line">特点：算法简单、收敛慢</span><br><span class="line">适用场景：中小网络</span><br></pre></td></tr></table></div></figure>




        <h3 id="BGP-外部网关路由协议"   >
          <a href="#BGP-外部网关路由协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#BGP-外部网关路由协议" class="headerlink" title="BGP-外部网关路由协议"></a>BGP-外部网关路由协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对于：内部网关路由协议IGP：比如RIP、OSPF等</span><br><span class="line">适用于：不同的自治域间的路由协议</span><br><span class="line">交换信息：路径通告</span><br><span class="line">基于：TCP连接用于交换BGP报文</span><br><span class="line">两类报文：eBGP用于相邻的AS，iBGP用于AS内的全部路由器（即内部）</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="路由器中三种典型的交换结构"   >
          <a href="#路由器中三种典型的交换结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器中三种典型的交换结构" class="headerlink" title="路由器中三种典型的交换结构"></a>路由器中三种典型的交换结构</h3>
      <p>共享内、共享总线、纵横式 crossbar</p>
<p><img   src="https://img-blog.csdnimg.cn/20210701184819348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>

        <h3 id="远程登录Telnet"   >
          <a href="#远程登录Telnet" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程登录Telnet" class="headerlink" title="远程登录Telnet"></a>远程登录Telnet</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用：定义客户进程与远程服务器进程之间的交互过程</span><br><span class="line">基于：TCP协议</span><br><span class="line">协议层：应用层协议</span><br><span class="line">传输数据格式：NVT网络虚拟终端（定义的一组通用字符集）</span><br><span class="line">工作过程：①建立TCP连接 </span><br><span class="line">②将本地终端上输入的用户名和口令及以后输入的任何命令或字符以网络虚拟终端NVT格式传输给远程主机</span><br><span class="line">③将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果</span><br><span class="line">④本地终端对远程主机撤销连接，从而结束 Telnet远程登录过程</span><br></pre></td></tr></table></div></figure>




        <h3 id="文件传输协议FTP"   >
          <a href="#文件传输协议FTP" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a><strong>文件传输协议FTP</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限</span><br><span class="line">实现方式：C/S模式</span><br><span class="line">协议层：应用层协议</span><br><span class="line">基于：TCP协议（21号端口）</span><br><span class="line">两个端口与两个连接：21号端口用于控制连接  20号端口用于数据连接</span><br></pre></td></tr></table></div></figure>




        <h3 id="传输层是干嘛的？"   >
          <a href="#传输层是干嘛的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层是干嘛的？" class="headerlink" title="传输层是干嘛的？"></a>传输层是干嘛的？</h3>
      <p>为主机的进程之间提供通信，是两个主机通信中第一个端对端的层次，具有缓冲作用。由于一个主机有多个进程，因此传输层具有分用复用的功能。传输层在终端用户中进行透明的数据传输，向上层提供可靠的数据传输服务。当网络层服务质量不能满足要求时（比如无法保证可靠传输）它可以将服务质量提高到达需要的要求。通过流量控制、分段&#x2F;重组、差错控制来保证数据传输的可靠性。</p>
<p>在传输层上又两个经常用到的协议：TCP和UDP，TCP可以保证可靠传输协议，它是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手来建立连接，四次挥手来中断连接。它具有拥塞控制和流量控制机制。UDP是尽最大努力交付的协议，比较的简单，没有那么多机制，对于那些数据质量要求不高但是时效性要求高的应用经常使用。</p>

        <h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"   >
          <a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3>
      <p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>

        <h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"   >
          <a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3>
      <p>主要原因有三：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p>当历史连接由于网络拥塞导致其在客户端重新请求之后，新请求达到之前先一步到达客户端，那么客户端发送的ACK便是历史的连接请求，此时客户端发现后便需要RST中断连接，但此时服务端已经是established因此会发送数据造成浪费，主要原因是两次握手「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</p>
<p>除此之外通过三次握手才能约定客户端和服务段双方的初始化序列号，如果两次的话只能确定客户端的初始化序列号。</p>
<p>如果是两次握手，当网络拥挤时由于SYN报文的丢失，会导致服务端手段多个重复的SYN，由于经过了一段时间的传输因此可能会造成多余连接的建立，造成资源浪费。</p>
<p>每次都是接收到数据包的一方可以得到对方的状态，发送的一方其实没有任何头绪。因此至少需要三次握手才能使得双方都确定对方已经完成发送数据的准备。</p>

        <h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"   >
          <a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3>
      <p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>

        <h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"   >
          <a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3>
      <p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。 </p>

        <h3 id="说下网络中的主机通信流程"   >
          <a href="#说下网络中的主机通信流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下网络中的主机通信流程" class="headerlink" title="说下网络中的主机通信流程"></a>说下网络中的主机通信流程</h3>
      <p>主机A和主机B在同一个二层网络中，直接走二层交换</p>
<p>主机A和主机B不在同一个网络中，走三层路由</p>

        <h3 id="介绍一下Socket"   >
          <a href="#介绍一下Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Socket" class="headerlink" title="介绍一下Socket"></a>介绍一下Socket</h3>
      <p>Socket是一组编程接口（API）。介于传输层和应用层，向应用层提供统一的编程接口。应用层不必了解TCP&#x2F;IP协议细节。直接通过对Socket接口函数的调用完成数据在IP网络的传输。</p>
<p>套接字&#x3D;IP地址+网络协议+端口号</p>

        <h3 id="HTTP和HTTPS"   >
          <a href="#HTTP和HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3>
      <p>他们都是应用层协议</p>
<p>HTTP协议是超文本传输协议，最初的目的是为了提供一种发布和接收HTML页面的方法</p>
<p>HTTPS是HTTP协议的安全版本，将其传输过程中的数据使用SSL&#x2F;TLS进行了加密，并且他是需要申请证书的</p>
<p>他们使用的端口号不同，HTTP为80端口，HTTPS为443端口</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立</span><br><span class="line">（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息</span><br><span class="line">（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</span><br><span class="line">（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</span><br><span class="line">（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</span><br></pre></td></tr></table></div></figure>





        <h3 id="CSMA-x2F-CD协议"   >
          <a href="#CSMA-x2F-CD协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3>
      <p>载波监听多点接入&#x2F;碰撞检测协议  三大特点</p>
<p>1.多点接入：作用在总线型网络中，许多计算机以多点接入的方式连接在同一个总线上</p>
<p>2.载波监听：每个站在发送数据前都会先检测总线上是否有其他站在发送数据，如果有则先等待</p>
<p>3.碰撞检测：边发送边监听，通过监听电压值的变化来判断是否和其他站发送进行了冲突，一段时间后无冲突则不再检测，如果发送冲突则停止发送数据，等待一段空闲时间后再次发送。</p>
<p>碰撞不可能完全避免，CSMA&#x2F;CD只能减少碰撞。</p>

        <h3 id="如何扩充局域网？"   >
          <a href="#如何扩充局域网？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何扩充局域网？" class="headerlink" title="如何扩充局域网？"></a>如何扩充局域网？</h3>
      <p>在物理层：通过集线器将多个计算机进行互联</p>
<p>链路层：通过交换机来进行扩展，相当于多接口的网桥</p>
<p>网络层：通过虚拟局域网VLAN</p>

        <h3 id="私有地址的范围"   >
          <a href="#私有地址的范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#私有地址的范围" class="headerlink" title="私有地址的范围"></a>私有地址的范围</h3>
      <p>A类：10.0.0.0-10.255.255.255</p>
<p>B类：172.16.0.0-172.31.255.255</p>
<p>C类：192.168.0.0-192.168.255.255</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用</p>

        <h3 id="介绍一下虚电路"   >
          <a href="#介绍一下虚电路" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下虚电路" class="headerlink" title="介绍一下虚电路"></a>介绍一下虚电路</h3>
      <p>虚电路是分组交换的两种传输方式中的一种，另一种是电路交换</p>
<p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p>
<p>提前定义好一条路径，可以改进性能，并且消除了帧和分组对头的需求，从而增加了吞吐率</p>

        <h3 id="电路交换、报文交换、分组交换"   >
          <a href="#电路交换、报文交换、分组交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3>
      <p>电路交换：在使用电路交换进行通话之前，必须先拨号建立一条连接，也就是一条专用的物理通路，这条通路在通话中只允许通话的两个用户使用，而不允许其他人使用。</p>
<p>优点：实现简单</p>
<p>缺点：建立大型网络时资源利用率不高，当用户比较多时，可能会出现通路短缺的情况。</p>
<p>报文交换：报文是通信链路中一次要发送的数据，报文交换就是把整个报文完整的发送到链路中，在某个节点存储下来之后再发送到下一个节点。</p>
<p>优点：相比电路交换，来说更加灵活。不需要事先建立连接之后再进行通信。</p>
<p>缺点：当每个报文的数据量较大时，每次在节点处转发再存储的话时延较大。</p>
<p>分组交换：分组交换采用转发存储技术，将一个完整的报文，分成若干个分组，再进行转发，而且每个分组之间经过哪一个节点，与上一个分组完全没有关系，这一点在某些网络节点发生网络阻塞时会显得尤其重要。</p>
<p>优点：发送数据更加灵活，时延更下。</p>
<p>缺点：发送设备和接收设备就更加复杂。</p>

        <h3 id="什么是SYN洪泛"   >
          <a href="#什么是SYN洪泛" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SYN洪泛" class="headerlink" title="什么是SYN洪泛"></a>什么是SYN洪泛</h3>
      <p> SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，耗尽其资源，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p>
<blockquote>
<p>半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。</p>
</blockquote>

        <h3 id="cookie-和-session-的区别："   >
          <a href="#cookie-和-session-的区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#cookie-和-session-的区别：" class="headerlink" title="cookie 和 session 的区别："></a><strong>cookie 和 session 的区别：</strong></h3>
      <p>1）保存位置与安全性：cookie保存在客户端，session保存在服务端，所以在安全性上面，cookie存在安全隐患，可以通过拦截或本地文件找到cookie后进行攻击，而session相对更加安全。因此，可以将登陆信息等重要信息存放为session中；其他信息如果需要保留，可以放在cookie中。</p>
<p>（2）存储容量：单个cookie最大只允许4KB，一个站点最多保存20个Cookie；session没有大小限制，个数只跟服务器的内存大小有关。</p>
<p>（3）有效期与实现机制：cookie可长期有效存在；session依赖于cookie，过期时间默认为-1，只需关闭窗口该 session 就会失效。每个客户端对应一个session ，客户端之间的 session  相互独立；</p>

        <h3 id="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"   >
          <a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="headerlink" title="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"></a>一个完整的http请求是怎么样？即从输入网址到获得页面的过程</h3>
      <p>（1）解析url，获取 url 中包含的域名；</p>
<p>（2）通过DNS系统查询域名对应的IP；</p>
<p>（3）浏览器得到域名对应的IP地址之后，向服务器发起三次握手请求建立TCP链接；</p>
<p>（4）TCP链接链接建立起来后，浏览器向服务器发送http请求，如果 html文件在缓存里，浏览器则直接返回， 如果没有，则去后台拿；</p>
<p>（5）服务器接收到请求后，根据路径参数映射到特定的处理器进行处理，并将处理结果以及相应的视图返回给浏览器。</p>
<p>（6）浏览器解析视图，并根据请求到的资源、数据进行渲染页面，最终向用户呈现一个完整的页面。</p>

        <h3 id="http的长连接和短连接？"   >
          <a href="#http的长连接和短连接？" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的长连接和短连接？" class="headerlink" title="http的长连接和短连接？"></a><strong>http的长连接和短连接？</strong></h3>
      <p>http的长连接和短连接本质上是TCP长连接和短连接。从http1.1开始就默认使用长连接。</p>
<p>短链接是指客户端与服务端每进行一次请求操作，就建立一次TCP连接，收到服务器响应后，就断开连接。</p>
<p>长连接是指客户端和服务建立TCP连接后，它们之间的连接会持续存在，不会因为一次HTTP请求后关闭，后续的请求也是用这个连接进行通信，使用长连接的HTTP协议，会在响应头有加入：Connection:keep-alive。长连接可以省去每次TCP建立和关闭的握手和挥手操作，节约时间提高效率。但在长连接下，客户端一般不会主动关闭连接，如果客户端和服务端之间的连接一直不关闭的话，随着连接数越来越多，会对服务端造成压力。</p>
<p>所以长连接多用于频繁请求资源，而且连接数不能太多的情况，例如数据库的连接用长连接。而像Web网站这种并发量大，但是每个用户无需频繁操作的场景，一般都使用短连接，因为长连接对服务端来说会耗费一定的资源。</p>

        <h3 id="get和-post-请求的区别"   >
          <a href="#get和-post-请求的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a><strong>get和 post 请求的区别</strong></h3>
      <ul>
<li>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。</li>
<li>（2）幂等性：get 是幂等的，post 为非幂等的</li>
<li>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。</li>
<li>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。</li>
<li>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。</li>
<li>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</li>
</ul>

        <h3 id="Http-常见的状态码"   >
          <a href="#Http-常见的状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-常见的状态码" class="headerlink" title="Http 常见的状态码"></a><strong>Http 常见的状态码</strong></h3>
      <p>（1）1xx：请求处理中，请求已被接受，正在处理。</p>
<p>（2）2xx：请求成功，请求被成功处理。</p>
<p>（3）3xx：重定向，要完成请求必须进一步处理。</p>
<p>（4）4xx：客户端错误，请求不合法。</p>
<ul>
<li>404：未找到请求的资源</li>
</ul>
<p>（5）5xx：服务端错误，服务端不能处理合法请求。</p>
<ul>
<li>500：服务器内部错误。</li>
</ul>

        <h3 id="DNS-为什么用-UDP"   >
          <a href="#DNS-为什么用-UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h3>
      <p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>

        <h3 id="保活计时器的作用？"   >
          <a href="#保活计时器的作用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#保活计时器的作用？" class="headerlink" title="保活计时器的作用？"></a>保活计时器的作用？</h3>
      <p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>

        <h3 id="UDP-如何实现可靠传输？"   >
          <a href="#UDP-如何实现可靠传输？" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-如何实现可靠传输？" class="headerlink" title="UDP 如何实现可靠传输？"></a>UDP 如何实现可靠传输？</h3>
      <p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">水水水</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/">http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/10/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">保研复习之离散数学</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"><span class="paginator-prev__text">保研复习之计算机知识</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">
          TCP&#x2F;IP 网络模型有哪几层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">
          流量控制和拥塞控制有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E5%92%8Chttp%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">
          https和http相比有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">
          TCP 和 UDP 区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%8C%E5%89%8D%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">
          第三次握手是可以携带数据的，前两次握手是不可以携带数据的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E3%80%8C%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%8D%E5%92%8C%E3%80%8C%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">
          不使用「两次握手」和「四次握手」的原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81"><span class="toc-number">7.</span> <span class="toc-text">
          为什么需要 TIME_WAIT 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">8.</span> <span class="toc-text">
          为什么需要四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">
          什么是拆包粘包：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">
          网络层 - IP数据报分片：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4%E5%92%8CIPv6%E9%A6%96%E9%83%A8%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">11.</span> <span class="toc-text">
          IPv4和IPv6首部的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">
          TCP 如何保证可靠性传输：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">
          交换机和路由器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">
          集线器和交换机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">
          网桥和交换机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9A"><span class="toc-number">16.</span> <span class="toc-text">
          介绍一下TCP的拥塞控制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9A"><span class="toc-number">17.</span> <span class="toc-text">
          拥塞控制和流量控制的差别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ip%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%94%A8%E6%9D%A5%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">18.</span> <span class="toc-text">
          Ip协议中用来分片和重组的依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">19.</span> <span class="toc-text">
          DHCP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">20.</span> <span class="toc-text">
          ARP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">21.</span> <span class="toc-text">
          ICMP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AERIP"><span class="toc-number">22.</span> <span class="toc-text">
          路由选择协议RIP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number">23.</span> <span class="toc-text">
          BGP-外部网关路由协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">24.</span> <span class="toc-text">
          路由器中三种典型的交换结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Telnet"><span class="toc-number">25.</span> <span class="toc-text">
          远程登录Telnet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP"><span class="toc-number">26.</span> <span class="toc-text">
          文件传输协议FTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">
          传输层是干嘛的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E8%80%8C%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%8D%B4%E5%8F%AA%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">
          为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%94%B9%E6%88%90%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%90%97%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">
          为什么连接建立的时候是三次握手，可以改成两次握手吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E5%8A%A8%E6%96%AD%E5%BC%80%E6%96%B9%E5%9C%A8TIME-WAIT%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%852MSL%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">
          为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AFClient%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">
          如果已经建立了连接，但是Client端突然出现故障了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text">
          说下网络中的主机通信流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSocket"><span class="toc-number">33.</span> <span class="toc-text">
          介绍一下Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-number">34.</span> <span class="toc-text">
          HTTP和HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSMA-x2F-CD%E5%8D%8F%E8%AE%AE"><span class="toc-number">35.</span> <span class="toc-text">
          CSMA&#x2F;CD协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%85%85%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">
          如何扩充局域网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">37.</span> <span class="toc-text">
          私有地址的范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%99%9A%E7%94%B5%E8%B7%AF"><span class="toc-number">38.</span> <span class="toc-text">
          介绍一下虚电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E3%80%81%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">39.</span> <span class="toc-text">
          电路交换、报文交换、分组交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSYN%E6%B4%AA%E6%B3%9B"><span class="toc-number">40.</span> <span class="toc-text">
          什么是SYN洪泛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">41.</span> <span class="toc-text">
          cookie 和 session 的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%8D%B3%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">42.</span> <span class="toc-text">
          一个完整的http请求是怎么样？即从输入网址到获得页面的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">
          http的长连接和短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">44.</span> <span class="toc-text">
          get和 post 请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">45.</span> <span class="toc-text">
          Http 常见的状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-UDP"><span class="toc-number">46.</span> <span class="toc-text">
          DNS 为什么用 UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">
          保活计时器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">
          UDP 如何实现可靠传输？</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">time_cool</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/timecool-cpu" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/shi-guang-85-73-85" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>水水水</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>