<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="[TOC]                     操作系统的功能       作为资源的管理者  进程管理: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题 内存管理：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成">
<meta property="og:type" content="article">
<meta property="og:title" content="保研复习之操作系统">
<meta property="og:url" content="http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="时光cool的博客仓库">
<meta property="og:description" content="[TOC]                     操作系统的功能       作为资源的管理者  进程管理: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题 内存管理：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210607160841587.png">
<meta property="og:image" content="https://image.iamshuaidi.com/picture/ed523051-608f-4c3f-b343-383e2d194470.png">
<meta property="og:image" content="https://image.iamshuaidi.com/picture/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png">
<meta property="og:image" content="https://image.iamshuaidi.com/picture/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png">
<meta property="og:image" content="https://image.iamshuaidi.com/picture/image-20210907124303344.png">
<meta property="og:image" content="https://image.iamshuaidi.com/picture/v2-1dfd23c107cca552b4e511ed526f75c4_720w.jpg">
<meta property="article:published_time" content="2022-10-05T12:52:25.178Z">
<meta property="article:modified_time" content="2022-10-05T12:59:27.533Z">
<meta property="article:author" content="水水水">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210607160841587.png"><title>保研复习之操作系统 | 时光cool的博客仓库</title><link ref="canonical" href="http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="时光cool的博客仓库" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">时光cool的博客仓库</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">保研复习之操作系统</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><p>[TOC]</p>

        <h3 id="操作系统的功能"   >
          <a href="#操作系统的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3>
      <p>作为资源的管理者</p>
<ul>
<li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li>
<li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li>
<li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li>
</ul>

        <h3 id="操作系统的特征"   >
          <a href="#操作系统的特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3>
      <p>并发性：是在计算机系统中同时存在多个程序，宏观上看，这些程序是同时向前推进的。 在单CPU上，这些并发执行的程序是交替在CPU上运行的。 </p>
<p>共享性：资源共享是操作系统程序和多个用户程序共用系统中的资源。</p>
<p>异步性：即不确定性。同一程序和数据的多次运行可能得到不同的结果；程序的运行时间、运行顺序也具有不确定性；外部输入的请求、运行故障发生的时间难以预测。这些都是不确定性的表现</p>
<p>虚拟：是指通过技术将一个物理实体变成若干个逻辑上的对应物。在操作系统中虚拟的实现主要是通过分时的使用方法。显然，如果n是某一个物理设备所对应的虚拟逻辑设备数，则虚拟设备的速度必然是物理设备速度的1&#x2F;n。</p>

        <h3 id="处理器的三级调度"   >
          <a href="#处理器的三级调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a><strong>处理器的三级调度</strong></h3>
      <p>高级调度（作业调度）：作业从磁盘调入内存所采取的调度算法，先来先服务调度算法、短作业优先调度算法 </p>
<p>中级调度：外存对换区的具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待。内存中暂时不能运行的进程对换到外存兑换区，此时状态为挂起状态。 </p>
<p>进程调度：采用什么样的算法将处理器分配给进程 </p>

        <h3 id="线程、进程、管程的区别？"   >
          <a href="#线程、进程、管程的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程、进程、管程的区别？" class="headerlink" title="线程、进程、管程的区别？"></a>线程、进程、管程的区别？</h3>
      <p>进程：是系统进行资源分配的基本单位，创建一个进程，系统会为其分配相应的内存空间等资源。（我们平时用的exe类型的就是一个进程，比如WeChat和QQ以及浏览器）。一个进程可以拥有一个或者多个线程，线程的引入增加了并发度。 </p>
<p>线程：是轻量型进程，由进程创建，是系统进行独立调度和分配的基本单位，线程会与同属于一个进程的其他线程共享该进程所具备的资源，但是线程本身也具备一些自己特有的信息，比如程序寄存器等。 </p>
<p>管程：定义了一个<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。面向对象思想，表征共享资源的数据结构及其对数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节。 </p>
<p>进程定义的是私有数据结构PCB，管程定义的是公共数据结构 </p>

        <h3 id="什么是死锁？死锁产生的条件？如何处理死锁问题"   >
          <a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="headerlink" title="什么是死锁？死锁产生的条件？如何处理死锁问题"></a>什么是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020" >死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>？死锁产生的条件？<strong>如何处理死锁问题</strong></h3>
      <p>死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。</p>
<p><img src="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210607160841587.png" alt="image-20210607160841587"></p>
<p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。 </p>

        <h3 id="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"   >
          <a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="headerlink" title="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"></a><strong>死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）</strong></h3>
      <p>互斥条件：一个资源一次只能被一个进程使用</p>
<p>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</p>
<p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</p>
<p>常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略 </p>

        <h3 id="解决死锁的基本方法？"   >
          <a href="#解决死锁的基本方法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决死锁的基本方法？" class="headerlink" title="解决死锁的基本方法？"></a>解决死锁的基本方法？</h3>
      <ol>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ol>

        <h3 id="怎么预防死锁？"   >
          <a href="#怎么预防死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么预防死锁？" class="headerlink" title="怎么预防死锁？"></a>怎么预防死锁？</h3>
      <ol>
<li>破坏请求条件：一次性分配所有资源，这样就不会再有请求了；</li>
<li>破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：</li>
<li>破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；</li>
<li>破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。</li>
</ol>

        <h3 id="怎么避免死锁？"   >
          <a href="#怎么避免死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h3>
      <p><strong>1. 安全状态</strong></p>
<p><img src="https://image.iamshuaidi.com/picture/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<p><strong>2. 单个资源的银行家算法</strong></p>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="https://image.iamshuaidi.com/picture/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<p><strong>3. 多个资源的银行家算法</strong></p>
<p><img src="https://image.iamshuaidi.com/picture/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>

        <h3 id="怎么解除死锁？"   >
          <a href="#怎么解除死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么解除死锁？" class="headerlink" title="怎么解除死锁？"></a>怎么解除死锁？</h3>
      <ol>
<li>资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；</li>
<li>撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；</li>
<li>进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>

        <h3 id="windows和linux系统有什么区别"   >
          <a href="#windows和linux系统有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#windows和linux系统有什么区别" class="headerlink" title="windows和linux系统有什么区别?"></a>windows和linux系统有什么区别?</h3>
      <p>linux是免费开源的，windows是微软开发需要付费且用户无法修改的。</p>
<p>软件的兼容性windows更好，比较的丰富。</p>
<p>linux有很多的发行版本，易用性没有windows那么好。</p>
<p>因为用的更加普及，在windows平台的病毒更多。</p>
<p>linux比较的稳定，因此很多服务器都是用linux</p>

        <h3 id="如何创建进程，如何创建线程？"   >
          <a href="#如何创建进程，如何创建线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建进程，如何创建线程？" class="headerlink" title="如何创建进程，如何创建线程？"></a>如何创建进程，如何创建线程？</h3>
      <p>linux使用fork()和thread()来创建</p>
<p>windows使用clone()来创建</p>

        <h3 id="单线程进程一定比多线程进行慢吗？"   >
          <a href="#单线程进程一定比多线程进行慢吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程进程一定比多线程进行慢吗？" class="headerlink" title="单线程进程一定比多线程进行慢吗？"></a>单线程进程一定比多线程进行慢吗？</h3>
      <p>不一定，多线程存在上下文切换。</p>
<p>分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑。 </p>

        <h3 id="进程之间的通信方式"   >
          <a href="#进程之间的通信方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a><strong>进程之间的通信方式</strong></h3>
      <p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。 </p>
<p><strong>管道</strong></p>
<p>它是半双工的，具有固定的读端和写端；<br>它只能用于父子进程或者兄弟进程之间的进程的通信；</p>
<p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p><strong>命名管道</strong></p>
<p>FIFO 可以在无关的进程之间交换数据，与无名管道不同；<br>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<p><strong>消息队列</strong></p>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；<br>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</p>
<p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；</p>
<p>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p>
<p><strong>信号量</strong></p>
<p>信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；<br>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</p>
<p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</p>
<p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</p>
<p>支持信号量组。</p>
<p><strong>共享内存</strong></p>
<p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；</p>
<p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>

        <h3 id="进程同步应遵循的原则"   >
          <a href="#进程同步应遵循的原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程同步应遵循的原则" class="headerlink" title="进程同步应遵循的原则"></a><strong>进程同步应遵循的原则</strong></h3>
      <p>空闲让进：当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。所以基本上不存在等待进程为n的情况。</p>
<p>忙则等待：当已有进程进入自己的临界区时，即相应的临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</p>
<p>有限等待：对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</p>
<p>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等</p>

        <h3 id="分页和分段有什么区别"   >
          <a href="#分页和分段有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#分页和分段有什么区别" class="headerlink" title="分页和分段有什么区别"></a>分页和分段有什么区别</h3>
      <ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ol>
<p>段页式：先分段、再分页</p>

        <h3 id="临界区？"   >
          <a href="#临界区？" class="heading-link"><i class="fas fa-link"></i></a><a href="#临界区？" class="headerlink" title="临界区？"></a>临界区？</h3>
      <p>每个进程中访问临界资源的那段代码称为临界区 </p>
<p>每次只允许一个进程进入临界区 </p>
<p>通过互斥进入来实现对临界资源的互斥访问</p>

        <h3 id="文件管理系统管理的对象"   >
          <a href="#文件管理系统管理的对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件管理系统管理的对象" class="headerlink" title="文件管理系统管理的对象"></a>文件管理系统管理的对象</h3>
      <ol>
<li><strong>文件</strong>。在文件系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li>
<li><strong>目录</strong>。为了方便用户对文件的存取和检索，在文件系统中必须配置目录，在目录的每个目录项中，必须含有文件名、对文件属性的说明，以及该文件所在的物理地址（或指针）。对目录的组织和管理，是方便用户和提高对文件存取速度的关键。</li>
<li><strong>磁盘（磁带）存储空间</strong>。文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li>
</ol>

        <h3 id="简单说下你对并发和并行的理解？"   >
          <a href="#简单说下你对并发和并行的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单说下你对并发和并行的理解？" class="headerlink" title="简单说下你对并发和并行的理解？"></a>简单说下你对并发和并行的理解？</h3>
      <ol>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；</li>
</ol>

        <h3 id="同步、异步、阻塞、非阻塞的概念"   >
          <a href="#同步、异步、阻塞、非阻塞的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步、异步、阻塞、非阻塞的概念" class="headerlink" title="同步、异步、阻塞、非阻塞的概念"></a>同步、异步、阻塞、非阻塞的概念</h3>
      <p><strong>同步</strong>：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。</p>
<p><strong>异步</strong>：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p><strong>阻塞</strong>：是指调用结果返回前，当前线程会被挂起，即阻塞。</p>
<p><strong>非阻塞</strong>：是指即使调用结果没返回，也不会阻塞当前线程。</p>

        <h3 id="为什么有了进程，还要有线程呢？"   >
          <a href="#为什么有了进程，还要有线程呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么有了进程，还要有线程呢？" class="headerlink" title="为什么有了进程，还要有线程呢？"></a>为什么有了进程，还要有线程呢？</h3>
      <p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：</p>
<p>进程在同一时间只能干一件事情；<br>进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。</p>
<p>基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。</p>

        <h3 id="进程的状态转换"   >
          <a href="#进程的状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3>
      <p>进程包括三种状态：就绪态、运行态和阻塞态。</p>
<p><img src="https://image.iamshuaidi.com/picture/image-20210907124303344.png" alt="image-20210907124303344"></p>
<ol>
<li><p>就绪 —&gt; 执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
</li>
<li><p>执行 —&gt; 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入&#x2F;输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p>
</li>
<li><p>阻塞 —&gt; 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入&#x2F;输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
</li>
<li><p>执行 —&gt; 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
</li>
</ol>

        <h3 id="什么是缓冲区溢出？有什么危害？"   >
          <a href="#什么是缓冲区溢出？有什么危害？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是缓冲区溢出？有什么危害？" class="headerlink" title="什么是缓冲区溢出？有什么危害？"></a>什么是缓冲区溢出？有什么危害？</h3>
      <p>缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。 </p>

        <h3 id="物理地址、逻辑地址、虚拟内存的概念"   >
          <a href="#物理地址、逻辑地址、虚拟内存的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理地址、逻辑地址、虚拟内存的概念" class="headerlink" title="物理地址、逻辑地址、虚拟内存的概念"></a>物理地址、逻辑地址、虚拟内存的概念</h3>
      <ol>
<li>物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。</li>
<li>逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</li>
<li>虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li>
</ol>

        <h3 id="页面置换算法有哪些？"   >
          <a href="#页面置换算法有哪些？" class="heading-link"><i class="fas fa-link"></i></a><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h3>
      <p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。常用的页面置换算法如下：</p>
<ul>
<li><strong>先进先出置换算法（FIFO）</strong></li>
</ul>
<p>先进先出，即淘汰最早调入的页面。</p>
<ul>
<li><strong>最佳置换算法（OPT）</strong></li>
</ul>
<p>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</p>
<ul>
<li><strong>最近最久未使用（LRU）算法</strong></li>
</ul>
<p>即选择最近最久未使用的页面予以淘汰</p>
<ul>
<li><strong>时钟（Clock）置换算法</strong></li>
</ul>
<p>时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。</p>

        <h3 id="谈谈你对动态链接库和静态链接库的理解？"   >
          <a href="#谈谈你对动态链接库和静态链接库的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对动态链接库和静态链接库的理解？" class="headerlink" title="谈谈你对动态链接库和静态链接库的理解？"></a>谈谈你对动态链接库和静态链接库的理解？</h3>
      <p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。</p>
<p>动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能</p>

        <h3 id="外中断和异常有什么区别？"   >
          <a href="#外中断和异常有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#外中断和异常有什么区别？" class="headerlink" title="外中断和异常有什么区别？"></a>外中断和异常有什么区别？</h3>
      <p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>

        <h3 id="一个程序从开始运行到结束的完整过程，你能说出来多少？"   >
          <a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="headerlink" title="一个程序从开始运行到结束的完整过程，你能说出来多少？"></a>一个程序从开始运行到结束的完整过程，你能说出来多少？</h3>
      <p>四个过程：</p>
<p><strong>（1）预编译</strong> 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p><strong>（2）编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p><strong>（3）汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p><strong>（4）链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p><strong>1、静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p><strong>2、动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>

        <h3 id="什么是用户态和内核态"   >
          <a href="#什么是用户态和内核态" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3>
      <p>用户态和内核态是操作系统的两种运行状态。</p>
<ul>
<li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li>
<li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<blockquote>
<p>那么为什么要有用户态和内核态呢？</p>
</blockquote>
<p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>

        <h3 id="用户态和内核态是如何切换的？"   >
          <a href="#用户态和内核态是如何切换的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h3>
      <p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p>
<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p>
<p>他们的工作流程如下：</p>
<p><img src="https://image.iamshuaidi.com/picture/v2-1dfd23c107cca552b4e511ed526f75c4_720w.jpg" alt="img"></p>
<ul>
<li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li>
<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ul>

        <h3 id="进程终止的方式"   >
          <a href="#进程终止的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程终止的方式" class="headerlink" title="进程终止的方式"></a>进程终止的方式</h3>
      <p><strong>进程的终止</strong></p>
<p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误退出(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<p><strong>正常退出</strong></p>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p>
<p><strong>错误退出</strong></p>
<p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></div></figure>

<p>Text</p>
<p>Copy</p>
<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<p><strong>严重错误退出</strong></p>
<p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<p><strong>被其他进程杀死</strong></p>
<p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>

        <h3 id="守护进程、僵尸进程和孤儿进程"   >
          <a href="#守护进程、僵尸进程和孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程、僵尸进程和孤儿进程" class="headerlink" title="守护进程、僵尸进程和孤儿进程"></a>守护进程、僵尸进程和孤儿进程</h3>
      
        <h5 id="守护进程"   >
          <a href="#守护进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5>
      <p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>

        <h5 id="孤儿进程"   >
          <a href="#孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5>
      <p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>

        <h5 id="僵尸进程"   >
          <a href="#僵尸进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5>
      <p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>

        <h3 id="如何避免僵尸进程？"   >
          <a href="#如何避免僵尸进程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何避免僵尸进程？" class="headerlink" title="如何避免僵尸进程？"></a>如何避免僵尸进程？</h3>
      <ul>
<li>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</li>
<li>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</li>
<li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</li>
<li>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</li>
</ul>
<p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p>

        <h3 id="介绍一下几种典型的锁？"   >
          <a href="#介绍一下几种典型的锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下几种典型的锁？" class="headerlink" title="介绍一下几种典型的锁？"></a>介绍一下几种典型的锁？</h3>
      
        <h5 id="读写锁"   >
          <a href="#读写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5>
      <ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>

        <h5 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5>
      <p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>

        <h5 id="条件变量"   >
          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5>
      <p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>

        <h5 id="自旋锁"   >
          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5>
      <p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>

        <h3 id="常见内存分配内存错误"   >
          <a href="#常见内存分配内存错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见内存分配内存错误" class="headerlink" title="常见内存分配内存错误"></a>常见内存分配内存错误</h3>
      <p>（1）内存分配未成功，却使用了它。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>（5）释放了内存却继续使用它。常见于以下有三种情况：</p>

        <h3 id="内存交换中，被换出的进程保存在哪里？"   >
          <a href="#内存交换中，被换出的进程保存在哪里？" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存交换中，被换出的进程保存在哪里？" class="headerlink" title="内存交换中，被换出的进程保存在哪里？"></a>内存交换中，被换出的进程保存在哪里？</h3>
      <p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。 </p>

        <h3 id="原子操作的是如何实现的"   >
          <a href="#原子操作的是如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#原子操作的是如何实现的" class="headerlink" title="原子操作的是如何实现的"></a>原子操作的是如何实现的</h3>
      <p><strong>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</strong></p>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p>（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。</p>
<p>处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p>
<p>（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>

        <h3 id="什么是虚拟内存"   >
          <a href="#什么是虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3>
      <p>传统的内存空间分配方式需要将作业一次性调入内存，太占空间，而程序运行的时候是有局部性的，可以将需要的调入内存，不需要的调出内存。</p>
<p>局部性原理：</p>
<p>①时间局部性：一条指令运行后，不久可能再次运行；数据被访问后，不久可能再次访问（因程序中有大量循环）</p>
<p>②空间局部性：程序访问了某个存储单元，与这个存储单元相邻的可能被再次访问（因为指令按顺序存放；数据是簇聚存储的）</p>
<p>实现方式：在非连续分配管理的基础上 引入了中断机制        一条指令执行期间可能产生多次缺页中断</p>
<p>1）请求分页存储管理        2）请求分段存储管理        3）段页式存储管理</p>
<p>在发生缺页后 发送缺页中断调入所缺页 若内存已满 要进行页面置换</p>

        <h3 id="I-x2F-O控制方式："   >
          <a href="#I-x2F-O控制方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O控制方式：" class="headerlink" title="I&#x2F;O控制方式："></a><strong>I&#x2F;O控制方式：</strong></h3>
      <p>1）程序控制方式：CPU不断查询I&#x2F;O设备是否已经做好准备               </p>
<p>2）中断驱动方式（程序中断方式）：I&#x2F;O准备好数据 才发生中断通知CPU传数据</p>
<p>3）DMA方式：主存和I&#x2F;O之间有一条数据通路，传输数据由DMA负责，传完一个或多个数据块 通知CPU                    </p>
<p>4）通道控制方式：将数据传到哪 以及数据的传输都交给通道</p>

        <h3 id="介绍下假脱机-Spooling-技术"   >
          <a href="#介绍下假脱机-Spooling-技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下假脱机-Spooling-技术" class="headerlink" title="介绍下假脱机(Spooling)技术"></a>介绍下<strong>假脱机(Spooling)技术</strong></h3>
      <p>通俗的讲，为了将独占的设备转化为逻辑上共享的设备，就是设备被占用，往设备发送的数据就先在磁盘暂存一下，等设备空闲再输入设备</p>
<p>组成：输入&#x2F; 出设备 输入&#x2F;出缓冲区 输入&#x2F;出井</p>
<p>常见应用：共享打印机</p>

        <h3 id="DMA和中断方式的主要区别"   >
          <a href="#DMA和中断方式的主要区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA和中断方式的主要区别" class="headerlink" title="DMA和中断方式的主要区别"></a><strong>DMA和中断方式的主要区别</strong></h3>
      <p>1）谁控制数据传输：DMA方式是由DMA控制；中断方式是CPU控制</p>
<p>2）优先级：DMA中断优先级大于普通I&#x2F;O中断</p>
<p>3）中断相应的时机：DMA方式可以在每个机器周期结束时候响应；中断方式只能在指令执行周期结束后响应</p>
<p>4）DMA方式在结束一个数据块传送后才发中断；中断方式每传输一个字就要中断</p>

        <h3 id="程序中断和子程序调用的区别"   >
          <a href="#程序中断和子程序调用的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序中断和子程序调用的区别" class="headerlink" title="程序中断和子程序调用的区别"></a><strong>程序中断和子程序调用的区别</strong></h3>
      <p>1）调用子程序的CALL指令的时机是固定的；中断是随机发生的</p>
<p>2）子程序的调用只涉及到软件；中断是软硬结合的过程</p>
<p>3）子程序由调用指令直接给出目标地址；中断要通过中断隐指令得到中断向量</p>

        <h3 id="什么是上下文切换"   >
          <a href="#什么是上下文切换" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3>
      <p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 <strong>将 CPU 资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。 </p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">水水水</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/10/05/%E6%A6%82%E7%8E%87%E8%AE%BA/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">保研复习之概率论</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/10/05/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"><span class="paginator-prev__text">保研复习之英语单词</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">
          操作系统的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.</span> <span class="toc-text">
          操作系统的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">
          处理器的三级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">
          线程、进程、管程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">
          什么是死锁？死锁产生的条件？如何处理死锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9A%EF%BC%88%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%88%90%E7%AB%8B%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">
          死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">
          解决死锁的基本方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">
          怎么预防死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">
          怎么避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">
          怎么解除死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E5%92%8Clinux%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">
          windows和linux系统有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">
          如何创建进程，如何创建线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%B8%80%E5%AE%9A%E6%AF%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%85%A2%E5%90%97%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">
          单线程进程一定比多线程进行慢吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">
          进程之间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">15.</span> <span class="toc-text">
          进程同步应遵循的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">
          分页和分段有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">
          临界区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.</span> <span class="toc-text">
          文件管理系统管理的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%E4%BD%A0%E5%AF%B9%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">
          简单说下你对并发和并行的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">20.</span> <span class="toc-text">
          同步、异步、阻塞、非阻塞的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">
          为什么有了进程，还要有线程呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">22.</span> <span class="toc-text">
          进程的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">
          什么是缓冲区溢出？有什么危害？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">24.</span> <span class="toc-text">
          物理地址、逻辑地址、虚拟内存的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">
          页面置换算法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">
          谈谈你对动态链接库和静态链接库的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">
          外中断和异常有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">
          一个程序从开始运行到结束的完整过程，你能说出来多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">29.</span> <span class="toc-text">
          什么是用户态和内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">
          用户态和内核态是如何切换的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">31.</span> <span class="toc-text">
          进程终止的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text">
          守护进程、僵尸进程和孤儿进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">32.0.1.</span> <span class="toc-text">
          守护进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">32.0.2.</span> <span class="toc-text">
          孤儿进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">32.0.3.</span> <span class="toc-text">
          僵尸进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">
          如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">
          介绍一下几种典型的锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">34.0.1.</span> <span class="toc-text">
          读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">34.0.2.</span> <span class="toc-text">
          互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">34.0.3.</span> <span class="toc-text">
          条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">34.0.4.</span> <span class="toc-text">
          自旋锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-number">35.</span> <span class="toc-text">
          常见内存分配内存错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">
          内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">37.</span> <span class="toc-text">
          原子操作的是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">38.</span> <span class="toc-text">
          什么是虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">39.</span> <span class="toc-text">
          I&#x2F;O控制方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%81%87%E8%84%B1%E6%9C%BA-Spooling-%E6%8A%80%E6%9C%AF"><span class="toc-number">40.</span> <span class="toc-text">
          介绍下假脱机(Spooling)技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E5%92%8C%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">41.</span> <span class="toc-text">
          DMA和中断方式的主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">42.</span> <span class="toc-text">
          程序中断和子程序调用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">43.</span> <span class="toc-text">
          什么是上下文切换</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">time_cool</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/timecool-cpu" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/shi-guang-85-73-85" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">17</div><div class="sidebar-ov-state-item__name">归档</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>水水水</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>