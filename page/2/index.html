<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="时光cool的博客仓库">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="时光cool的博客仓库">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="水水水">
<meta name="twitter:card" content="summary"><title>时光cool的博客仓库</title><link ref="canonical" href="http://example.com/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="时光cool的博客仓库" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">时光cool的博客仓库</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">保研复习之离散数学</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="关键词："   >
          <a href="#关键词：" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3>
      <ul>
<li><input disabled="" type="checkbox"> 命题、主析取范式、主合取范式、极小项、极大项</li>
<li><input disabled="" type="checkbox"> 个体词、谓词、量词 </li>
<li><input disabled="" type="checkbox"> P规则、T规则、CP规则</li>
<li><input disabled="" type="checkbox"> 辖域、自由变元、约束变元</li>
<li><input disabled="" type="checkbox"> 环和、环积，幂集，补集，对称差集，笛卡尔乘积，文氏图</li>
<li><input disabled="" type="checkbox"> 关系的定义域、值域、域、逆、合成、限制和像 </li>
<li><input disabled="" type="checkbox"> 自反、对称、传递、偏序关系 </li>
<li><input disabled="" type="checkbox"> 闭包、自反闭包、对称闭包、传递闭包</li>
<li><input disabled="" type="checkbox"> 覆盖、划分、等价关系、等价类</li>
<li><input disabled="" type="checkbox"> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%88%E6%96%AF%E5%9B%BE&spm=1001.2101.3001.7020" >哈斯图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、上下界、偏序</li>
<li><input disabled="" type="checkbox"> 幺元、零元、逆元</li>
<li><input disabled="" type="checkbox"> 代数、半群、独异点、群、阿贝尔群、循环独异点、生成元</li>
<li><input disabled="" type="checkbox"> 简单图、平凡图、多重图、线图、子图、补图、出度、入度、同构</li>
<li><input disabled="" type="checkbox"> 出度、入度、度、同构、子图、真子图、生成子图、有向完全图、无向完全图、补图</li>
<li><input disabled="" type="checkbox"> 连通图、单向连通图、弱连通图、强连通图、基图、连通分图、点连通度、边连通度</li>
<li><input disabled="" type="checkbox"> 基本路径、基本回路、简单路径、简单回路</li>
<li><input disabled="" type="checkbox"> 欧拉路径、欧拉回路、欧拉图、哈密顿路径、哈密顿回路、哈密顿图、哈密尔顿图、欧拉公式</li>
<li><input disabled="" type="checkbox"> 树、无向树、平凡树、森林、连通分支、树叶、分支点、生成树、树枝、弦、余树、Kruskal</li>
</ul>

        <h3 id="主析取范式和主合取范式"   >
          <a href="#主析取范式和主合取范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h3>
      <p>极小项是若命题变元或其否定的合取∧；</p>
<p>极大项是若命题变元或其否定的析取∨； </p>
<p><img src="C:\Users\86150\AppData\Local\Temp\1656988084687.png" alt="1656988084687"></p>

        <h3 id="推理规则"   >
          <a href="#推理规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3>
      <p>P规则：就是直接利用推理中给出的前提，即前提引入。</p>
<p>T规则：就是由某一个或几个前提可以通过等价、蕴含得到其他命题公式，即推理规则。 </p>
<p>I表示在T规则中通过蕴含式推出其他命题公式，即推理规则中的蕴含推理。</p>
<p>E表示在T规则中通过等价式推出其他命题公式，即推理规则中的置换规则。 </p>
<p>CP(Conditional Proof)规则，若证明AB→C, B可作为附加前提引入。通俗点说，就是咱在做证明题时，看到待证结论是B→C这样的，把B当作前提来用，这就是CP规则。 </p>

        <h3 id="代数、半群、独异点、群、阿贝尔群之间的关系"   >
          <a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="headerlink" title="代数、半群、独异点、群、阿贝尔群之间的关系"></a>代数、半群、独异点、群、阿贝尔群之间的关系</h3>
      <p><img src="C:\Users\86150\AppData\Local\Temp\1657009248374.png" alt="1657009248374"></p>

        <h3 id="欧拉图和哈密顿图"   >
          <a href="#欧拉图和哈密顿图" class="heading-link"><i class="fas fa-link"></i></a><a href="#欧拉图和哈密顿图" class="headerlink" title="欧拉图和哈密顿图"></a>欧拉图和哈密顿图</h3>
      <p>欧拉回路：若存在一条从起点S出发的路径，每条边恰好只走一次，最终回到起点S的路径被称为欧拉路径。</p>
<p>欧拉通路：若存在一条从起点S出发的路径，经过每条边一次，但是不要求回到起点S的路径被称作欧拉通路。</p>
<p>哈密顿路径：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级路径</p>
<p>哈密顿回路：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级回路</p>
<p>哈密顿图：具有哈密顿回路的无向图</p>
<p>欧拉公式：n-m+k&#x3D;2</p>

        <h3 id="离散数学讲了什么"   >
          <a href="#离散数学讲了什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#离散数学讲了什么" class="headerlink" title="离散数学讲了什么"></a>离散数学讲了什么</h3>
      <p>数理逻辑，二元关系，群与环，数论什么的，是一门比较抽象的学科，主要作用是建立相关的数学模型，把实际问题抽象成为计算机能够理解的逻辑结构，并且用计算机的思维去解决实际问题，往往实际用的不多，主要是训练思维。</p>

        <h3 id="什么是完全图？"   >
          <a href="#什么是完全图？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是完全图？" class="headerlink" title="什么是完全图？"></a>什么是完全图？</h3>
      <p>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图<br>在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图</p>

        <h3 id="什么是群？"   >
          <a href="#什么是群？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是群？" class="headerlink" title="什么是群？"></a>什么是群？</h3>
      <p>代数系统封闭性 结合律 他就是 半群 含有单位元 就是含幺半群 有逆元就是 群</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E8%AE%A1%E7%BD%91/">保研复习之计算机网络</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[TOC]</p>

        <h3 id="TCP-x2F-IP-网络模型有哪几层？"   >
          <a href="#TCP-x2F-IP-网络模型有哪几层？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h3>
      <p>4层：应用层、传输层、网络层、网络套接层</p>

        <h3 id="流量控制和拥塞控制有什么区别？"   >
          <a href="#流量控制和拥塞控制有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制和拥塞控制有什么区别？" class="headerlink" title="流量控制和拥塞控制有什么区别？"></a>流量控制和拥塞控制有什么区别？</h3>
      <p>流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的；</p>
<p>拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。 </p>

        <h3 id="https和http相比有什么区别"   >
          <a href="#https和http相比有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#https和http相比有什么区别" class="headerlink" title="https和http相比有什么区别"></a>https和http相比有什么区别</h3>
      <ol>
<li>建立连接时候：https 比 http多了 TLS 的握手过程；</li>
<li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li>
</ol>

        <h3 id="TCP-和-UDP-区别："   >
          <a href="#TCP-和-UDP-区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-和-UDP-区别：" class="headerlink" title="TCP 和 UDP 区别："></a><strong>TCP 和 UDP 区别：</strong></h3>
      <p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。慢开始、拥塞避免、快重传、快恢复 </li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>

        <h3 id="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"   >
          <a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="headerlink" title="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"></a><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></h3>
      <ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>

        <h3 id="不使用「两次握手」和「四次握手」的原因："   >
          <a href="#不使用「两次握手」和「四次握手」的原因：" class="heading-link"><i class="fas fa-link"></i></a><a href="#不使用「两次握手」和「四次握手」的原因：" class="headerlink" title="不使用「两次握手」和「四次握手」的原因："></a>不使用「两次握手」和「四次握手」的原因：</h3>
      <p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。 </p>
<p>（1）三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p>
<p>（2）三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>

        <h3 id="为什么需要-TIME-WAIT-状态"   >
          <a href="#为什么需要-TIME-WAIT-状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h3>
      <p>TIME_WAIT 状态持续 2MSL（最大报文存活时间），约4分钟才转换成CLOSE状态。由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接，TIME_WAIT 的主要作用有：</p>
<p>（1）重发丢失的 ACK 报文，保证连接可靠的关闭：</p>
<blockquote>
<p>由于网络等原因，无法保证最后一次挥手的 ACK 报文一定能传送给对方，如果 ACK 丢失，对方会超时重传 FIN，主动关闭端会再次响应ACK过去；如果没有 TIME_WAIT 状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。同时，服务器就因为接收不到客户端的信息而无法正常关闭。</p>
</blockquote>
<p>（2）保证本次连接的重复数据段从网络中消失：</p>
<blockquote>
<p>如果存在两个连接，第一个连接正常关闭，第二个相同的连接紧接着建立；如果第一个连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达，则会干扰第二连接，等待 2MSL 可以让上次连接的报文数据消逝在网络中。</p>
</blockquote>

        <h3 id="为什么需要四次挥手"   >
          <a href="#为什么需要四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3>
      <p>TCP 是全双工模式，并且支持半关闭特性，提供了连接的一端在结束发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>

        <h3 id="什么是拆包粘包："   >
          <a href="#什么是拆包粘包：" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是拆包粘包：" class="headerlink" title="什么是拆包粘包："></a><strong>什么是拆包粘包：</strong></h3>
      <p>拆包粘包在数据链路层、网络层以及传输层都可能存在。而在传输层中，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。 </p>

        <h3 id="网络层-IP数据报分片："   >
          <a href="#网络层-IP数据报分片：" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层-IP数据报分片：" class="headerlink" title="网络层 - IP数据报分片："></a><strong>网络层 - IP数据报分片：</strong></h3>
      <p>​	 MTU 是数据链路层中的网络对数据帧的一个限制（以太网中 MTU 为1500个字节），一个 IP 数据报在以太网中传输，如果它的长度大于 MTU 值，就要进行分片传输，使得每片数据报的长度小于 MTU。而分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装，IP数据报的分片与重组是在网络层进完成的。</p>
<p>​        前面提到，MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 在建立连接时通常会协商双方的 MSS 值（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（IP 数据包包头的大小 20 Bytes 和 TCP 数据段的包头 20 Bytes），TCP报文段的分段与重组是在传输层完成的。</p>
<blockquote>
<p>如果用链路层以太网，MSS的值往往为1460。而 Internet 上标准的 MTU（最小的 MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。</p>
</blockquote>
<p>​        到这里我们就能看出，TCP 分段的原因是 MSS，IP 分片的原因是 MTU，由于一直有 MSS &lt;&#x3D; MTU，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了，因此TCP报文段很少会发生IP分片的情况。</p>
<p>​        而由于 UDP 数据报不会自己进行分段，因此当长度超过了 MTU 时，会在网络层进行 IP 分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p>​        所以，总的来说，UDP 不会分段，就由 IP 来分，TCP会分段，当然就不用 IP 来分了！</p>

        <h3 id="IPv4和IPv6首部的差异"   >
          <a href="#IPv4和IPv6首部的差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4和IPv6首部的差异" class="headerlink" title="IPv4和IPv6首部的差异"></a>IPv4和IPv6首部的差异</h3>
      <p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>

        <h3 id="TCP-如何保证可靠性传输："   >
          <a href="#TCP-如何保证可靠性传输：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-如何保证可靠性传输：" class="headerlink" title="TCP 如何保证可靠性传输："></a>TCP 如何保证可靠性传输：</h3>
      <ul>
<li>（1）三次握手</li>
<li>（2）应答机制与超时重传：TCP接收端收到发送端的数据时，它将发送一个确认。当TCP发送端发出一个报文段后，它会启动一个定时器，等待接收端的确认报文段，如果不能及时收到一个确认，将重发这个报文段。</li>
<li>（3）数据包校验与丢弃重复数据：TCP会检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP会超时重发数据；对于重复数据，则进行丢弃；</li>
<li>（4）对失序数据包进行重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>（5）流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li>（6）拥塞控制：网络拥塞时，减少数据的发送。</li>
</ul>

        <h3 id="交换机和路由器的区别"   >
          <a href="#交换机和路由器的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3>
      <p>（1）工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层；</p>
<p>（2）寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址；</p>
<p>（3）转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</p>
<p>（4）交换机用于连接局域网，路由器用于连接外网和局域网</p>

        <h3 id="集线器和交换机的区别"   >
          <a href="#集线器和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器和交换机的区别" class="headerlink" title="集线器和交换机的区别"></a><strong>集线器和交换机的区别</strong></h3>
      <p>集线器和交换机都是工作在TCP&#x2F;IP协议的最后一层，数据链路（物理层），都是连接多个设备形成局域网的。<br>集线器会把接收到的数据包每次都广播给局域网局域网的所有计算机，而交换机只有首次在MAC地址表找不到记录才广播，其他时候是直接单独发送给对应MAC地址的计算机。交换机可以说是集线器的升级改良版，在集线器的基础上多了MAC地址表，可以分割冲突域，更加智能化。</p>
<p>集线器的数据传输方式是广播方式，而交换机的数据传输是有目的的，数据只对目的节点发送，只是在自己的MAC地址表中找不到的情况下第一次使用广播方式发送，然后因为交换机具有MAC地址学习功能，第二次以后就不再是广播发送了，又是有目的的发送。这样的好处是数据传输效率提高，不会出现广播风暴，在安全性方面也不会出现其它节点侦听的现象</p>

        <h3 id="网桥和交换机的区别"   >
          <a href="#网桥和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#网桥和交换机的区别" class="headerlink" title="网桥和交换机的区别"></a><strong>网桥和交换机的区别</strong></h3>
      <ul>
<li>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个输出输入端口，而交换机具有高密度的端口。所以一般的交换机，网桥就有桥接作用。</li>
<li>网桥主要由软件实现，交换机主要由硬件实现</li>
</ul>
<p>网桥也可以理解成只有两个端口的交换机，交换机可以理解成由多个网桥组成的 </p>

        <h3 id="介绍一下TCP的拥塞控制："   >
          <a href="#介绍一下TCP的拥塞控制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下TCP的拥塞控制：" class="headerlink" title="介绍一下TCP的拥塞控制："></a>介绍一下<strong>TCP的拥塞控制：</strong></h3>
      <p>拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。 </p>
<p><strong>（1）慢开始算法：</strong>当发送主机开始发送数据时，不要一开始就发送大量的数据，因为不清楚网络的拥塞情况，而是试探一下网络的拥塞情况，由小到大逐渐增大发送窗口。</p>
<p><strong>（2）拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p><strong>（3）快重传：</strong>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不必等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><strong>（4）快恢复：</strong>与快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减少”算法，把ssthresh门限设置为拥塞窗口cwnd的一半，但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法：因为如果网络出现拥塞的话，就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以此时并不执行慢开始算法，而是执行拥塞避免算法。</p>

        <h3 id="拥塞控制和流量控制的差别："   >
          <a href="#拥塞控制和流量控制的差别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制和流量控制的差别：" class="headerlink" title="拥塞控制和流量控制的差别："></a>拥塞控制和流量控制的差别：</h3>
      <p>（1）相同点：拥塞控制和流量控制的相同点都是控制丢包现象，实现机制都是让发送方发得慢一点。</p>
<p>（2）不同点：</p>
<p>① 拥塞控制是一个全局性的过程，防止过多的数据注入到网络中，造成网络拥塞</p>
<p>② 流量控制指点对点通信量的控制，要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
<p>如何判断多个数据包是属于同一个信息？以及他们的先后次序？</p>
<p>为什么网络传输中会出现丢包？</p>

        <h3 id="Ip协议中用来分片和重组的依据"   >
          <a href="#Ip协议中用来分片和重组的依据" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ip协议中用来分片和重组的依据" class="headerlink" title="Ip协议中用来分片和重组的依据"></a>Ip协议中用来分片和重组的依据</h3>
      <p>标志：根据DF来判断是否可以进行分片</p>
<p>标识：根据标识来判断原始报文和分片报文的关系</p>
<p>偏移量：收集所有的分片</p>
<p><img   src="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>
<p>一个表示网段地址、一个表示广播地址</p>
<p>网络号是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的第一个地址，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80" >广播地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E6%AE%B5&spm=1001.2101.3001.7020" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的最后一个地址，这两个地址是不能配置在计算机<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" >主机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的。 </p>

        <h3 id="DHCP协议"   >
          <a href="#DHCP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名称：动态主机配置协议</span><br><span class="line">作用：当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址</span><br><span class="line">协议：基于UDP</span><br><span class="line">工作方式：客户/服务段模式	C/S模式</span><br><span class="line">端口号：服务器在67号  客户端在68号</span><br><span class="line">过程：DHCPDISCOVER-&gt;DHCPOFFER-&gt;DHCPREQUEST-&gt;DHCPACK</span><br><span class="line">协议层：网络层</span><br></pre></td></tr></table></div></figure>




        <h3 id="ARP协议"   >
          <a href="#ARP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">名称：地址解析协议</span><br><span class="line">作用：根据IP地址获取物理地址的一个TCP/IP协议</span><br><span class="line">协议层：网络层</span><br><span class="line">过程：</span><br><span class="line">	A已知B的IP地址，需要获得B的MAC地址（物理地址）</span><br><span class="line">    如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取</span><br><span class="line">    如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组</span><br><span class="line">    在局域网上的所有节点都可以接收到ARP query</span><br><span class="line">    B接收到ARP query分组后，将自己的MAC地址发送给A</span><br><span class="line">    A在ARP表中缓存B的IP地址和MAC地址的映射关系</span><br><span class="line">    超时时删除</span><br></pre></td></tr></table></div></figure>




        <h3 id="ICMP协议"   >
          <a href="#ICMP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：互联网控制报文协议</span><br><span class="line">作用：ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</span><br><span class="line">ICMP 报文携带在IP 数据报中： IP上层协议号为1</span><br><span class="line">类型：差错报告报文、询问报文</span><br></pre></td></tr></table></div></figure>




        <h3 id="路由选择协议RIP"   >
          <a href="#路由选择协议RIP" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议RIP" class="headerlink" title="路由选择协议RIP"></a>路由选择协议RIP</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于：距离矢量算法</span><br><span class="line">衡量标准：跳数、即距离近</span><br><span class="line">基本思想：①只与邻居路由器交换信息②交换的是整个路由表</span><br><span class="line">特点：算法简单、收敛慢</span><br><span class="line">适用场景：中小网络</span><br></pre></td></tr></table></div></figure>




        <h3 id="BGP-外部网关路由协议"   >
          <a href="#BGP-外部网关路由协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#BGP-外部网关路由协议" class="headerlink" title="BGP-外部网关路由协议"></a>BGP-外部网关路由协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对于：内部网关路由协议IGP：比如RIP、OSPF等</span><br><span class="line">适用于：不同的自治域间的路由协议</span><br><span class="line">交换信息：路径通告</span><br><span class="line">基于：TCP连接用于交换BGP报文</span><br><span class="line">两类报文：eBGP用于相邻的AS，iBGP用于AS内的全部路由器（即内部）</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="路由器中三种典型的交换结构"   >
          <a href="#路由器中三种典型的交换结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器中三种典型的交换结构" class="headerlink" title="路由器中三种典型的交换结构"></a>路由器中三种典型的交换结构</h3>
      <p>共享内、共享总线、纵横式 crossbar</p>
<p><img   src="https://img-blog.csdnimg.cn/20210701184819348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>

        <h3 id="远程登录Telnet"   >
          <a href="#远程登录Telnet" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程登录Telnet" class="headerlink" title="远程登录Telnet"></a>远程登录Telnet</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用：定义客户进程与远程服务器进程之间的交互过程</span><br><span class="line">基于：TCP协议</span><br><span class="line">协议层：应用层协议</span><br><span class="line">传输数据格式：NVT网络虚拟终端（定义的一组通用字符集）</span><br><span class="line">工作过程：①建立TCP连接 </span><br><span class="line">②将本地终端上输入的用户名和口令及以后输入的任何命令或字符以网络虚拟终端NVT格式传输给远程主机</span><br><span class="line">③将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果</span><br><span class="line">④本地终端对远程主机撤销连接，从而结束 Telnet远程登录过程</span><br></pre></td></tr></table></div></figure>




        <h3 id="文件传输协议FTP"   >
          <a href="#文件传输协议FTP" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a><strong>文件传输协议FTP</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限</span><br><span class="line">实现方式：C/S模式</span><br><span class="line">协议层：应用层协议</span><br><span class="line">基于：TCP协议（21号端口）</span><br><span class="line">两个端口与两个连接：21号端口用于控制连接  20号端口用于数据连接</span><br></pre></td></tr></table></div></figure>




        <h3 id="传输层是干嘛的？"   >
          <a href="#传输层是干嘛的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层是干嘛的？" class="headerlink" title="传输层是干嘛的？"></a>传输层是干嘛的？</h3>
      <p>为主机的进程之间提供通信，是两个主机通信中第一个端对端的层次，具有缓冲作用。由于一个主机有多个进程，因此传输层具有分用复用的功能。传输层在终端用户中进行透明的数据传输，向上层提供可靠的数据传输服务。当网络层服务质量不能满足要求时（比如无法保证可靠传输）它可以将服务质量提高到达需要的要求。通过流量控制、分段&#x2F;重组、差错控制来保证数据传输的可靠性。</p>
<p>在传输层上又两个经常用到的协议：TCP和UDP，TCP可以保证可靠传输协议，它是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手来建立连接，四次挥手来中断连接。它具有拥塞控制和流量控制机制。UDP是尽最大努力交付的协议，比较的简单，没有那么多机制，对于那些数据质量要求不高但是时效性要求高的应用经常使用。</p>

        <h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"   >
          <a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3>
      <p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>

        <h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"   >
          <a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3>
      <p>主要原因有三：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p>当历史连接由于网络拥塞导致其在客户端重新请求之后，新请求达到之前先一步到达客户端，那么客户端发送的ACK便是历史的连接请求，此时客户端发现后便需要RST中断连接，但此时服务端已经是established因此会发送数据造成浪费，主要原因是两次握手「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</p>
<p>除此之外通过三次握手才能约定客户端和服务段双方的初始化序列号，如果两次的话只能确定客户端的初始化序列号。</p>
<p>如果是两次握手，当网络拥挤时由于SYN报文的丢失，会导致服务端手段多个重复的SYN，由于经过了一段时间的传输因此可能会造成多余连接的建立，造成资源浪费。</p>
<p>每次都是接收到数据包的一方可以得到对方的状态，发送的一方其实没有任何头绪。因此至少需要三次握手才能使得双方都确定对方已经完成发送数据的准备。</p>

        <h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"   >
          <a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3>
      <p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>

        <h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"   >
          <a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3>
      <p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。 </p>

        <h3 id="说下网络中的主机通信流程"   >
          <a href="#说下网络中的主机通信流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下网络中的主机通信流程" class="headerlink" title="说下网络中的主机通信流程"></a>说下网络中的主机通信流程</h3>
      <p>主机A和主机B在同一个二层网络中，直接走二层交换</p>
<p>主机A和主机B不在同一个网络中，走三层路由</p>

        <h3 id="介绍一下Socket"   >
          <a href="#介绍一下Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Socket" class="headerlink" title="介绍一下Socket"></a>介绍一下Socket</h3>
      <p>Socket是一组编程接口（API）。介于传输层和应用层，向应用层提供统一的编程接口。应用层不必了解TCP&#x2F;IP协议细节。直接通过对Socket接口函数的调用完成数据在IP网络的传输。</p>
<p>套接字&#x3D;IP地址+网络协议+端口号</p>

        <h3 id="HTTP和HTTPS"   >
          <a href="#HTTP和HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3>
      <p>他们都是应用层协议</p>
<p>HTTP协议是超文本传输协议，最初的目的是为了提供一种发布和接收HTML页面的方法</p>
<p>HTTPS是HTTP协议的安全版本，将其传输过程中的数据使用SSL&#x2F;TLS进行了加密，并且他是需要申请证书的</p>
<p>他们使用的端口号不同，HTTP为80端口，HTTPS为443端口</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立</span><br><span class="line">（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息</span><br><span class="line">（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</span><br><span class="line">（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</span><br><span class="line">（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</span><br></pre></td></tr></table></div></figure>





        <h3 id="CSMA-x2F-CD协议"   >
          <a href="#CSMA-x2F-CD协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3>
      <p>载波监听多点接入&#x2F;碰撞检测协议  三大特点</p>
<p>1.多点接入：作用在总线型网络中，许多计算机以多点接入的方式连接在同一个总线上</p>
<p>2.载波监听：每个站在发送数据前都会先检测总线上是否有其他站在发送数据，如果有则先等待</p>
<p>3.碰撞检测：边发送边监听，通过监听电压值的变化来判断是否和其他站发送进行了冲突，一段时间后无冲突则不再检测，如果发送冲突则停止发送数据，等待一段空闲时间后再次发送。</p>
<p>碰撞不可能完全避免，CSMA&#x2F;CD只能减少碰撞。</p>

        <h3 id="如何扩充局域网？"   >
          <a href="#如何扩充局域网？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何扩充局域网？" class="headerlink" title="如何扩充局域网？"></a>如何扩充局域网？</h3>
      <p>在物理层：通过集线器将多个计算机进行互联</p>
<p>链路层：通过交换机来进行扩展，相当于多接口的网桥</p>
<p>网络层：通过虚拟局域网VLAN</p>

        <h3 id="私有地址的范围"   >
          <a href="#私有地址的范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#私有地址的范围" class="headerlink" title="私有地址的范围"></a>私有地址的范围</h3>
      <p>A类：10.0.0.0-10.255.255.255</p>
<p>B类：172.16.0.0-172.31.255.255</p>
<p>C类：192.168.0.0-192.168.255.255</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用</p>

        <h3 id="介绍一下虚电路"   >
          <a href="#介绍一下虚电路" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下虚电路" class="headerlink" title="介绍一下虚电路"></a>介绍一下虚电路</h3>
      <p>虚电路是分组交换的两种传输方式中的一种，另一种是电路交换</p>
<p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p>
<p>提前定义好一条路径，可以改进性能，并且消除了帧和分组对头的需求，从而增加了吞吐率</p>

        <h3 id="电路交换、报文交换、分组交换"   >
          <a href="#电路交换、报文交换、分组交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3>
      <p>电路交换：在使用电路交换进行通话之前，必须先拨号建立一条连接，也就是一条专用的物理通路，这条通路在通话中只允许通话的两个用户使用，而不允许其他人使用。</p>
<p>优点：实现简单</p>
<p>缺点：建立大型网络时资源利用率不高，当用户比较多时，可能会出现通路短缺的情况。</p>
<p>报文交换：报文是通信链路中一次要发送的数据，报文交换就是把整个报文完整的发送到链路中，在某个节点存储下来之后再发送到下一个节点。</p>
<p>优点：相比电路交换，来说更加灵活。不需要事先建立连接之后再进行通信。</p>
<p>缺点：当每个报文的数据量较大时，每次在节点处转发再存储的话时延较大。</p>
<p>分组交换：分组交换采用转发存储技术，将一个完整的报文，分成若干个分组，再进行转发，而且每个分组之间经过哪一个节点，与上一个分组完全没有关系，这一点在某些网络节点发生网络阻塞时会显得尤其重要。</p>
<p>优点：发送数据更加灵活，时延更下。</p>
<p>缺点：发送设备和接收设备就更加复杂。</p>

        <h3 id="什么是SYN洪泛"   >
          <a href="#什么是SYN洪泛" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SYN洪泛" class="headerlink" title="什么是SYN洪泛"></a>什么是SYN洪泛</h3>
      <p> SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，耗尽其资源，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p>
<blockquote>
<p>半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。</p>
</blockquote>

        <h3 id="cookie-和-session-的区别："   >
          <a href="#cookie-和-session-的区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#cookie-和-session-的区别：" class="headerlink" title="cookie 和 session 的区别："></a><strong>cookie 和 session 的区别：</strong></h3>
      <p>1）保存位置与安全性：cookie保存在客户端，session保存在服务端，所以在安全性上面，cookie存在安全隐患，可以通过拦截或本地文件找到cookie后进行攻击，而session相对更加安全。因此，可以将登陆信息等重要信息存放为session中；其他信息如果需要保留，可以放在cookie中。</p>
<p>（2）存储容量：单个cookie最大只允许4KB，一个站点最多保存20个Cookie；session没有大小限制，个数只跟服务器的内存大小有关。</p>
<p>（3）有效期与实现机制：cookie可长期有效存在；session依赖于cookie，过期时间默认为-1，只需关闭窗口该 session 就会失效。每个客户端对应一个session ，客户端之间的 session  相互独立；</p>

        <h3 id="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"   >
          <a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="headerlink" title="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"></a>一个完整的http请求是怎么样？即从输入网址到获得页面的过程</h3>
      <p>（1）解析url，获取 url 中包含的域名；</p>
<p>（2）通过DNS系统查询域名对应的IP；</p>
<p>（3）浏览器得到域名对应的IP地址之后，向服务器发起三次握手请求建立TCP链接；</p>
<p>（4）TCP链接链接建立起来后，浏览器向服务器发送http请求，如果 html文件在缓存里，浏览器则直接返回， 如果没有，则去后台拿；</p>
<p>（5）服务器接收到请求后，根据路径参数映射到特定的处理器进行处理，并将处理结果以及相应的视图返回给浏览器。</p>
<p>（6）浏览器解析视图，并根据请求到的资源、数据进行渲染页面，最终向用户呈现一个完整的页面。</p>

        <h3 id="http的长连接和短连接？"   >
          <a href="#http的长连接和短连接？" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的长连接和短连接？" class="headerlink" title="http的长连接和短连接？"></a><strong>http的长连接和短连接？</strong></h3>
      <p>http的长连接和短连接本质上是TCP长连接和短连接。从http1.1开始就默认使用长连接。</p>
<p>短链接是指客户端与服务端每进行一次请求操作，就建立一次TCP连接，收到服务器响应后，就断开连接。</p>
<p>长连接是指客户端和服务建立TCP连接后，它们之间的连接会持续存在，不会因为一次HTTP请求后关闭，后续的请求也是用这个连接进行通信，使用长连接的HTTP协议，会在响应头有加入：Connection:keep-alive。长连接可以省去每次TCP建立和关闭的握手和挥手操作，节约时间提高效率。但在长连接下，客户端一般不会主动关闭连接，如果客户端和服务端之间的连接一直不关闭的话，随着连接数越来越多，会对服务端造成压力。</p>
<p>所以长连接多用于频繁请求资源，而且连接数不能太多的情况，例如数据库的连接用长连接。而像Web网站这种并发量大，但是每个用户无需频繁操作的场景，一般都使用短连接，因为长连接对服务端来说会耗费一定的资源。</p>

        <h3 id="get和-post-请求的区别"   >
          <a href="#get和-post-请求的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a><strong>get和 post 请求的区别</strong></h3>
      <ul>
<li>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。</li>
<li>（2）幂等性：get 是幂等的，post 为非幂等的</li>
<li>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。</li>
<li>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。</li>
<li>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。</li>
<li>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</li>
</ul>

        <h3 id="Http-常见的状态码"   >
          <a href="#Http-常见的状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-常见的状态码" class="headerlink" title="Http 常见的状态码"></a><strong>Http 常见的状态码</strong></h3>
      <p>（1）1xx：请求处理中，请求已被接受，正在处理。</p>
<p>（2）2xx：请求成功，请求被成功处理。</p>
<p>（3）3xx：重定向，要完成请求必须进一步处理。</p>
<p>（4）4xx：客户端错误，请求不合法。</p>
<ul>
<li>404：未找到请求的资源</li>
</ul>
<p>（5）5xx：服务端错误，服务端不能处理合法请求。</p>
<ul>
<li>500：服务器内部错误。</li>
</ul>

        <h3 id="DNS-为什么用-UDP"   >
          <a href="#DNS-为什么用-UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h3>
      <p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>

        <h3 id="保活计时器的作用？"   >
          <a href="#保活计时器的作用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#保活计时器的作用？" class="headerlink" title="保活计时器的作用？"></a>保活计时器的作用？</h3>
      <p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>

        <h3 id="UDP-如何实现可靠传输？"   >
          <a href="#UDP-如何实现可靠传输？" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-如何实现可靠传输？" class="headerlink" title="UDP 如何实现可靠传输？"></a>UDP 如何实现可靠传输？</h3>
      <p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">保研复习之计算机知识</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="switch为什么比if快？"   >
          <a href="#switch为什么比if快？" class="heading-link"><i class="fas fa-link"></i></a><a href="#switch为什么比if快？" class="headerlink" title="switch为什么比if快？"></a>switch为什么比if快？</h3>
      <p>switch以空间换时间。<br>1、当分支较多时，当时用switch的效率是很高的。因为switch是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是if…else是遍历所以得可能值，知道找到符合条件的分支。如此看来，switch的效率确实比ifelse要高的多。<br>2、由汇编代码可知道，switch…case占用较多的代码空间，因为它要生成跳表，特别是当case常量分布范围很大但实际有效值又比较少的情况，switch…case的空间利用率将变得很低。<br>3、switch…case只能处理case为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用switch…case来处理的。所以，switch只能是在常量选择分支时比ifelse效率高，但是ifelse能应用于更多的场合，ifelse比较灵活。</p>

        <h3 id="并发和并行的区别？"   >
          <a href="#并发和并行的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h3>
      <p>一、意思不同</p>
<p>1、并发：并发是指两个或多个事件在同一时间间隔发生。</p>
<p>2、并行：并行是指两个或者多个事件在同一时刻发生。</p>
<p>二、侧重不同</p>
<p>1、并发：并发侧重于在同一实体上。</p>
<p>2、并行：并行侧重于在不同实体上。</p>
<p>三、处理不同</p>
<p>1、并发：并发在一台处理器上“同时”处理多个任务。</p>
<p>2、并行：并行在多台处理器上同时处理多个任务。</p>

        <h3 id="局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？"   >
          <a href="#局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？" class="headerlink" title="局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？"></a>局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？</h3>
      <p>定义局部变量,其实就是在栈中通过移动栈指针,来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上,而栈内存是反复使用的(脏的,上次用完没清零的) ,所以说使用栈来实现的局部变量定义时如果不初始化,里面的值就是一个垃圾值。由此我们扩展一下,其实不仅仅是局部变量,所有的变量在定义时只是在内存中分配一块空间,并没有对这块空间进行任何的初始化。如果这块内存以前被用过,里面的数据还在,那它对于我们来说是没有任何意义的垃圾值。</p>
<p>全局变量是定义在堆中的，为静态存储。变量定义的时候,分配了一定的内存单元,在整个程序中,内存单元都不变.只能初始化一次,可以多次赋值,静态存储变量不初始化则初始为0.由堆进行初始化和收回，因此在定义时会默认初始化为0</p>

        <h3 id="如何求圆周率？"   >
          <a href="#如何求圆周率？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何求圆周率？" class="headerlink" title="如何求圆周率？"></a>如何求圆周率？</h3>
      <p>①基于蒙特卡洛来计算，比如构造一个半径为1的圆和它的外切正方形，然后向其中去随机大量的点，计算落在圆中的概率应该是等于π&#x2F;4,当随机量足够多时可以认为这个比例就是概率即可计算。</p>
<p>②圆周率定义为一个圆形的周长和直径的比值。构造一个圆，然后用一个软绳去算出圆的周长去除于直径即可得到。</p>

        <h3 id="多个点拟合使用什么算法？"   >
          <a href="#多个点拟合使用什么算法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#多个点拟合使用什么算法？" class="headerlink" title="多个点拟合使用什么算法？"></a>多个点拟合使用什么算法？</h3>
      <p>首先通过观察这些点，如果能够发现明显的线性关系，则去尝试使用多元线性回归。比如可以明显的看出他们可以拟合为一条直线，则可以使用最小二乘法去求解最合适的k和b。然后去计算拟合优度$R^2$去判断拟合的效果。</p>
<p>除此之外也可以针对我们研究的问题去查阅文献，尝试去获取具有科学性的模型，然后将我们的实际问题赋予此去求出相应的参数。</p>
<p>如果没有其他办法则可以尝试使用神经网络去进行预测，比如在数学建模美赛中我就尝试使用XGboost去针对过去十年的比特币价格进行合理预测，得到的不错的拟合度。</p>

        <h3 id="面向过程和面向对象的区别，面向对象的性质？"   >
          <a href="#面向过程和面向对象的区别，面向对象的性质？" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向过程和面向对象的区别，面向对象的性质？" class="headerlink" title="面向过程和面向对象的区别，面向对象的性质？"></a>面向过程和面向对象的区别，面向对象的性质？</h3>
      <p>区别：①首先他们都是软件开发的思想，先有的面向过程再有的面向对象。面向对象是为了弥补在大型项目中面向过程的不足。②面向过程可以抽象为程序&#x3D;数据结构+算法，但在面向对象的编程中是对象&#x3D;数据结构+算法，程序&#x3D;对象+对象，具有更好的迁移性，控制和复用③编程思想不同，面向过程是专注于涉及功能函数，面向对象编程则是抽象出类、属性、方法等元素，然后进行封装实现④他们都具有封装性，但是面向对象的对象具有多态、继承等特点。</p>
<p>性质：三大特性</p>
<p>a)封装：将对象中的属性、方法进行隐藏，仅对外提供公共访问方法，使得外部无法获取其中的实现过程，易于复用同时提高安全性。</p>
<p>b)继承:使用目前已经定义好的类来作为基础建立新类的技术，在基础类上添加新的数据和函数，是多态的基础。</p>
<p>c)多态:一个已经定义好的引用变量只有在程序运行时才能确定指向的是哪个类的实例对象，调用的是哪个类的实现方法。</p>

        <h3 id="你是怎么理解类和对象的？"   >
          <a href="#你是怎么理解类和对象的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你是怎么理解类和对象的？" class="headerlink" title="你是怎么理解类和对象的？"></a>你是怎么理解类和对象的？</h3>
      <p>类是一个概念，是一类具有相同特性对象的抽象，是一个模板。代表的是一类事物，当我们遇到多个对象具有相同的特性时我们便可以进行类的抽象。</p>
<p>对象是类的实例化，是实际存在的个体。</p>
<p>他们之间的关系就是类时对象的抽象，对象是类的实例化。</p>

        <h3 id="介绍一下c-的多态"   >
          <a href="#介绍一下c-的多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下c-的多态" class="headerlink" title="介绍一下c++的多态"></a>介绍一下c++的多态</h3>
      <p>主要包括两种，静态多态和动态多态。</p>
<p>静态多态是指在编译的时候实现函数的多个状态，比如通过修改函数的参数数量、参数类型来实现函数重载。这个的实现原理是通过编译器在编译c++函数时函数名会发生变化，包含参数的数量以及类型等信息，依次来区分不同的函数调用。</p>
<p>静态多态是指在程序运行才确定调用的是哪个函数，是一种动态绑定。比如具有虚函数的基类和实现了虚函数的子类，我们可以通过基类指针来调用子类中的虚函数。实现原理是通过虚函数指针以及虚函数表。当一个有虚函数的类在实例化的时候编译器会为其分配一个指向虚函数表的指针vptr,通过函数指针来调用虚函数时只会根据所指向对象类型来执行相对应的虚函数。</p>

        <h3 id="C语言中-局部变量和全局变量都是存储在什么区"   >
          <a href="#C语言中-局部变量和全局变量都是存储在什么区" class="heading-link"><i class="fas fa-link"></i></a><a href="#C语言中-局部变量和全局变量都是存储在什么区" class="headerlink" title="C语言中 局部变量和全局变量都是存储在什么区"></a>C语言中 局部变量和全局变量都是存储在什么区</h3>
      <p>局部变量是分配在栈中的，也可以手动分配在堆上不过需要记得手动回收。这个局部变量所在的函数被多次调用时，每次调用这个局部变量在栈上的位置都不一定相同 </p>
<p>全局变量分布在堆上，也就是静态存储器。在程序开始执行时给全局变量分配存储区，程序行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不动态地进行分配和释放； </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">保研复习之计算机与网络安全</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="信息安全的基本属性"   >
          <a href="#信息安全的基本属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息安全的基本属性" class="headerlink" title="信息安全的基本属性"></a>信息安全的基本属性</h3>
      <ul>
<li><strong>保密性（Confidentiality）</strong>：保证信息不泄露给未经授权的用户。</li>
<li><strong>完整性（Integrity）</strong>：保证信息从真实的发信者传送到真实的收信者手中，传送过程中没有被非法用户添加、删除、替换等。</li>
<li><strong>可用性（Availability）</strong>：保证授权用户能对数据进行及时可靠的访问。</li>
</ul>

        <h3 id="防范缓冲区溢出的手段"   >
          <a href="#防范缓冲区溢出的手段" class="heading-link"><i class="fas fa-link"></i></a><a href="#防范缓冲区溢出的手段" class="headerlink" title="防范缓冲区溢出的手段"></a>防范缓冲区溢出的手段</h3>
      <p>1.使用更安全的函数，比如scanf_s()、gets_s() </p>
<p>2.使用更加安全的语言，比如Java等安全的语言编写程序 </p>
<p>3.改进编译器，它的主要思想是在编译器中增加边界检查以及保护堆栈的功能 </p>

        <h3 id="防火墙技术"   >
          <a href="#防火墙技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3>
      <p>计算机网络中的<strong>边境检查站</strong>，保护内部网络，无法抵御网络中的内部攻击。</p>
<p>有三种类型：包过滤防火墙、状态监测防火墙、代理服务器防火墙</p>
<p>包过滤防火墙在网络中的适当位置对数据包按照规则进行过滤，状态监测防火墙是通过检测模块在不影响网络正常工作的前提下，抽取部分数据，即状态信息动态地保存起来作为以后指定安全决策的参考，代理服务器防火墙运行在两个网络之间，从站点取回所需信息再转发给客户。</p>
<p>防火墙并非单纯的软件或硬件，它实质是软件和硬件加上一组安全策略的集合。 </p>

        <h3 id="入侵检测技术"   >
          <a href="#入侵检测技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h3>
      <p>对周围正在进行的各种活动进行监视以此来判断系统的安全性</p>
<p>有两种模型：基于主机的IDS和基于网络的IDS</p>
<p>核心部件都是通信流收集器，分析引擎以及特征数据库</p>
<p>基于主机的IDS搜集本机的日志文件和其他关键文件，基于网络的IDS搜集的是流经本网段的所有数据包。 分析引擎获得数据之后与特征数据库中的记录进行模式匹配，从而觉得哪些行为是好的，哪些行为是坏的。 </p>

        <h3 id="身份认证技术"   >
          <a href="#身份认证技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h3>
      <p>身份认证技术用来确定用户的合法身份。 </p>
<p>基于口令认证技术：通过口令来验证用户的合法有效性（账号密码）</p>
<p>双因素身份认证技术：添加了额外的身份验证令牌，而不仅仅是静态口令 </p>
<p>数字证书的身份认证技术：通过CA认证机构发放的数字证书来对用户身份进行证明，常用在网络协议</p>
<p>基于生物特征的身份认证技术：采用独一无二的生物特征来认证用户身份的技术 ，比如指纹识别、虹膜识别、行为识别等。</p>

        <h3 id="网络层安全问题"   >
          <a href="#网络层安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层安全问题" class="headerlink" title="网络层安全问题"></a>网络层安全问题</h3>
      <p>关于<strong>ARP协议</strong>，由于计算机会对收到的每个ARP应答报文作出响应，并更新自己的ARP缓冲表，攻击者利用这个漏洞可以发起中间人攻击，或者用地址冲突使得目标主机不能联网 </p>
<p>关于<strong>ip协议</strong>，由于ip的源地址不可靠，攻击者可以利用这个漏洞发起盲目飞行攻击以及利用源路由机制发起<strong>中间人攻击</strong>，针对这个漏洞可以采用单播反向验证进行预防。 </p>
<p>关于<strong>ICMP协议</strong>，利用回送报文可以发起smurf攻击，利用路由重定向报文可以改变主机的路由。 </p>
<p>介绍下SYN扫描、FIN扫描、idle扫描</p>

        <h3 id="传输层的安全问题"   >
          <a href="#传输层的安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层的安全问题" class="headerlink" title="传输层的安全问题"></a>传输层的安全问题</h3>
      <p><strong>1.SYN泛洪攻击</strong><br>漏洞：服务器端的资源是在第二次握手之后分配的，客户端资源是在第三次握手之后分配的。攻击者发送大量第一次握手的数据包，对服务器回复的ACK不予确认。导致服务器所有的连接处于挂起状态，消耗服务器资源。</p>
<p>防御：限制一台计算机向服务器发起SYN包的次数；先用代理服务器过滤掉可以的SYN包。</p>
<p><strong>2.RST复位攻击</strong><br>漏洞：TCP释放连接有两种方式，友好终止（FIN）和突然终止（RST）。RST&#x3D;1说明连接中出现严重差错，丢弃缓冲区中的包，立刻断开TCP连接。</p>
<p>手段：攻击者创建tcp复位数据报，将数据报发送给受害者和服务器，终止两者的连接。复位数据报的伪造要求【源IP、源端口、目标IP、目标端口、序号】都要正确，而且序号要落在窗口内，因此窗口越大，越容易发起复位攻击。</p>
<p><strong>3.会话劫持</strong><br>基本思想：扰乱客户和服务器之间的同步状态，改写客户与服务器之间的会话</p>
<p>过程：</p>
<p>攻击者等待客户与服务器之间的TCP连接正常开启<br>攻击者伪装成客户向服务器发送RST包，使服务器的TCP连接关闭<br>攻击者伪装成客户向服务器发送TCP连接请求，序列号与客户最初选择的不同<br>服务器与攻击者建立TCP连接，它为自己选择的序列号也与之前的不同<br>客户并不知道这些，它仍然保持着之前双方的序列号<br>这样，客户与服务器之间的序列号就被扰乱了，它们之间传输的报文不被对方接受<br>攻击者作为中间人，通过改写收到的数据包，来维持客户与服务器之间的数据传输<br><strong>4.ACK风暴</strong><br>漏洞：主机会在接收到一个它不期望的报文后，向对方返回一个ACK报文，告知对方它想接收什么报文，希望重新与对方同步。而对方在收到报文之后，也发现报文的序号不对，它又会向主机发送ACK报文。这样就构成死循环，使网络上充满ACK报文，导致网络拥塞。</p>
<p><strong>5.UDP Flood</strong></p>
<p>UDP Flood是日渐猖厥的流量型DoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.qycn.com/qydns/" >DNS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>服务器或Radius认证服务器、流媒体视频服务器。</p>

        <h3 id="应用层安全问题"   >
          <a href="#应用层安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层安全问题" class="headerlink" title="应用层安全问题"></a>应用层安全问题</h3>
      <p>针对<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=DHCP&spm=1001.2101.3001.7020" >DHCP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>协议：</p>
<p><strong>1.伪造发现报文：拒绝服务攻击</strong><br>攻击方法：攻击者向DHCP服务器发送大量伪造的DHCP发现报文（虚假的硬件地址）</p>
<p>目的：消耗掉地址池中的所有IP地址</p>
<p>注意：DHCP服务器会释放到期的IP，攻击者需持续发包</p>
<p><strong>2.伪造释放报文：ip冲突</strong><br>攻击方法：伪装成客户端，向DHCP服务器发送释放报文</p>
<p>目的：导致DHCP服务器向多台客户端提供同一个IP</p>
<p>注意：需要知道DHCP分配过的IP</p>
<p><strong>3.伪造提供报文：DHCP欺骗</strong><br>漏洞：客户不对收到的DHCP提供报文进行来源确认</p>
<p>攻击方法：攻击者伪装成DHCP服务器向客户端回应恶意DHCP提供报文</p>
<p>后果：给客户分配无效IP地址，造成客户无法使用网络，或将攻击者的IP作为默认网关提供给客户，嗅探客户流量</p>
<p>防御方法：配置交换机的信任端口。连接真正DHCP服务器的端口被配置为信任端口，只有从信任端口接收到的DHCP提供包才能继续转发，其余一律丢弃。</p>
<p>针对DNS协议:</p>
<p><strong>1.伪造查询报文：拒绝服务</strong></p>
<ul>
<li>向受害者DNS服务器发送大量的DNS查询请求包，导致DNS服务器无法正常工作</li>
</ul>
<p><strong>2.伪造应答报文：DNS劫持</strong></p>
<ul>
<li>漏洞：客户端永远相信DNS应答是正确的</li>
<li>攻击手段：直接向客户端发送恶意的DNS应答，或者将恶意条目插入到DNS服务器，修改域名和ip地址的对应项。</li>
</ul>
<p>针对HTTP协议：</p>
<p>http存在sql注入的风险</p>

        <h3 id="访问控制"   >
          <a href="#访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3>
      <p><strong>自主访问控制（DAC）</strong>的特点是客体的创建者可以授予其他主体对客体的访问权限，十分灵活，实现方式有访问控制矩阵，访问控制列表，访问控制能力列表。访问控制矩阵是一个三元组，包括主体，客体和访问权限；访问控制列表是以文件为中心创建的，而访问控制能力列表则是基于用户为中心创建的。 </p>
<p>**强制访问控制(MAC)**，这是一种基于安全级别的访问控制，每一个主体和客体都被授予了不同的安全级别，通过判断主客体之间的安全级别进行访问控制。 </p>
<p>**基于角色的访问控制(RBAC)**，与上面两种访问控制不同的是这种策略不直接对用户授予权限，而是给用户赋予不同的角色，每个角色有不同的权限。 </p>
<p>**基于属性的访问控制(ABAC)**，每个用户携带自己的属性，包括主体属性，资源属性和环境属性来访问客体，授权引擎根据这些属性进行访问控制。 </p>

        <h3 id="蠕虫-VS-木马-VS-病毒"   >
          <a href="#蠕虫-VS-木马-VS-病毒" class="heading-link"><i class="fas fa-link"></i></a><a href="#蠕虫-VS-木马-VS-病毒" class="headerlink" title="蠕虫 VS 木马 VS 病毒"></a>蠕虫 VS 木马 VS 病毒</h3>
      <p>蠕虫是一种可以独立运行，并能自动传播到其他计算机上的程序。<strong>利用缓冲区溢出漏洞使攻击代码自动运行</strong></p>
<p>木马通过网络在用户未察觉的情况下窃取用户信息或控制用户主机的程序。<strong>可建立远程连接</strong> </p>
<p>病毒是计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。 </p>

        <h3 id="防火墙的局限性"   >
          <a href="#防火墙的局限性" class="heading-link"><i class="fas fa-link"></i></a><a href="#防火墙的局限性" class="headerlink" title="防火墙的局限性"></a>防火墙的局限性</h3>
      <p>1.防火墙只是一种边界安全保护系统，如果攻击者在内网，那将无法进行防护</p>
<p>2.防火墙是基于已有攻击知识制定的，无法对新的动机进行防护，难以防范零日漏洞</p>
<p>3.防火墙对通信内容的控制很弱，因此其对病毒、蠕虫、木马等恶意代码的防护能力很弱</p>

        <h3 id="什么是SQL-注入？"   >
          <a href="#什么是SQL-注入？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SQL-注入？" class="headerlink" title="什么是SQL 注入？"></a>什么是SQL 注入？</h3>
      <p>SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>1). SQL注入攻击的总体思路</p>
<p>　　(1). 寻找到SQL注入的位置<br>　　(2). 判断服务器类型和后台数据库类型<br>　　(3). 针对不同的服务器和数据库特点进行SQL注入攻击</p>

        <h3 id="什么是匿名网络"   >
          <a href="#什么是匿名网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是匿名网络" class="headerlink" title="什么是匿名网络?"></a>什么是匿名网络?</h3>
      <ol>
<li>匿名网络：暗网，使用洋葱路由，一层一层包裹数据包，网络节点都不知道目的端和起始端，所以匿名</li>
</ol>
<blockquote>
<p>被称作洋葱路由的原因在于消息一层一层的加密包装成被称作洋葱数据包的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，层数取决于到目的地中间会经过的节点数，每经过一个节点层会将数据包的最外层解密，因此任一个节点都无法同时知晓这个消息最初与最终的目的地，使发送者达到匿名的效果。</p>
</blockquote>

        <h3 id="用户隐私泄露怎么看，怎样防止泄露："   >
          <a href="#用户隐私泄露怎么看，怎样防止泄露：" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户隐私泄露怎么看，怎样防止泄露：" class="headerlink" title="用户隐私泄露怎么看，怎样防止泄露："></a>用户隐私泄露怎么看，怎样防止泄露：</h3>
      <p>用户隐私泄露，即用户在注册和使用相关网络应用上传的个人信息和数据被他人盗取，比如CSDN社区600万用户账号密码泄露，说明相关企业的网络安全意识淡薄，相关安全策略缺失。 在今天“数据为王”的当今社会,数据所给企业带来的收益，已远大于其它资产产生收益，数据泄露直接会给企业造成经济损失并影响其品牌形象。</p>
<p>如何防止泄露：首先相关安全技术实施好，比如密码不要明文存储，采用MD5加密，页面数据交互部分后端处理不能采取简单的拼接，防止SQL注入等等，然后也是最重要的相关技术人员和管理人员的网络安全意识一定要有，不然即使安全技术再好，也抵不住社会工程学攻击。 网络安全三分靠技术七分靠管理 </p>

        <h3 id="什么是漏洞扫描"   >
          <a href="#什么是漏洞扫描" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是漏洞扫描" class="headerlink" title="什么是漏洞扫描"></a>什么是漏洞扫描</h3>
      <ol>
<li>漏洞扫描：漏洞扫描器包括网络漏扫、主机漏扫、数据库漏扫等不同种类。</li>
</ol>
<blockquote>
<p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。</p>
</blockquote>

        <h3 id="什么是XSS攻击"   >
          <a href="#什么是XSS攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h3>
      <p>XSS（Cross-site scripting） 服务器对客户端的输入检测不严格 ，导致客户端输入的恶意JS代码被植入到HTML代码中，这些JavaScript代码得以执行，实现一些特殊的目的. 防御对策： 对输入内容中特殊字符进行转义 种类：持久型XSS、非持久型XSS 持久型XSS也叫存储型XSS 非持久性XSS分为反射型XSS和DOM型XSS </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。</span><br><span class="line">非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。</span><br><span class="line">持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</span><br><span class="line">DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。</span><br></pre></td></tr></table></div></figure>




        <h3 id="什么是CSRF攻击"   >
          <a href="#什么是CSRF攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3>
      <p>跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>通过伪装来自受信任用户的请求来利用受信任的网站。<br>防御对策：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 阻止不明外域的访问：验证HTTP Referer字段</span><br><span class="line">   根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL(本例中，通常是以bank. test域名开头的地址)。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</span><br><span class="line">2. 提交时要求附加本域才能获取的信息：在请求地址中添加token并验证</span><br><span class="line">   CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="DES加密的大致过程"   >
          <a href="#DES加密的大致过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#DES加密的大致过程" class="headerlink" title="DES加密的大致过程"></a>DES加密的大致过程</h3>
      <p>64位明文经过初始置换之后，然后进行16轮迭代，进行逆置换，生成64位密文。</p>
<ul>
<li>用56位密钥加密64位数据（8个奇偶校验）</li>
<li>采用分组加密，feistel密码结构（feistel:简单地说Feistel结构就是顺序地执行两个或多个基本密码系统，使最后结果的密码强度高于每个密码系统的结果）</li>
<li>对称算法：加密和解密除密钥编排不同外，使用同一算法</li>
<li>密钥较短，加密处理简单，加解密速度快，适用于加密大量数据的场合</li>
</ul>
<p>流程：</p>
<p><strong>1.ip置换（先是左边的明文<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020" >加密</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>部分）</strong></p>
<p>给定明文，通过一个固定的初始置换IP来重排输入明文块P中的比特，得到比特串P0&#x3D;IP(P)&#x3D;L0R0，这里L0和R0分别是P0的前32比特和后32比特</p>
<p><strong>2.将ip置换后的明文分成两组</strong> </p>
<p><strong>3.右边进入分组密码的轮函数F</strong> </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">轮函数包括E盒拓展、与轮密钥异或、S盒压缩、置换运算</span><br><span class="line">·右半部分继续进入E盒扩展</span><br><span class="line">	因为子密钥是48bit，所以将数据通过e盒扩展从32bit——&gt;48bit(注意e盒扩展的规律)</span><br><span class="line"></span><br><span class="line">·与子密钥异或后，再通过S盒压缩</span><br><span class="line">	48bit分成8组，通过8个s盒进行压缩恢复为32bit(注意压缩的方法：第一位与第六位组成行，中间四位组成列。最后查s盒得到的数据的二进制位压缩后的四位结果)</span><br><span class="line"></span><br><span class="line">·s盒的输出结果，通过p盒置换输出，轮函数F结束</span><br></pre></td></tr></table></div></figure>

<p><strong>4.轮函数F的输出结果再与左半部分异或形成新的R,而原来的R则转为L本轮结束</strong> </p>
<p>子密钥生成流程：密钥严格是64位，但是8位是奇偶校验位，因此是56位的</p>
<p><strong>1.先减掉8奇偶校验位，再通过pc-1置换</strong> </p>
<p><strong>2.分两组C0与D0进行循环左移位</strong> </p>
<p><strong>3.再进行pc-2的置换。52bit——&gt;48bit，本轮子密钥生成结束，下一轮密钥靠C1、D1循环左移位后继续通过pc-2置换</strong> </p>

        <h3 id="AES加密的大致过程"   >
          <a href="#AES加密的大致过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES加密的大致过程" class="headerlink" title="AES加密的大致过程"></a>AES加密的大致过程</h3>
      <p>输入明文、子密钥，进行r轮迭代得到密文。 每一轮迭代过程为：明文先进行字节代替变换、行移位变换、列混合变换，再进行轮密钥加变换，得到下一轮输入  </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%9C%BA%E7%BB%84/">保研复习之计算机组成原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="总线是什么？"   >
          <a href="#总线是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#总线是什么？" class="headerlink" title="总线是什么？"></a>总线是什么？</h4>
      <p>1）总线是一组能功能部件之间分时共享的公共信息传送线路。分时、共享是它的两大特点。<br>2）分时是指同一时刻只能有一个部件向总线上发出信息。<br>3）总线分为三大类：片内总线、系统总线（数据总线+控制总线+地址总线）、通信总线。<br>4）通信方式分为：异步通信和并行通信。<br>5）一些特性：功能特性、电气特性、机械特性、时间特性。</p>

        <h4 id="DMA是什么？"   >
          <a href="#DMA是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA是什么？" class="headerlink" title="DMA是什么？"></a>DMA是什么？</h4>
      <p>（1）CPU和外设之间数据传输的方式，外部设备发送DMA请求，CPU同意之后就让出总线控制权，DMA控制器接管总线控制权之后开始进行外部设备与内存之间的直接数据的，CPU不再作为中枢。比较适合大量数据的传输，跟中断相比减少了中断请求、相应、保存上下文（即环境）的时间，使得资源利用率以及吞吐量更大。<br>（2）DMA请求、DMA响应、数据传输、DMA结束<br>   （预处理–&gt;数据传输–&gt;后处理）</p>

        <h4 id="说下五级流水CPU的各阶段"   >
          <a href="#说下五级流水CPU的各阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下五级流水CPU的各阶段" class="headerlink" title="说下五级流水CPU的各阶段"></a>说下五级流水CPU的各阶段</h4>
      <p>五级流水线指的是：取指、译码、执行、访存、写回五个操作。<br>1）取指：<br>指令取指（InstrucTIon Fetch）是指将指令从存储器中读取出来的过程。</p>
<p>2）译码：<br>指令译码（InstrucTIon Decode）是指将存储器中取出的指令进行翻译的过程。经过译码之后得到指令需要的操作数寄存器索引，可以使用此索引从通用寄存器组（Register File，Regfile）中将操作数读出。</p>
<p>3）执行：<br>指令译码之后所需要进行的计算类型都已得知，并且已经从通用寄存器组中读取出了所需的操作数，那么接下来便进行指令执行（InstrucTIon Execute）。指令执行是指对指令进行真正运算的过程。譬如，如果指令是一条加法运算指令，则对操作数进行加法操作；如果是减法运算指令，则进行减法操作。<br>在“执行”阶段的最常见部件为算术逻辑部件运算器（ArithmeTIc Logical Unit，ALU），作为实施具体运算的硬件功能单元。</p>
<p>4）访存：<br>存储器访问指令往往是指令集中最重要的指令类型之一，访存（Memory Access）是指存储器访问指令将数据从存储器中读出，或者写入存储器的过程。</p>
<p>5）写回：<br>写回（Write-Back）是指将指令执行的结果写回通用寄存器组的过程。如果是普通运算指令，该结果值来自于“执行”阶段计算的结果；如果是存储器读指令，该结果来自于“访存”阶段从存储器中读取出来的数据。</p>

        <h4 id="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"   >
          <a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？</h4>
      <p>1）五级流水CPU就是在多周期CPU的基础上+流水线思想——–&gt;实现并行。<br>2）传统的单周期CPU是指指令在一个时钟周期（即时钟到来一次）内执行完成，包括所有的操作。但这里存在的确定就是时钟周期的时间是固定的，所以时钟周期的时间应该是最长的指令所需要的时间，对于那种很短的指令，就会造成浪费。引入多周期，这时就可以减少浪费的时间。<br>3）单周期CPU（是指在一个时钟周期内完成这五个阶段的处理）。因为五级流水CPU中每一个操作的流水时间是一样的，取得是这五步中的最大执行时间，那么就是最大操作时间*需要执行的操作数目（取指、译码、、、）。<br>4）因为只有一条指令嘛，所以单周期最快，多条指令是考虑流水线比较好。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%A6%82%E7%8E%87%E8%AE%BA/">保研复习之概率论</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="什么是最大似然估计？"   >
          <a href="#什么是最大似然估计？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是最大似然估计？" class="headerlink" title="什么是最大似然估计？"></a>什么是最大似然估计？</h3>
      <p>基本介绍：在所有θ 可能的取值中，寻找一个值使得这个采样的可能性最大化，可以通过使得似然函数的一阶导数等于零，使得这个函数取到最大值。这个使得可能性最大的值称为最大似然估计</p>
<p>定义：设  $X 1, X 2, \ldots, X n  $为来自总体$  X  $的简单随机样本，$  x 1, x 2, \ldots, x n  $为样本观测值称</p>
<p>$L(\theta)&#x3D;\prod_{i&#x3D;1}^{n} p\left(x_{i}, \theta\right)$为参数θ的似然函数,通过使得这个似然函数取得最大值，得到的对应参数值就是最大似然估计。</p>
<p><strong>⚠️注意：</strong>1）这里的似然函数是指 x1,x2,…,xn 不变时，关于 θ 的一个函数。</p>
<p>2）最大似然估计不一定存在，也不一定唯一。</p>

        <h3 id="什么是中心极限定理？"   >
          <a href="#什么是中心极限定理？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是中心极限定理？" class="headerlink" title="什么是中心极限定理？"></a>什么是中心极限定理？</h3>
      <p>定义：如果样本量足够大，则变量均值的采样分布将近似于正态分布，而与该变量在总体中的分布无关。</p>
<p>说明：中心极限定理意味着即使数据分布不是正态的，从中抽取的样本均值的分布也是正态的。 </p>
<p>核心：独立同分布随机变量的均值呈正态分布。</p>

        <h3 id="什么是大数定理？"   >
          <a href="#什么是大数定理？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是大数定理？" class="headerlink" title="什么是大数定理？"></a>什么是大数定理？</h3>
      <p>沟通概率论和统计的桥梁。</p>
<p>样本容量极大时，样本的均值必然趋近于总体的期望。</p>
<p><strong>大数定律告诉我们当样本量很大时能用频率近似代替概率；能用样本均值近似代替总体均值。</strong> </p>

        <h3 id="一句话概括假设检验"   >
          <a href="#一句话概括假设检验" class="heading-link"><i class="fas fa-link"></i></a><a href="#一句话概括假设检验" class="headerlink" title="一句话概括假设检验"></a>一句话概括假设检验</h3>
      <ul>
<li><p><strong>假设检验</strong>：</p>
</li>
<li><ul>
<li>你提出假设：说你的硬币是公平的</li>
<li>我提出要检验你的假设：扔十次，看实验的结果是不是和你的假设相符</li>
</ul>
</li>
<li><p><strong>P值</strong></p>
</li>
<li><ul>
<li>一般认为<br>p−value≤0.05<br>就可以认为假设是不正确的。0.05这个标准就是<strong>显著水平</strong>，当然选择多少作为显著水平也是主观的。</li>
</ul>
</li>
<li></li>
</ul>

        <h3 id="概率和统计的区别"   >
          <a href="#概率和统计的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#概率和统计的区别" class="headerlink" title="概率和统计的区别"></a>概率和统计的区别</h3>
      <p><strong>概率是已知模型和参数，推数据。统计是已知数据，推模型和参数。</strong> </p>
<p>概率一般是个确定的值，统计得到的具有一定的随机性</p>

        <h3 id="概率和似然的区别"   >
          <a href="#概率和似然的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#概率和似然的区别" class="headerlink" title="概率和似然的区别"></a>概率和似然的区别</h3>
      <ul>
<li><p>P(x|θ)<br>输入有两个：x表示某一个具体的数据；θ表示模型的参数。</p>
</li>
<li><ul>
<li><strong>如果θ是已知确定的，x是变量</strong>，这个函数叫做概率函数(probability function)，它描述对于不同的样本点x，其出现概率是多少。</li>
<li><strong>如果x是已知确定的，θ是变量</strong>，这个函数叫做似然函数(<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=likelihood+function&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22268007494%22%7D" >likelihood function</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>), 它描述对于不同的模型参数，出现x这个样本点的概率是多少。</li>
</ul>
</li>
</ul>

        <h3 id="介绍一下欧拉公式"   >
          <a href="#介绍一下欧拉公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下欧拉公式" class="headerlink" title="介绍一下欧拉公式"></a>介绍一下欧拉公式</h3>
      <p>公式：$e^{i \theta}&#x3D;\cos (\theta)+i \sin (\theta)$</p>
<p>指数函数的定义域扩大到了复数域 </p>
<p>建立和三角函数和指数函数的关系 </p>
<p>在傅里叶变换中用到了欧拉函数</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">保研复习之操作系统</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[TOC]</p>

        <h3 id="操作系统的功能"   >
          <a href="#操作系统的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3>
      <p>作为资源的管理者</p>
<ul>
<li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li>
<li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li>
<li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li>
</ul>

        <h3 id="操作系统的特征"   >
          <a href="#操作系统的特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3>
      <p>并发性：是在计算机系统中同时存在多个程序，宏观上看，这些程序是同时向前推进的。 在单CPU上，这些并发执行的程序是交替在CPU上运行的。 </p>
<p>共享性：资源共享是操作系统程序和多个用户程序共用系统中的资源。</p>
<p>异步性：即不确定性。同一程序和数据的多次运行可能得到不同的结果；程序的运行时间、运行顺序也具有不确定性；外部输入的请求、运行故障发生的时间难以预测。这些都是不确定性的表现</p>
<p>虚拟：是指通过技术将一个物理实体变成若干个逻辑上的对应物。在操作系统中虚拟的实现主要是通过分时的使用方法。显然，如果n是某一个物理设备所对应的虚拟逻辑设备数，则虚拟设备的速度必然是物理设备速度的1&#x2F;n。</p>

        <h3 id="处理器的三级调度"   >
          <a href="#处理器的三级调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a><strong>处理器的三级调度</strong></h3>
      <p>高级调度（作业调度）：作业从磁盘调入内存所采取的调度算法，先来先服务调度算法、短作业优先调度算法 </p>
<p>中级调度：外存对换区的具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待。内存中暂时不能运行的进程对换到外存兑换区，此时状态为挂起状态。 </p>
<p>进程调度：采用什么样的算法将处理器分配给进程 </p>

        <h3 id="线程、进程、管程的区别？"   >
          <a href="#线程、进程、管程的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程、进程、管程的区别？" class="headerlink" title="线程、进程、管程的区别？"></a>线程、进程、管程的区别？</h3>
      <p>进程：是系统进行资源分配的基本单位，创建一个进程，系统会为其分配相应的内存空间等资源。（我们平时用的exe类型的就是一个进程，比如WeChat和QQ以及浏览器）。一个进程可以拥有一个或者多个线程，线程的引入增加了并发度。 </p>
<p>线程：是轻量型进程，由进程创建，是系统进行独立调度和分配的基本单位，线程会与同属于一个进程的其他线程共享该进程所具备的资源，但是线程本身也具备一些自己特有的信息，比如程序寄存器等。 </p>
<p>管程：定义了一个<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。面向对象思想，表征共享资源的数据结构及其对数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节。 </p>
<p>进程定义的是私有数据结构PCB，管程定义的是公共数据结构 </p>

        <h3 id="什么是死锁？死锁产生的条件？如何处理死锁问题"   >
          <a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="headerlink" title="什么是死锁？死锁产生的条件？如何处理死锁问题"></a>什么是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020" >死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>？死锁产生的条件？<strong>如何处理死锁问题</strong></h3>
      <p>死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。</p>
<p><img src="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210607160841587.png" alt="image-20210607160841587"></p>
<p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。 </p>

        <h3 id="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"   >
          <a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="headerlink" title="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"></a><strong>死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）</strong></h3>
      <p>互斥条件：一个资源一次只能被一个进程使用</p>
<p>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</p>
<p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</p>
<p>常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略 </p>

        <h3 id="解决死锁的基本方法？"   >
          <a href="#解决死锁的基本方法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决死锁的基本方法？" class="headerlink" title="解决死锁的基本方法？"></a>解决死锁的基本方法？</h3>
      <ol>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ol>

        <h3 id="怎么预防死锁？"   >
          <a href="#怎么预防死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么预防死锁？" class="headerlink" title="怎么预防死锁？"></a>怎么预防死锁？</h3>
      <ol>
<li>破坏请求条件：一次性分配所有资源，这样就不会再有请求了；</li>
<li>破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：</li>
<li>破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；</li>
<li>破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。</li>
</ol>

        <h3 id="怎么避免死锁？"   >
          <a href="#怎么避免死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h3>
      <p><strong>1. 安全状态</strong></p>
<p><img src="https://image.iamshuaidi.com/picture/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<p><strong>2. 单个资源的银行家算法</strong></p>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="https://image.iamshuaidi.com/picture/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<p><strong>3. 多个资源的银行家算法</strong></p>
<p><img src="https://image.iamshuaidi.com/picture/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>

        <h3 id="怎么解除死锁？"   >
          <a href="#怎么解除死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么解除死锁？" class="headerlink" title="怎么解除死锁？"></a>怎么解除死锁？</h3>
      <ol>
<li>资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；</li>
<li>撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；</li>
<li>进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>

        <h3 id="windows和linux系统有什么区别"   >
          <a href="#windows和linux系统有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#windows和linux系统有什么区别" class="headerlink" title="windows和linux系统有什么区别?"></a>windows和linux系统有什么区别?</h3>
      <p>linux是免费开源的，windows是微软开发需要付费且用户无法修改的。</p>
<p>软件的兼容性windows更好，比较的丰富。</p>
<p>linux有很多的发行版本，易用性没有windows那么好。</p>
<p>因为用的更加普及，在windows平台的病毒更多。</p>
<p>linux比较的稳定，因此很多服务器都是用linux</p>

        <h3 id="如何创建进程，如何创建线程？"   >
          <a href="#如何创建进程，如何创建线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建进程，如何创建线程？" class="headerlink" title="如何创建进程，如何创建线程？"></a>如何创建进程，如何创建线程？</h3>
      <p>linux使用fork()和thread()来创建</p>
<p>windows使用clone()来创建</p>

        <h3 id="单线程进程一定比多线程进行慢吗？"   >
          <a href="#单线程进程一定比多线程进行慢吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程进程一定比多线程进行慢吗？" class="headerlink" title="单线程进程一定比多线程进行慢吗？"></a>单线程进程一定比多线程进行慢吗？</h3>
      <p>不一定，多线程存在上下文切换。</p>
<p>分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑。 </p>

        <h3 id="进程之间的通信方式"   >
          <a href="#进程之间的通信方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a><strong>进程之间的通信方式</strong></h3>
      <p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。 </p>
<p><strong>管道</strong></p>
<p>它是半双工的，具有固定的读端和写端；<br>它只能用于父子进程或者兄弟进程之间的进程的通信；</p>
<p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p><strong>命名管道</strong></p>
<p>FIFO 可以在无关的进程之间交换数据，与无名管道不同；<br>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<p><strong>消息队列</strong></p>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；<br>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</p>
<p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；</p>
<p>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p>
<p><strong>信号量</strong></p>
<p>信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；<br>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</p>
<p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</p>
<p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</p>
<p>支持信号量组。</p>
<p><strong>共享内存</strong></p>
<p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；</p>
<p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>

        <h3 id="进程同步应遵循的原则"   >
          <a href="#进程同步应遵循的原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程同步应遵循的原则" class="headerlink" title="进程同步应遵循的原则"></a><strong>进程同步应遵循的原则</strong></h3>
      <p>空闲让进：当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。所以基本上不存在等待进程为n的情况。</p>
<p>忙则等待：当已有进程进入自己的临界区时，即相应的临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</p>
<p>有限等待：对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</p>
<p>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等</p>

        <h3 id="分页和分段有什么区别"   >
          <a href="#分页和分段有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#分页和分段有什么区别" class="headerlink" title="分页和分段有什么区别"></a>分页和分段有什么区别</h3>
      <ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ol>
<p>段页式：先分段、再分页</p>

        <h3 id="临界区？"   >
          <a href="#临界区？" class="heading-link"><i class="fas fa-link"></i></a><a href="#临界区？" class="headerlink" title="临界区？"></a>临界区？</h3>
      <p>每个进程中访问临界资源的那段代码称为临界区 </p>
<p>每次只允许一个进程进入临界区 </p>
<p>通过互斥进入来实现对临界资源的互斥访问</p>

        <h3 id="文件管理系统管理的对象"   >
          <a href="#文件管理系统管理的对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件管理系统管理的对象" class="headerlink" title="文件管理系统管理的对象"></a>文件管理系统管理的对象</h3>
      <ol>
<li><strong>文件</strong>。在文件系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li>
<li><strong>目录</strong>。为了方便用户对文件的存取和检索，在文件系统中必须配置目录，在目录的每个目录项中，必须含有文件名、对文件属性的说明，以及该文件所在的物理地址（或指针）。对目录的组织和管理，是方便用户和提高对文件存取速度的关键。</li>
<li><strong>磁盘（磁带）存储空间</strong>。文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li>
</ol>

        <h3 id="简单说下你对并发和并行的理解？"   >
          <a href="#简单说下你对并发和并行的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单说下你对并发和并行的理解？" class="headerlink" title="简单说下你对并发和并行的理解？"></a>简单说下你对并发和并行的理解？</h3>
      <ol>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；</li>
</ol>

        <h3 id="同步、异步、阻塞、非阻塞的概念"   >
          <a href="#同步、异步、阻塞、非阻塞的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步、异步、阻塞、非阻塞的概念" class="headerlink" title="同步、异步、阻塞、非阻塞的概念"></a>同步、异步、阻塞、非阻塞的概念</h3>
      <p><strong>同步</strong>：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。</p>
<p><strong>异步</strong>：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p><strong>阻塞</strong>：是指调用结果返回前，当前线程会被挂起，即阻塞。</p>
<p><strong>非阻塞</strong>：是指即使调用结果没返回，也不会阻塞当前线程。</p>

        <h3 id="为什么有了进程，还要有线程呢？"   >
          <a href="#为什么有了进程，还要有线程呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么有了进程，还要有线程呢？" class="headerlink" title="为什么有了进程，还要有线程呢？"></a>为什么有了进程，还要有线程呢？</h3>
      <p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：</p>
<p>进程在同一时间只能干一件事情；<br>进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。</p>
<p>基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。</p>

        <h3 id="进程的状态转换"   >
          <a href="#进程的状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3>
      <p>进程包括三种状态：就绪态、运行态和阻塞态。</p>
<p><img src="https://image.iamshuaidi.com/picture/image-20210907124303344.png" alt="image-20210907124303344"></p>
<ol>
<li><p>就绪 —&gt; 执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
</li>
<li><p>执行 —&gt; 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入&#x2F;输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p>
</li>
<li><p>阻塞 —&gt; 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入&#x2F;输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
</li>
<li><p>执行 —&gt; 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
</li>
</ol>

        <h3 id="什么是缓冲区溢出？有什么危害？"   >
          <a href="#什么是缓冲区溢出？有什么危害？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是缓冲区溢出？有什么危害？" class="headerlink" title="什么是缓冲区溢出？有什么危害？"></a>什么是缓冲区溢出？有什么危害？</h3>
      <p>缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。 </p>

        <h3 id="物理地址、逻辑地址、虚拟内存的概念"   >
          <a href="#物理地址、逻辑地址、虚拟内存的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理地址、逻辑地址、虚拟内存的概念" class="headerlink" title="物理地址、逻辑地址、虚拟内存的概念"></a>物理地址、逻辑地址、虚拟内存的概念</h3>
      <ol>
<li>物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。</li>
<li>逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</li>
<li>虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li>
</ol>

        <h3 id="页面置换算法有哪些？"   >
          <a href="#页面置换算法有哪些？" class="heading-link"><i class="fas fa-link"></i></a><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h3>
      <p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。常用的页面置换算法如下：</p>
<ul>
<li><strong>先进先出置换算法（FIFO）</strong></li>
</ul>
<p>先进先出，即淘汰最早调入的页面。</p>
<ul>
<li><strong>最佳置换算法（OPT）</strong></li>
</ul>
<p>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</p>
<ul>
<li><strong>最近最久未使用（LRU）算法</strong></li>
</ul>
<p>即选择最近最久未使用的页面予以淘汰</p>
<ul>
<li><strong>时钟（Clock）置换算法</strong></li>
</ul>
<p>时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。</p>

        <h3 id="谈谈你对动态链接库和静态链接库的理解？"   >
          <a href="#谈谈你对动态链接库和静态链接库的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对动态链接库和静态链接库的理解？" class="headerlink" title="谈谈你对动态链接库和静态链接库的理解？"></a>谈谈你对动态链接库和静态链接库的理解？</h3>
      <p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。</p>
<p>动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能</p>

        <h3 id="外中断和异常有什么区别？"   >
          <a href="#外中断和异常有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#外中断和异常有什么区别？" class="headerlink" title="外中断和异常有什么区别？"></a>外中断和异常有什么区别？</h3>
      <p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>

        <h3 id="一个程序从开始运行到结束的完整过程，你能说出来多少？"   >
          <a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="headerlink" title="一个程序从开始运行到结束的完整过程，你能说出来多少？"></a>一个程序从开始运行到结束的完整过程，你能说出来多少？</h3>
      <p>四个过程：</p>
<p><strong>（1）预编译</strong> 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p><strong>（2）编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p><strong>（3）汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p><strong>（4）链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p><strong>1、静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p><strong>2、动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>

        <h3 id="什么是用户态和内核态"   >
          <a href="#什么是用户态和内核态" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3>
      <p>用户态和内核态是操作系统的两种运行状态。</p>
<ul>
<li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li>
<li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<blockquote>
<p>那么为什么要有用户态和内核态呢？</p>
</blockquote>
<p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>

        <h3 id="用户态和内核态是如何切换的？"   >
          <a href="#用户态和内核态是如何切换的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h3>
      <p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p>
<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p>
<p>他们的工作流程如下：</p>
<p><img src="https://image.iamshuaidi.com/picture/v2-1dfd23c107cca552b4e511ed526f75c4_720w.jpg" alt="img"></p>
<ul>
<li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li>
<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ul>

        <h3 id="进程终止的方式"   >
          <a href="#进程终止的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程终止的方式" class="headerlink" title="进程终止的方式"></a>进程终止的方式</h3>
      <p><strong>进程的终止</strong></p>
<p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误退出(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<p><strong>正常退出</strong></p>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p>
<p><strong>错误退出</strong></p>
<p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></div></figure>

<p>Text</p>
<p>Copy</p>
<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<p><strong>严重错误退出</strong></p>
<p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<p><strong>被其他进程杀死</strong></p>
<p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>

        <h3 id="守护进程、僵尸进程和孤儿进程"   >
          <a href="#守护进程、僵尸进程和孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程、僵尸进程和孤儿进程" class="headerlink" title="守护进程、僵尸进程和孤儿进程"></a>守护进程、僵尸进程和孤儿进程</h3>
      
        <h5 id="守护进程"   >
          <a href="#守护进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5>
      <p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>

        <h5 id="孤儿进程"   >
          <a href="#孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5>
      <p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>

        <h5 id="僵尸进程"   >
          <a href="#僵尸进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5>
      <p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>

        <h3 id="如何避免僵尸进程？"   >
          <a href="#如何避免僵尸进程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何避免僵尸进程？" class="headerlink" title="如何避免僵尸进程？"></a>如何避免僵尸进程？</h3>
      <ul>
<li>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</li>
<li>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</li>
<li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</li>
<li>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</li>
</ul>
<p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p>

        <h3 id="介绍一下几种典型的锁？"   >
          <a href="#介绍一下几种典型的锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下几种典型的锁？" class="headerlink" title="介绍一下几种典型的锁？"></a>介绍一下几种典型的锁？</h3>
      
        <h5 id="读写锁"   >
          <a href="#读写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5>
      <ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>

        <h5 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5>
      <p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>

        <h5 id="条件变量"   >
          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5>
      <p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>

        <h5 id="自旋锁"   >
          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5>
      <p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>

        <h3 id="常见内存分配内存错误"   >
          <a href="#常见内存分配内存错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见内存分配内存错误" class="headerlink" title="常见内存分配内存错误"></a>常见内存分配内存错误</h3>
      <p>（1）内存分配未成功，却使用了它。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>（5）释放了内存却继续使用它。常见于以下有三种情况：</p>

        <h3 id="内存交换中，被换出的进程保存在哪里？"   >
          <a href="#内存交换中，被换出的进程保存在哪里？" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存交换中，被换出的进程保存在哪里？" class="headerlink" title="内存交换中，被换出的进程保存在哪里？"></a>内存交换中，被换出的进程保存在哪里？</h3>
      <p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。 </p>

        <h3 id="原子操作的是如何实现的"   >
          <a href="#原子操作的是如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#原子操作的是如何实现的" class="headerlink" title="原子操作的是如何实现的"></a>原子操作的是如何实现的</h3>
      <p><strong>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</strong></p>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p>（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。</p>
<p>处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p>
<p>（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>

        <h3 id="什么是虚拟内存"   >
          <a href="#什么是虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3>
      <p>传统的内存空间分配方式需要将作业一次性调入内存，太占空间，而程序运行的时候是有局部性的，可以将需要的调入内存，不需要的调出内存。</p>
<p>局部性原理：</p>
<p>①时间局部性：一条指令运行后，不久可能再次运行；数据被访问后，不久可能再次访问（因程序中有大量循环）</p>
<p>②空间局部性：程序访问了某个存储单元，与这个存储单元相邻的可能被再次访问（因为指令按顺序存放；数据是簇聚存储的）</p>
<p>实现方式：在非连续分配管理的基础上 引入了中断机制        一条指令执行期间可能产生多次缺页中断</p>
<p>1）请求分页存储管理        2）请求分段存储管理        3）段页式存储管理</p>
<p>在发生缺页后 发送缺页中断调入所缺页 若内存已满 要进行页面置换</p>

        <h3 id="I-x2F-O控制方式："   >
          <a href="#I-x2F-O控制方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O控制方式：" class="headerlink" title="I&#x2F;O控制方式："></a><strong>I&#x2F;O控制方式：</strong></h3>
      <p>1）程序控制方式：CPU不断查询I&#x2F;O设备是否已经做好准备               </p>
<p>2）中断驱动方式（程序中断方式）：I&#x2F;O准备好数据 才发生中断通知CPU传数据</p>
<p>3）DMA方式：主存和I&#x2F;O之间有一条数据通路，传输数据由DMA负责，传完一个或多个数据块 通知CPU                    </p>
<p>4）通道控制方式：将数据传到哪 以及数据的传输都交给通道</p>

        <h3 id="介绍下假脱机-Spooling-技术"   >
          <a href="#介绍下假脱机-Spooling-技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下假脱机-Spooling-技术" class="headerlink" title="介绍下假脱机(Spooling)技术"></a>介绍下<strong>假脱机(Spooling)技术</strong></h3>
      <p>通俗的讲，为了将独占的设备转化为逻辑上共享的设备，就是设备被占用，往设备发送的数据就先在磁盘暂存一下，等设备空闲再输入设备</p>
<p>组成：输入&#x2F; 出设备 输入&#x2F;出缓冲区 输入&#x2F;出井</p>
<p>常见应用：共享打印机</p>

        <h3 id="DMA和中断方式的主要区别"   >
          <a href="#DMA和中断方式的主要区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA和中断方式的主要区别" class="headerlink" title="DMA和中断方式的主要区别"></a><strong>DMA和中断方式的主要区别</strong></h3>
      <p>1）谁控制数据传输：DMA方式是由DMA控制；中断方式是CPU控制</p>
<p>2）优先级：DMA中断优先级大于普通I&#x2F;O中断</p>
<p>3）中断相应的时机：DMA方式可以在每个机器周期结束时候响应；中断方式只能在指令执行周期结束后响应</p>
<p>4）DMA方式在结束一个数据块传送后才发中断；中断方式每传输一个字就要中断</p>

        <h3 id="程序中断和子程序调用的区别"   >
          <a href="#程序中断和子程序调用的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序中断和子程序调用的区别" class="headerlink" title="程序中断和子程序调用的区别"></a><strong>程序中断和子程序调用的区别</strong></h3>
      <p>1）调用子程序的CALL指令的时机是固定的；中断是随机发生的</p>
<p>2）子程序的调用只涉及到软件；中断是软硬结合的过程</p>
<p>3）子程序由调用指令直接给出目标地址；中断要通过中断隐指令得到中断向量</p>

        <h3 id="什么是上下文切换"   >
          <a href="#什么是上下文切换" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3>
      <p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 <strong>将 CPU 资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。 </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/">保研复习之英语单词</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><ul>
<li><p>abstraction layer，抽象层</p>
</li>
<li><p>access，获取，存取</p>
</li>
<li><p>Active Directory，活动目录</p>
</li>
<li><p>acyclic digraph，有向无环图</p>
</li>
<li><p>Parameter ,参数</p>
</li>
<li><p>affinity，绑定</p>
</li>
<li><p>Aggregate，聚合</p>
</li>
<li><p>analog，模拟的</p>
</li>
<li><p>architecture，体系机构，结构</p>
</li>
<li><p>margin [ˈmɑ:dʒin] n. 余量，边缘，边际</p>
</li>
<li><p>deep neural network (DNN) 深度神经网络 </p>
</li>
<li><p>Linear Regression 线性回归 </p>
</li>
<li><p>Max-Pooling 最大池化 </p>
</li>
<li><p>Reinforcement Learning (RL) 强化学习</p>
</li>
<li><p>gradient descent 梯度下降</p>
</li>
<li><p>Threhold 阈值 </p>
</li>
<li><p>exploding gradient  [ˈɡreɪdiənt]梯度爆炸 </p>
</li>
<li><p>mometum 动量</p>
</li>
<li><p>hyperparameter 超参数</p>
</li>
<li><p>Activation Function 激活函数</p>
</li>
<li><p>Convolutional Neural Network (CNN) 卷积神经网络 </p>
</li>
<li><p>Backpropagation 反向传播 </p>
</li>
<li><p>bias units 激活值 </p>
</li>
<li><p>hidden (layer) units 隐藏层&#x2F;隐藏单元 </p>
</li>
<li><p>forward pass 前向传播 </p>
</li>
<li><p>correlation 相关系数 </p>
</li>
<li><p>dataset augmentation 数据增强 </p>
</li>
<li><p>derivative 导数 </p>
</li>
<li><p>Normalization 归一化 </p>
</li>
<li><p>Objective function 目标函数</p>
</li>
<li><p>Generalization 泛化 </p>
</li>
<li><p>Global Optimization 全局优化 </p>
</li>
<li><p>directed 有向 </p>
</li>
<li><p>dot product 点积 </p>
</li>
<li><p>embedding 嵌入 </p>
</li>
<li><p>determinant 行列式 </p>
</li>
<li><p>infinite 无穷 </p>
</li>
<li><p>integral 积分 </p>
</li>
<li><p>atomicity，原子性</p>
</li>
<li><p>attribute，特性</p>
</li>
<li><p>autonomous，独立性</p>
</li>
<li><p>baud，波特</p>
</li>
<li><p>block，阻断</p>
</li>
<li><p>Central Processing Unit，中央处理器（CPU）</p>
</li>
<li><p>channel，信道，频道</p>
</li>
<li><p>compatibility，兼容性</p>
</li>
<li><p>properties  特性</p>
</li>
<li><p>emergence 出现</p>
<hr>
</li>
<li><p>convolutional  卷积</p>
</li>
<li><p>spectral domain  谱域</p>
</li>
<li><p>implemented by  实现</p>
</li>
<li><p>supplemented  补充</p>
</li>
<li><p>comprehensively summarizes   全面总结</p>
</li>
<li><p>prospected  勘测</p>
</li>
<li><p>systematically review  系统回顾</p>
</li>
<li><p>Furthermore  进而</p>
</li>
<li><p>hybrid attention mechanism 混合注意力机制</p>
</li>
<li><p>namely  也即是</p>
</li>
<li><p>mitigate the interference  减轻干扰</p>
</li>
<li><p>cognitive intelligence 认知智能</p>
</li>
<li><p>knowledge graphs 知识图谱</p>
</li>
<li><p>distantly supervised training samples 远程监督训练样本</p>
</li>
<li><p>intelligent recommendation 智能推荐</p>
</li>
<li><p>conversation system 对话系统</p>
</li>
<li><p>Internet of things 物联网</p>
</li>
<li><p>secure multiparty computation 安全多方计算</p>
</li>
<li><p>jointly  共同地</p>
</li>
<li><p>cryptographic technology  密码技术</p>
</li>
<li><p>implementation framework 实施框架</p>
</li>
<li><p>oblivious transfer 不经意传输</p>
</li>
<li><p>threshold  阈值</p>
</li>
<li><p>adversary model 对抗型模式</p>
</li>
<li><p>security proof  安全证明</p>
</li>
<li><p>overview  概述；概况 </p>
</li>
<li><p>distribution statistics 分布统计</p>
</li>
<li><p>evaluations  定值，估计</p>
</li>
<li><p>prospected 勘测</p>
</li>
<li><p>corresponding to 对应的</p>
</li>
<li><p>Federated learning 联邦学习</p>
</li>
<li><p>model convergence rate 模型收敛速度</p>
</li>
<li><p>resource coordination 资源协调</p>
</li>
<li><p>expounded 阐述；说明； </p>
</li>
<li><p>adaptive learning 自适应学习</p>
</li>
<li><p>incentive mechanisms 激励机制</p>
</li>
<li><p>deploys  部署</p>
</li>
<li><p>Specifically 具体地;特别是</p>
</li>
<li><p>heterogeneous  各种各样的</p>
</li>
<li><p>innovation points 创新点</p>
</li>
<li><p>small perturbation 扰动</p>
</li>
<li><p>clean examples  自然样本</p>
</li>
<li><p>input dissociation 输入解离 </p>
</li>
<li><p>survey researches 调查研究 </p>
</li>
<li><p>evolution  演变</p>
</li>
<li><p>analyzes  分析 </p>
</li>
<li><p>selective redundancy 选择性冗余</p>
</li>
<li><p>adopts  采用</p>
</li>
<li><p>linear approximation[əˌprɑːksɪˈmeɪʃn] 线性逼近</p>
</li>
<li><p>data suite 数据集</p>
</li>
<li><p>subjoins  添加</p>
</li>
<li><p>predicate slice 谓词片 </p>
</li>
<li><p>adverse influence 负作用</p>
</li>
<li><p>distribution  分布</p>
</li>
<li><p>incrementally   增量的；迭代的</p>
</li>
<li><p>decimal[ˈdesɪml]  places 小数位</p>
</li>
<li><p>critical  临界的；危急的；关键的 </p>
</li>
<li><p>deviations  偏差</p>
</li>
<li><p>emerge in 出现在</p>
</li>
<li><p>representation 表示</p>
</li>
<li><p>intensity 强烈;紧张;</p>
</li>
<li><p>nominal model 标称模型</p>
</li>
<li><p>invalidation [ɪnˌvælɪˈdeɪʃn] 失效</p>
</li>
<li><p>Reversible  可逆的</p>
</li>
<li><p>error-free 无损</p>
</li>
<li><p>pixel 像素</p>
</li>
<li><p>preprocessing step 预处理阶段</p>
</li>
<li><p>non-overlapping blocks 非重叠；不重叠的； </p>
</li>
<li><p>compressed  压缩</p>
</li>
<li><p>corresponding key 对应的密钥</p>
</li>
<li><p>arithmetic coding 算数编码</p>
</li>
<li><p>pseudo-random 伪随机</p>
</li>
<li><p>domestic and foreign 国内外</p>
</li>
<li><p>temporal correlation 时间相关性</p>
</li>
<li><p>literatures  文献</p>
</li>
<li><p>so as to  为了</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/hello-world/">Hello World</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/" >Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/" >documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html" >troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html" >Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server"   >
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/server.html" >Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files"   >
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html" >Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites"   >
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html" >Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">time_cool</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/timecool-cpu" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/shi-guang-85-73-85" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">19</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>水水水</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@1.0.1/dist/quicklink.umd.js"></script><script>function initQuicklink() {
  quicklink({
    timeout: '10000',
    priority: true,
    ignores: [uri => uri.includes('#'), uri => uri === 'http://example.com/page/2/', /\/api\/?/,uri => uri.includes('.xml'),uri => uri.includes('.zip'),(uri, el) => el.hasAttribute('nofollow'),(uri, el) => el.hasAttribute('noprefetch')]
  });
}

if (false || false) {
  initQuicklink();
} else {
  window.addEventListener('DOMContentLoaded', initQuicklink, false);
}</script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>