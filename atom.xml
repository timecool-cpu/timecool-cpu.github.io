<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光cool的博客仓库</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-09T13:01:44.733Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>水水水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣精选</title>
    <link href="http://example.com/2022/10/09/%E5%8A%9B%E6%89%A3%E5%A5%BD%E9%A2%98/"/>
    <id>http://example.com/2022/10/09/%E5%8A%9B%E6%89%A3%E5%A5%BD%E9%A2%98/</id>
    <published>2022-10-09T10:24:35.194Z</published>
    <updated>2022-10-09T13:01:44.733Z</updated>
    
    <content type="html"><![CDATA[        <h4 id="856-括号的分数"   >          <a href="#856-括号的分数" class="heading-link"><i class="fas fa-link"></i></a><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/score-of-parentheses/" >856. 括号的分数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>分治</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!s.<span class="built_in">size</span>()||s.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) sum+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> sum+=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==s.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">scoreOfParentheses</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>,s.<span class="built_in">size</span>()<span class="number">-2</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">scoreOfParentheses</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i+<span class="number">1</span>))+<span class="built_in">scoreOfParentheses</span>(s.<span class="built_in">substr</span>(i+<span class="number">1</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>栈应用</strong></p><blockquote><p><img src="https://gitee.com/zhang-yingmiao/typora-photos/raw/master/img/202210091945577.png" alt="image-20221009194551510"></p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;a;</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a.<span class="built_in">top</span>()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">a.<span class="built_in">top</span>()+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=a.<span class="built_in">top</span>();</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">a.<span class="built_in">top</span>()+=<span class="number">2</span>*t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h4 id=&quot;856-括号的分数&quot;   &gt;
          &lt;a href=&quot;#856-括号的分数&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#856-括号的分数&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://example.com/2022/10/05/%E5%89%91%E6%8C%87offer/"/>
    <id>http://example.com/2022/10/05/%E5%89%91%E6%8C%87offer/</id>
    <published>2022-10-05T13:03:41.657Z</published>
    <updated>2022-10-12T05:18:08.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="D:\Blog\blog\source_posts\assets\192eacb527ce46e383e6ae27833f6608a20e598f.jpg@1036w-16655518695851.webp" alt="192eacb527ce46e383e6ae27833f6608a20e598f.jpg@1036w"></p><p><img src="D:\Blog\blog\source_posts\assets\微信截图_20220712180954.png" alt="微信截图_20220712180954"></p>        <h4 id="剑指-Offer-II-001-整数除法"   >          <a href="#剑指-Offer-II-001-整数除法" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-001-整数除法" class="headerlink" title="剑指 Offer II 001. 整数除法"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/xoh6Oh/" >剑指 Offer II 001. 整数除法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>边界处理</strong>（巨恶心）</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> f= (a&lt;<span class="number">0</span>)^(b&lt;<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(a==INT32_MIN&amp;&amp;b==<span class="number">-1</span>)<span class="keyword">return</span> INT32_MAX;</span><br><span class="line"><span class="keyword">if</span>(a==INT32_MIN&amp;&amp;b==<span class="number">1</span>) <span class="keyword">return</span> INT32_MIN;</span><br><span class="line"><span class="keyword">if</span>(b==INT32_MIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a==INT32_MIN)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>) a=-a;</span><br><span class="line"><span class="keyword">if</span>(b&gt;<span class="number">0</span>) b=-b;</span><br><span class="line"><span class="type">int</span> k[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) k[i]=INT32_MIN;</span><br><span class="line">k[<span class="number">0</span>]=b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k[i<span class="number">-1</span>]&lt;=a||k[i<span class="number">-1</span>]&lt;<span class="number">-1073741824</span>) <span class="keyword">break</span>;</span><br><span class="line">k[i]=k[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k[idx]&gt;=a-k[idx]) idx++;</span><br><span class="line"><span class="keyword">if</span>(idx==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;k[idx])</span><br><span class="line">&#123;</span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a-=k[<span class="number">0</span>];</span><br><span class="line">ans+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">a-=k[idx];</span><br><span class="line">ans+=<span class="number">1</span>&lt;&lt;idx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f?-ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-002-二进制加法"   >          <a href="#剑指-Offer-II-002-二进制加法" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-002-二进制加法" class="headerlink" title="剑指 Offer II 002. 二进制加法"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/JFETK5/" >剑指 Offer II 002. 二进制加法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>经典进位</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">        string c;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+b[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">0</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>),f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+b[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">1</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>),f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+b[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">2</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>),f=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+b[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">3</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>),f=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>();i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">0</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>),f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">1</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>),f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-<span class="string">&#x27;0&#x27;</span>+f==<span class="number">2</span>) c.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>),f=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f) c.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-003-前-n-个数字二进制中-1-的个数"   >          <a href="#剑指-Offer-II-003-前-n-个数字二进制中-1-的个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-003-前-n-个数字二进制中-1-的个数" class="headerlink" title="剑指 Offer II 003. 前 n 个数字二进制中 1 的个数"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/w3tCBm/" >剑指 Offer II 003. 前 n 个数字二进制中 1 的个数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>lowbit</strong></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lowbit(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        return n&amp;-n;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; countBits(int n) &#123;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        for(int i=0;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int k=i;</span><br><span class="line">            int t=0;</span><br><span class="line">            while(k)</span><br><span class="line">            &#123;</span><br><span class="line">                k-=lowbit(k);</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><blockquote><p>利用 Brian Kernighan 算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 x，令 x&#x3D;x &amp; (x−1)，该运算将 xx 的二进制表示的最后一个 1变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。</p></blockquote><p><strong>动态规划</strong></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还没写，待补</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-004-只出现一次的数字"   >          <a href="#剑指-Offer-II-004-只出现一次的数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-004-只出现一次的数字" class="headerlink" title="剑指 Offer II 004. 只出现一次的数字 "></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/WGki4K/" >剑指 Offer II 004. 只出现一次的数字 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>哈希</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">        </span><br><span class="line">            ++freq[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [num, occ]: freq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (occ == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>位统计</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c&gt;&gt;i&amp;<span class="number">1</span>)a[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) a[i]=a[i]%<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">&#123;</span><br><span class="line">ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-005-单词长度的最大乘积"   >          <a href="#剑指-Offer-II-005-单词长度的最大乘积" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/aseY1I/" >剑指 Offer II 005. 单词长度的最大乘积</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>暴力</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> st[<span class="number">1005</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                st[i][words[i][j]-<span class="string">&#x27;a&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> len1=words[i].<span class="built_in">size</span>(),len2=words[j].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;words[i].<span class="built_in">size</span>();k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[j][words[i][k]-<span class="string">&#x27;a&#x27;</span>]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        f=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!f) ans=<span class="built_in">max</span>(ans,len1*len2);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>位优化</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;mask;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t|=(<span class="number">1</span>&lt;&lt;(words[i][j]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            mask.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len1=words[i].<span class="built_in">size</span>(),len2=words[j].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span>(mask[i]&amp;mask[j]) <span class="keyword">continue</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,len1*len2);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-006-排序数组中两个数字之和"   >          <a href="#剑指-Offer-II-006-排序数组中两个数字之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-006-排序数组中两个数字之和" class="headerlink" title="剑指 Offer II 006. 排序数组中两个数字之和"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/kLl5u1/" >剑指 Offer II 006. 排序数组中两个数字之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>双指针</strong></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">int l=0,r=numbers.size()-1;</span><br><span class="line">while(numbers[l]+numbers[r]!=target)</span><br><span class="line">&#123;</span><br><span class="line">if(numbers[l]+numbers[r]&gt;target) r--;</span><br><span class="line">else l++;</span><br><span class="line">&#125;</span><br><span class="line">return &#123;l,r&#125;;</span><br><span class="line">    &#125;p</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-007-数组中和为-0-的三个数"   >          <a href="#剑指-Offer-II-007-数组中和为-0-的三个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-007-数组中和为-0-的三个数" class="headerlink" title="剑指 Offer II 007. 数组中和为 0 的三个数"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/1fGaJU/" >剑指 Offer II 007. 数组中和为 0 的三个数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>排序+双指针</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> k=len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span>(k&gt;j&amp;&amp;nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>) k--;</span><br><span class="line"><span class="keyword">if</span>(k&gt;j&amp;&amp;nums[i]+nums[j]+nums[k]==<span class="number">0</span>) res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-008-和大于等于-target-的最短子数组"   >          <a href="#剑指-Offer-II-008-和大于等于-target-的最短子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-008-和大于等于-target-的最短子数组" class="headerlink" title="剑指 Offer II 008. 和大于等于 target 的最短子数组"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/2VG8Kg/" >剑指 Offer II 008. 和大于等于 target 的最短子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>双指针O(n)</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans=INT32_MAX;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(l&lt;len&amp;&amp;r&lt;len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(sum&lt;target&amp;&amp;r+<span class="number">1</span>&lt;len)</span><br><span class="line">&#123;</span><br><span class="line">sum+=nums[++r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=target) ans=<span class="built_in">min</span>(ans,r-l+<span class="number">1</span>);</span><br><span class="line">sum-=nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==INT32_MAX)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>二分查找O(nlogn)</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line"><span class="type">int</span> ans=INT32_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ss=sum[i<span class="number">-1</span>]+target;</span><br><span class="line"><span class="keyword">auto</span> p=<span class="built_in">lower_bound</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>(),ss);</span><br><span class="line"><span class="keyword">if</span>(p!=sum.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num=p-sum.<span class="built_in">begin</span>()-i+<span class="number">1</span>;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans==INT32_MAX?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><blockquote><p>lower_bound(start,last,n)  :返回第一个大于等于n的地址</p><p>upper_bound(start,last,n)  :返回第一个大于n的地址</p></blockquote>        <h4 id="剑指-Offer-II-009-乘积小于-K-的子数组"   >          <a href="#剑指-Offer-II-009-乘积小于-K-的子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-009-乘积小于-K-的子数组" class="headerlink" title="剑指 Offer II 009. 乘积小于 K 的子数组"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/ZVAVXX/" >剑指 Offer II 009. 乘积小于 K 的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>滑动窗口</strong></p><p>法1：固定左端点（注意边界处理）</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; len &amp;&amp; r &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (r + <span class="number">1</span> &lt; len &amp;&amp; r &lt; l)</span><br><span class="line">sum *= nums[++r];</span><br><span class="line"><span class="keyword">while</span> (r + <span class="number">1</span> &lt; len &amp;&amp; sum &lt; k)</span><br><span class="line">sum *= nums[++r];</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= k)</span><br><span class="line">ans += r - l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += r - l + <span class="number">1</span>;</span><br><span class="line">sum /= nums[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>法2：固定右端点</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prod = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            prod *= nums[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; prod &gt;= k) &#123;</span><br><span class="line">                prod /= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/ZVAVXX/solution/cheng-ji-xiao-yu-k-de-zi-shu-zu-by-leetc-xqx8/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-010-和为-k-的子数组"   >          <a href="#剑指-Offer-II-010-和为-k-的子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-010-和为-k-的子数组" class="headerlink" title="剑指 Offer II 010. 和为 k 的子数组"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/QTMn0o/" >剑指 Offer II 010. 和为 k 的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>前缀和+哈希</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs.<span class="built_in">count</span>(sum[i]-k)) ans+=hs[sum[i]-k];</span><br><span class="line">hs[sum[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><blockquote><p>用哈希遍历前缀和的时候不要直接遍历，可以加入判断，使得在其中就满足了下标的符合关系,就不需要后续添加一个index数组来记录对应的下标。</p></blockquote>        <h4 id="剑指-Offer-II-011-0-和-1-个数相同的子数组"   >          <a href="#剑指-Offer-II-011-0-和-1-个数相同的子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-011-0-和-1-个数相同的子数组" class="headerlink" title="剑指 Offer II 011. 0 和 1 个数相同的子数组"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/A1NYOS/" >剑指 Offer II 011. 0 和 1 个数相同的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>前缀和+哈希</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:nums) <span class="keyword">if</span>(c==<span class="number">0</span>) c=<span class="number">-1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!hs.<span class="built_in">count</span>(sum[i])) hs[sum[i]]=i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,i-hs[sum[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-012-左右两边子数组的和相等"   >          <a href="#剑指-Offer-II-012-左右两边子数组的和相等" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-012-左右两边子数组的和相等" class="headerlink" title="剑指 Offer II 012. 左右两边子数组的和相等"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/tvdfij/" >剑指 Offer II 012. 左右两边子数组的和相等</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>前缀和</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)  sum+=c;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sum-l-nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">l+=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-013-二维子矩阵的和"   >          <a href="#剑指-Offer-II-013-二维子矩阵的和" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-013-二维子矩阵的和" class="headerlink" title="剑指 Offer II 013. 二维子矩阵的和"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/O4NDxx/" >剑指 Offer II 013. 二维子矩阵的和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>二维前缀和</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; h;</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line"><span class="type">int</span> len=matrix.<span class="built_in">size</span>();</span><br><span class="line">h.<span class="built_in">resize</span>(len+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">&#123;</span><br><span class="line">h[i].<span class="built_in">resize</span>(matrix[<span class="number">0</span>].<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=matrix[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line">h[i][j]=h[i][j<span class="number">-1</span>]+h[i<span class="number">-1</span>][j]-h[i<span class="number">-1</span>][j<span class="number">-1</span>]+matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-h[row2+<span class="number">1</span>][col1]-h[row1][col2+<span class="number">1</span>]+h[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-014-字符串中的变位词"   >          <a href="#剑指-Offer-II-014-字符串中的变位词" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-014-字符串中的变位词" class="headerlink" title="剑指 Offer II 014. 字符串中的变位词"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/MPnaiL/" >剑指 Offer II 014. 字符串中的变位词</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>哈希字符串遍历</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length1=s1.<span class="built_in">size</span>(),length2=s2.<span class="built_in">size</span>();</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hs1,hs2;</span><br><span class="line"><span class="keyword">if</span>(length1&gt;length2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++) </span><br><span class="line">&#123;</span><br><span class="line">hs1[s1[i]]++;</span><br><span class="line">hs2[s2[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hs1.<span class="built_in">size</span>()==hs2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> f=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:hs1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c.second!=hs2[c.first]) &#123;f=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=length1,j=<span class="number">0</span>;i&lt;length2;i++,j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(--hs2[s2[j]]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">hs2.<span class="built_in">erase</span>(s2[j]);</span><br><span class="line">&#125;</span><br><span class="line">hs2[s2[i]]++;</span><br><span class="line"><span class="keyword">if</span>(hs1.<span class="built_in">size</span>()==hs2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> f=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:hs1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c.second!=hs2[c.first]) &#123;f=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-015-字符串中的所有变位词"   >          <a href="#剑指-Offer-II-015-字符串中的所有变位词" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-015-字符串中的所有变位词" class="headerlink" title="剑指 Offer II 015. 字符串中的所有变位词"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/VabMRr/" >剑指 Offer II 015. 字符串中的所有变位词</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>复用上一题的代码</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(s1,s2);</span><br><span class="line"><span class="type">int</span> length1=s1.<span class="built_in">size</span>(),length2=s2.<span class="built_in">size</span>();</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hs1,hs2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++) </span><br><span class="line">&#123;</span><br><span class="line">hs1[s1[i]]++;</span><br><span class="line">hs2[s2[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hs1.<span class="built_in">size</span>()==hs2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs1==hs2) ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);<span class="comment">//直接使用重载=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=length1,j=<span class="number">0</span>;i&lt;length2;i++,j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(--hs2[s2[j]]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">hs2.<span class="built_in">erase</span>(s2[j]);</span><br><span class="line">&#125;</span><br><span class="line">hs2[s2[i]]++;</span><br><span class="line"><span class="keyword">if</span>(hs1.<span class="built_in">size</span>()==hs2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs1==hs2) ans.<span class="built_in">emplace_back</span>(j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-016-不含重复字符的最长子字符串"   >          <a href="#剑指-Offer-II-016-不含重复字符的最长子字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-016-不含重复字符的最长子字符串" class="headerlink" title="剑指 Offer II 016. 不含重复字符的最长子字符串"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/wtcaE1/" >剑指 Offer II 016. 不含重复字符的最长子字符串</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>哈希遍历</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c=s[i];</span><br><span class="line">            <span class="keyword">if</span>(hs.<span class="built_in">count</span>(c))</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,(<span class="type">int</span>)hs.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> idx=hs[c];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=idx;k++) hs.<span class="built_in">erase</span>(s[k]);</span><br><span class="line">j=idx+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">            hs[c]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(<span class="type">int</span>)hs.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-017-含有所有字符的最短字符串"   >          <a href="#剑指-Offer-II-017-含有所有字符的最短字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-017-含有所有字符的最短字符串" class="headerlink" title="剑指 Offer II 017. 含有所有字符的最短字符串"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/M1oyTv/" >剑指 Offer II 017. 含有所有字符的最短字符串</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>滑动窗口就完了</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">string ans;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hs,hs2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:t) hs[c]++;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> diff=hs.<span class="built_in">size</span>();</span><br><span class="line">hs2=hs;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs2.<span class="built_in">count</span>(s[i]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(--hs2[s[i]]==<span class="number">0</span>) diff--;</span><br><span class="line"><span class="keyword">if</span>(diff==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=j;;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs2.<span class="built_in">count</span>(s[k]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hs2[s[k]]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!ans.<span class="built_in">size</span>()||ans.<span class="built_in">size</span>()&gt;i-k+<span class="number">1</span>) ans=s.<span class="built_in">substr</span>(k,i-k+<span class="number">1</span>);</span><br><span class="line">hs2[s[k]]++;</span><br><span class="line">diff++;</span><br><span class="line">j=k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> hs2[s[k]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-018-有效的回文"   >          <a href="#剑指-Offer-II-018-有效的回文" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-018-有效的回文" class="headerlink" title="剑指 Offer II 018. 有效的回文"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/XltzEq/" >剑指 Offer II 018. 有效的回文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>std::string的reverse和&#x3D;重载</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>) ss.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) ss.<span class="built_in">push_back</span>(c-<span class="string">&#x27;A&#x27;</span>+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;= <span class="string">&#x27;9&#x27;</span>) ss.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;ss;</span></span><br><span class="line">        string tmp=ss;</span><br><span class="line">        <span class="built_in">reverse</span>(ss.<span class="built_in">begin</span>(),ss.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ss==tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-019-最多删除一个字符得到回文"   >          <a href="#剑指-Offer-II-019-最多删除一个字符得到回文" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-019-最多删除一个字符得到回文" class="headerlink" title="剑指 Offer II 019. 最多删除一个字符得到回文"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/RQku0D/" >剑指 Offer II 019. 最多删除一个字符得到回文</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>分类讨论</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;s[l]==s[r]) l++,r--;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[l]==s[r<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            string s1=s.<span class="built_in">substr</span>(l,r-l);</span><br><span class="line">            string s2=s1;</span><br><span class="line">            <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(s1==s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[l+<span class="number">1</span>]==s[r])</span><br><span class="line">        &#123;</span><br><span class="line">            string s1=s.<span class="built_in">substr</span>(l+<span class="number">1</span>,r-l);</span><br><span class="line">            string s2=s1;</span><br><span class="line">            <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(s1==s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-020-回文子字符串的个数"   >          <a href="#剑指-Offer-II-020-回文子字符串的个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-020-回文子字符串的个数" class="headerlink" title="剑指 Offer II 020. 回文子字符串的个数"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/a7VOhD/" >剑指 Offer II 020. 回文子字符串的个数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>暴力</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                string ss=s.<span class="built_in">substr</span>(i,j-i+<span class="number">1</span>);</span><br><span class="line">                string sss=ss;</span><br><span class="line">                <span class="built_in">reverse</span>(ss.<span class="built_in">begin</span>(),ss.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(ss==sss) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>动态规划</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]!=s[j]) st[i][j]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j||i+<span class="number">1</span>==j) st[i][j]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>) st[i][j]=st[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"><span class="keyword">if</span>(st[i][j]) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-021-删除链表的倒数第-n-个结点"   >          <a href="#剑指-Offer-II-021-删除链表的倒数第-n-个结点" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-021-删除链表的倒数第-n-个结点" class="headerlink" title="剑指 Offer II 021. 删除链表的倒数第 n 个结点"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/SLwz0R/" >剑指 Offer II 021. 删除链表的倒数第 n 个结点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>双指针</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||n&lt;=<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* l=head,*r=head,*pre=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!r) <span class="keyword">break</span>;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=l;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre==l)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next=l-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> l;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-022-链表中环的入口节点"   >          <a href="#剑指-Offer-II-022-链表中环的入口节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/c32eOV/" >剑指 Offer II 022. 链表中环的入口节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>快慢指针</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* l = head-&gt;next,*r = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(r&amp;&amp;l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        r=head;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-023-两个链表的第一个重合节点"   >          <a href="#剑指-Offer-II-023-两个链表的第一个重合节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-023-两个链表的第一个重合节点" class="headerlink" title="剑指 Offer II 023. 两个链表的第一个重合节点"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/3u1WK4/" >剑指 Offer II 023. 两个链表的第一个重合节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>哈希集合</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hs;</span><br><span class="line">        ListNode* p=headA;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            hs.<span class="built_in">insert</span>(p);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headB;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.<span class="built_in">count</span>(p)) <span class="keyword">return</span> p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>双指针</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA||!headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pa=headA,*pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pa) pa=headB;</span><br><span class="line">            <span class="keyword">if</span>(!pb) pb=headA;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb) <span class="keyword">break</span>;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-024-反转链表"   >          <a href="#剑指-Offer-II-024-反转链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-024-反转链表" class="headerlink" title="剑指 Offer II 024. 反转链表"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/UHnkqh/" >剑指 Offer II 024. 反转链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>三指针</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* l=<span class="literal">nullptr</span>,*p,*r;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            r=p-&gt;next;</span><br><span class="line">            p-&gt;next=l;</span><br><span class="line">            l=p;</span><br><span class="line">            p=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>递归</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode*p = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-025-链表中的两数相加"   >          <a href="#剑指-Offer-II-025-链表中的两数相加" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-025-链表中的两数相加" class="headerlink" title="剑指 Offer II 025. 链表中的两数相加"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/lMSNwu/" >剑指 Offer II 025. 链表中的两数相加</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>栈实现加法</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;s1,s2;</span><br><span class="line">        ListNode* p=l1;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=l2;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;ss;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()) <span class="built_in">swap</span>(s1,s2);</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(s1.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=s1.<span class="built_in">top</span>(),b=s2.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">pop</span>();s2.<span class="built_in">pop</span>();</span><br><span class="line">            ss.<span class="built_in">push</span>((f+a+b)%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;(f+a+b)%10&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(f+a+b&gt;=<span class="number">10</span>) f=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> f=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=s2.<span class="built_in">top</span>();</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">            ss.<span class="built_in">push</span>((f+a)%<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;(f+a)%10&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(f+a&gt;=<span class="number">10</span>) f=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> f=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f) ss.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        ListNode* ans=<span class="literal">nullptr</span>,*cur;</span><br><span class="line">        <span class="keyword">while</span>(ss.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=ss.<span class="built_in">top</span>();</span><br><span class="line">            ss.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!ans)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="keyword">new</span> <span class="built_in">ListNode</span>(a);</span><br><span class="line">                cur=ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(a);</span><br><span class="line">                cur-&gt;next = p;</span><br><span class="line">                cur = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-026-重排链表"   >          <a href="#剑指-Offer-II-026-重排链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-026-重排链表" class="headerlink" title="剑指 Offer II 026. 重排链表"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/LGjMqU/" >剑指 Offer II 026. 重排链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>快慢指针求中点+链表逆序+链表合并</strong></p><blockquote><p><img src="https://gitee.com/zhang-yingmiao/typora-photos/raw/master/img/202210102137666.png" alt="image-20221010213711461"></p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* l=head,*r=head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(r)</span><br><span class="line">        &#123;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!r) <span class="keyword">break</span>;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        r = l-&gt;next;</span><br><span class="line">        ListNode* cur=r,*cl=<span class="literal">nullptr</span>,*cr=cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=cl;</span><br><span class="line">            cl=cur;</span><br><span class="line">            cur=cr;</span><br><span class="line">            <span class="keyword">if</span>(cur) cr=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1=head,*p2=cl;</span><br><span class="line">        <span class="keyword">while</span>(p2)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* t=p1-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">            p1 = t;</span><br><span class="line">            t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        p1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-027-回文链表"   >          <a href="#剑指-Offer-II-027-回文链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-027-回文链表" class="headerlink" title="剑指 Offer II 027. 回文链表"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/aMhZSa/" >剑指 Offer II 027. 回文链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>数组辅助</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;a;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>递归（高雅）</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode* front_point;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(head-&gt;next)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != front_point-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front_point = front_point-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        front_point = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-028-展平多级双向链表"   >          <a href="#剑指-Offer-II-028-展平多级双向链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-028-展平多级双向链表" class="headerlink" title="剑指 Offer II 028. 展平多级双向链表"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/Qv1Da2/" >剑指 Offer II 028. 展平多级双向链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>递归</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* head,Node* &amp;p1,Node* &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        p1 = head;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* t1=<span class="literal">nullptr</span>,*t2 = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            p2= cur;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;child) cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(cur-&gt;child,t1,t2);</span><br><span class="line">                Node* ne = cur-&gt;next;</span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                cur-&gt;next = t1;</span><br><span class="line">                t1-&gt;prev = cur;</span><br><span class="line">                t2-&gt;next = ne;</span><br><span class="line">                p2 = t2;</span><br><span class="line">                <span class="keyword">if</span>(ne) &#123;ne-&gt;prev = t2;&#125;</span><br><span class="line">                cur = ne;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        Node *p1=<span class="literal">nullptr</span>,*p2=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(head,p1,p2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h4 id="剑指-Offer-II-029-排序的循环链表"   >          <a href="#剑指-Offer-II-029-排序的循环链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-029-排序的循环链表" class="headerlink" title="剑指 Offer II 029. 排序的循环链表"></a><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/4ueAj6/" >剑指 Offer II 029. 排序的循环链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>      <p><strong>遍历</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(Node *head, <span class="type">int</span> insertVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node *p = head;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next != head)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;val &lt;= insertVal &amp;&amp; p-&gt;next-&gt;val &gt;= insertVal)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, p-&gt;next);</span><br><span class="line">                    p-&gt;next = tmp;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; p-&gt;next-&gt;val &amp;&amp; (insertVal &gt;= p-&gt;val || insertVal &lt;= p-&gt;next-&gt;val))</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, p-&gt;next);</span><br><span class="line">                    p-&gt;next = tmp;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node *tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, p-&gt;next);</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;D:\Blog\blog\source_posts\assets\192eacb527ce46e383e6ae27833f6608a20e598f.jpg@1036w-16655518695851.webp&quot; alt=&quot;192eacb527ce46e38</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之杂乱知识点</title>
    <link href="http://example.com/2022/10/05/%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/10/05/%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-10-05T12:52:25.231Z</published>
    <updated>2022-10-05T13:00:28.081Z</updated>
    
    <content type="html"><![CDATA[<p><code>printf``(``&quot;%o&quot;``, a); </code> 表示输出为8进制</p><p><code> ``int</code> <code>x = -1;</code></p><p><code>    ``unsigned ``int</code> <code>y = 2;</code></p><p>有符号数与无符号数比较，会自动转换为无符号数，x&gt;y</p><p>C++编译器也不保证浮点数a+b的结果等于b+a </p><p>随机访问且易于文件扩展的是索引结构的特性。 </p><p>对IP数据报分片的重组通常发生在目的主机<br>分段是发生在传输层，一般是TCP进行分段；分片是发生在网络层，IP层会将数据进行分片传输</p><p><strong>UDP不会分段，那就又IP来分片；TCP会自行分段，那么就不需要IP来分片了。</strong> </p><p>通道技术实现了I&#x2F;O系统的独立性和各个部件的并行性。（可以理解为不同的CPU主存可以<strong>通过不同的通道，执行不同的通道指令，控制控制器执行不同操作</strong>） </p>        <h4 id="广义表"   >          <a href="#广义表" class="heading-link"><i class="fas fa-link"></i></a><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4>      <p>（1）对任意一个非空的广义表，其表头可能是单元素，也可能是广义表。</p><p>（2）而其表尾一定是广义表。</p><p>广义表A&#x3D;((a),a)的表头是（a),表尾是(a)</p><p>把对视图的查询转化为对基本表的查询称为视图的消解 </p><p>select的执行顺序为：from where group having order by limit </p><p>有三类存储设备：独占设备、共享设备、虚拟设备</p><p>通过文件目录可以实现从文件名到文件（物理地址）的转化。 </p><p>C++中，能作为函数重载判断依据的是 参数类型、参数个数、Const</p><p>FTP使用21和20端口，用户通过21连接FTP服务器，服务器通过20与用户连接并传送数据 </p><p>多态有静态多态（编译时）和动态多态（运行时），静态多态主要实现了函数的重载和运算符的重载，动态时的多态主要实现了虚函数 </p><p>ICMP 差错控制报文不享受特别优先权</p><p>在父类的构造函数 和 析构函数 中都不能调用纯虚函数(不能以任何方式调用)。 </p><p>析构函数不能是虚函数和调用纯虚函数，但是可以自己申明为纯虚函数</p><p>构造函数可以被重载，不能为虚函数，没有返回值，创建对象时，基类的构造先调用，然后才是派生类里的</p><p>指针在64位系统中占用8个字节，A类中有3个指针，故占用24个字节。B类继承自A类且无成员变量和虚函数表，占用字节和A相同。 </p><p>分时系统最关键的问题是及时接收，及时处理。 </p><p>SATA 串口硬盘，是未来PC机硬盘的趋势， <span class="exturl"><a class="exturl__link"   href="http://baike.so.com/doc/1070721-1132939.html" >串行接口</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 还具有结构简单、支持热插拔的优点； </p><p>怎么标志分布在整个互联网上的万维网文档—统一资源定位符URL</p><p>用什么样的协议实现万维网上的各种链接—超文本传送协议HTTP</p><p>怎样使用不同风格的万维网文档都能在互联网上的主机上显示—超文本标记语言HTML</p><p>物理层中继系统：转发器(repeater)。</p><p>数据链路层中继系统：网桥或桥接器(bridge)。</p><p>网络层中继系统：路由器(router)。</p><p>网桥和路由器的混合物：桥路器(brouter)。</p><p>网络层以上的中继系统：网关(gateway)。</p><p> 对进程间互斥的使用临界资源，进程可以（互斥的进入各自的同类资源临界区）。 </p><hr><hr><hr><p>线性代数:正定矩阵、正则矩阵、矩阵求逆方法</p><p>英语问题:研究生规划</p><p>离散数学:相等关系和偏序关系是什么?闭包是什么?给你一个关系，怎么得到它的自反闭包?对称闭包?传递闭包?</p><p>优先级队列学过吗?什么时候用?怎么实现?</p><p>计算机网络:客户端和服务器传输数据怎么保证数据不丢失不错乱?</p><p>软件测试:白盒测试路径覆盖原理是什么?条件逻辑覆盖指的是什么?</p><p>研究生阶段最重要的品质,你觉得是什么?</p><p>英语介绍操作系统干啥的</p><p>应用软件怎么与操作系统协同工作？从计算机体系结构和操作系统的角度去说</p><p>操作系统：做过多线程吗？怎么样利用多核？做过多台电脑协同操作的项目吗？</p><p>AI：CNN的原理是什么？机器学习和深度学习的关系是什么？</p><p>两个栈实现队列</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈A  栈B</span><br><span class="line">队列入：栈B的数据都入栈A，然后数据入栈A</span><br><span class="line">队列出：栈A的数据入B直到有一个，然后A中数据输出出队列</span><br></pre></td></tr></table></div></figure><p>论文里的最让我感到棘手的地方是哪个</p><p>解释全概率公式</p><p>如何可视化高维特征</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不同的视图去表示数据的一部分属性</span><br><span class="line">利用平行坐标系</span><br></pre></td></tr></table></div></figure><p>求半副牌抽两张，没有大小王的概率</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(2,52)/C(2,54)</span><br></pre></td></tr></table></div></figure><p>十张考核牌里有四个难牌，甲乙丙三人抽题，抽出不放回，问1）三人都抽到难牌的概率？2）每个人抽到难牌的概率</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(3,4)/C(3,10)         4/10</span><br></pre></td></tr></table></div></figure><p>解释什么是二分</p><p>用动态规划解爬楼梯问题</p><p>求平方根的算法</p><p>汉诺塔问题，写伪代码</p><p>N个人围成圈，每三个人报数，报到3的人都离开，问最后还剩下的人，初始序号为？（约瑟夫环）</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//f(n)=(f(n-1)+3)%n;</span><br><span class="line">int dp[100001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[1]=0;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=(dp[i-1]+3)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>桌面上开始按钮的作用</p><p>回收站的作用</p><p>Linux的哲学是什么</p><p>指令和程序的区别是什么？指令的执行过程？指令和程序哪一个对计算机的性能影响更大？</p><p>解释检错码和纠错码？</p><p>浏览网页时在你输入网址到页面显示出来之间都发生了什么</p><p>你如何看待现在网络不安全的问题</p><p>什么是两个矩阵等价？用矩阵乘法严谨的表述</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线性代数和矩阵论中，有两个m×n阶矩阵A和B，如果这两个矩阵满足B=QAP(P是n×n阶可逆矩阵，Q是m×m阶可逆矩阵)，那么这两个矩阵之间是等价关系。</span><br></pre></td></tr></table></div></figure><p>为什么RGB三通道可以表示彩色图像？</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为人眼对红、绿、蓝最为敏感,人的眼睛像一个三色接收器的体系,大多数的颜色可以通过红、绿、蓝三色按照不同的比例合成产生</span><br><span class="line">三原色</span><br></pre></td></tr></table></div></figure><p>C语言中堆和栈的区别</p><p>什么程序适合多进程，什么程序适合多线程，各举3个例子</p><p>一阶导，二阶导的物理意义，几何意义</p><p>说下网络中的主机通信流程</p><p>一个主机将两个端口接到网络上是否会提升吞吐量？为什么？</p><p>给一个数组，求huffman树的高度。</p><p>解释一下什么是时间复杂度；</p><p>用英文解释 快速排序</p><p>解释下快排为什么快？不要说快排的什么复杂度或者算法过程，回答为什么快。</p><p>因为时间局部性和空间局部性，cache比主存快，读入一个数据时，会把它周围内存地址的数据存入cache，下次访问直接就访问cache了，而快排又经常访问相邻元素，所以比较快。</p><p>xgboost的原理，比如正负样本不平衡如何处理</p><p>中断的过程</p><p>极大值什么时候等于最大值</p><p>m维线性空间的定义</p><p>独立性和不相关的关系</p><p>ping的协议是什么？</p><p>IP可以唯一表示地址，为什么还需要每台电脑的网卡？</p><p>网卡的作用</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络是通过模拟信号将信息转化为电流传播的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</span><br></pre></td></tr></table></div></figure><p>集合的划分 </p><p>集合的基 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在逻辑代数里,表示集合中元素个数的数就叫做这个集合的“基数”</span><br></pre></td></tr></table></div></figure><p>什么是域、环</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域表示</span><br><span class="line">环则是由两个运算符，其中加法符合交换群，乘法符合半群，乘法对加法的分配律</span><br></pre></td></tr></table></div></figure><p>public类中哪些成员可以被子类访问； </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public和Protect中的成员函数和成员数据都是可以访问的</span><br><span class="line">友元函数也是可以被访问的</span><br><span class="line">同时被设置为虚函数的子类可以访问或者重载</span><br></pre></td></tr></table></div></figure><p>c++和java都是面向对象的编程语言，他们之间有什么区别？ </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c++虽然是面向对象，但也可以面向过程编程</span><br><span class="line">c++可以多继承，但是java不行</span><br><span class="line">java没有指针,new后得到的是一个对象的引用</span><br><span class="line">java对于对象会自动回收，防止内存泄漏</span><br></pre></td></tr></table></div></figure><p>c++变量有哪些前缀修饰符？ </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern</span><br><span class="line">const</span><br><span class="line">static</span><br><span class="line">signed、unsigned</span><br></pre></td></tr></table></div></figure><p>C++的引用是什么？ </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用就是给已经存在的变量取得一个别名，而不是新定义一个变量。编译器不会为引用变量开辟新得内存空间，引用变量和引用的变量共用同一内存空间。</span><br></pre></td></tr></table></div></figure><p>如何求第二条最短路？ </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spfa即可</span><br><span class="line">dis1[]记录最短路， dis2[]记录第二短路</span><br><span class="line">显然有</span><br><span class="line">1、如果dis1被更新则dis2 = 旧的dis1</span><br><span class="line">2、if (dis1[v] == dis1[u] + edge[i].dis &amp;&amp; dis2[v] &gt; dis2[u] + edge[i].dis)</span><br><span class="line">dis2[v] = dis2[u] + edge[i].dis;</span><br><span class="line">3、if (dis1[v] &lt; dis1[u] + edge[i].dis &amp;&amp; dis2[v] &gt; dis1[u] + edge[i].dis) &#123;</span><br><span class="line">dis2[v] = dis1[u] + edge[i].dis;</span><br></pre></td></tr></table></div></figure><p>C++引用和指针的区别。 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。</span><br><span class="line">引用初始化后不能被改变，指针可以改变所指的对象。</span><br><span class="line">不存在指向空值的引用，但是存在指向空值的指针。</span><br></pre></td></tr></table></div></figure><p>寄存器寻址方式 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">立即数寻址方式</span><br><span class="line">寄存器寻址</span><br><span class="line">寄存器直接寻址</span><br><span class="line">寄存器间接寻址</span><br><span class="line">相对寻址</span><br><span class="line">基址加编址寻址</span><br><span class="line">相对基址加编址寻址：操作数的有效地址由于基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到。</span><br></pre></td></tr></table></div></figure><p>有哪些稳定的算法？ 不稳定的算法？</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">稳定的算法：插入排序、折半插入排序、冒泡排序、归并排序</span><br><span class="line">不稳定的算法：快速排序、堆排序、选择排序、希尔排序</span><br></pre></td></tr></table></div></figure><p>算法复杂度的定义是什么？ 那O(n)的大O是什么意思 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫做渐进时间复杂度。大O符号表示程序运行时的渐进时间复杂度的上界，所以大O表示最坏情况下的时间复杂度</span><br></pre></td></tr></table></div></figure><p>何为系统调用？ </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS与应用进程之间的接口，它是用户程序取得OS服务的唯一途径，与一般过程调用的区别：运行在不同系统状态。调用程序运行在用户态，被调用程序运行在系统态，通过软中断机制，先由用户态转为系统态，才能转向相应的系统调用子程序。一般过程调用返回后继续执行，但对系统调用，当调用的进程仍具有最高优先权时，才返回到调用进程继续处理，否则只能等被重新调度</span><br></pre></td></tr></table></div></figure><p>Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别** </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） new、delete 是操作符，可以重载，只能在 C++中使用。</span><br><span class="line">（2） new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。malloc不会</span><br><span class="line">（3） new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。</span><br></pre></td></tr></table></div></figure><p>面向对象的三大特征** </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected， public）。</span><br><span class="line"> 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。</span><br><span class="line"> 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 这部分需要熟悉掌握原理虚函数，了解一些概念（静态多态、动态多态）等，面试时经常会问。</span><br></pre></td></tr></table></div></figure><p>static关键字有什么作用？</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；</span><br><span class="line">修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；</span><br><span class="line">修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；</span><br><span class="line">修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；</span><br><span class="line">修饰成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。</span><br></pre></td></tr></table></div></figure><p>变量的声明和定义有什么区别</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</span><br><span class="line"></span><br><span class="line">说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</span><br></pre></td></tr></table></div></figure><p>全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；</span><br><span class="line">而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</span><br><span class="line">操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。</span><br></pre></td></tr></table></div></figure><p>如何避免“野指针”</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。</span><br><span class="line">指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。</span><br><span class="line">指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。</span><br></pre></td></tr></table></div></figure><p>选择排序和冒泡排序的区别</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择排序是每次从无序中找到一个最小的和开头进行交换</span><br><span class="line">冒泡排序是遍历无序，每次有更小的就进行交换</span><br><span class="line">选择排序每次就只能选出一个，冒泡排序可以把一系列的顺序给锊顺</span><br><span class="line">冒泡排序是稳定的，选择排序是不稳定的</span><br></pre></td></tr></table></div></figure><p>哈希冲突的四种解决办法</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放寻址法</span><br><span class="line">拉链法</span><br><span class="line">建立公共溢出区</span><br><span class="line">再哈希法</span><br></pre></td></tr></table></div></figure><p><strong>OSI和TCP&#x2F;IP模型各个层之间的协议和功能</strong> </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层：负责处理应用程序的逻辑。</span><br><span class="line">传输层：进程间通信，实现分用复用</span><br><span class="line">网络层：实现不同主机间的通信，实现数据包的选路和转发</span><br><span class="line">链路层：实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>协议三要素 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、语义是解释控制信息每个部分的意义；</span><br><span class="line">2、语法是用户数据与控制信息的结构与格式，以及数据出现的顺序；</span><br><span class="line">3、时序是对事件发生顺序的详细说明。</span><br></pre></td></tr></table></div></figure><p>有了IP地址为什么还要有MAC地址？</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于利用原因在互联网中使用IP进行通信。IP地址一般表示的是一个网段，在互联网传输中大部分局域网都是通过防火墙后以代理IP进行数据包的发送，因此如果光使用IP地址的话无法实现如上的信息隐藏和发送代理。</span><br><span class="line">类似于寄快递，通过Ip地址可以确定送达的地方，通过MAC才能确定签收方。</span><br><span class="line">由于传输的场景不同，因此所使用的的参与也就有所不同。</span><br></pre></td></tr></table></div></figure><p><strong>一次HTTP请求过程</strong> </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）在浏览器中输入URL，并按下回车键；</span><br><span class="line">2）浏览器向DNS服务器发出域名解析请求并获得结果；</span><br><span class="line">3）根据目的IP地址和端口号，与服务器建立TCP连接；</span><br><span class="line">4）浏览器向服务器发送数据请求；</span><br><span class="line">5）服务器将网页数据发送给浏览器；</span><br><span class="line">6）通信完成，断开TCP连接；</span><br><span class="line">7）浏览器解析收到的数据并显示；</span><br></pre></td></tr></table></div></figure><p><strong>冯诺依曼体系结构</strong> </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算机主要由输入设备，输出设备，控制器，运算器，存储器该五个组成部分构成。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>完成一条指令的四个周期 </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•取指周期</span><br><span class="line">•间指周期</span><br><span class="line">•执行周期</span><br><span class="line">•中断周期</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;printf``(``&amp;quot;%o&amp;quot;``, a); &lt;/code&gt; 表示输出为8进制&lt;/p&gt;
&lt;p&gt;&lt;code&gt; ``int&lt;/code&gt; &lt;code&gt;x = -1;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;    ``unsigned ``int</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之线性代数</title>
    <link href="http://example.com/2022/10/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://example.com/2022/10/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2022-10-05T12:52:25.227Z</published>
    <updated>2022-10-05T12:58:03.084Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">伴随矩阵</span><br><span class="line">奇异矩阵：非可逆矩阵</span><br><span class="line">共轭矩阵</span><br><span class="line">反对称矩阵</span><br><span class="line">增广矩阵</span><br><span class="line">行阶梯型矩阵</span><br><span class="line">行最简型矩阵</span><br><span class="line">标准型矩阵</span><br><span class="line">初等矩阵</span><br><span class="line">代数余子式</span><br><span class="line">k阶子式</span><br><span class="line">满秩矩阵</span><br><span class="line">降秩矩阵</span><br><span class="line">向量组的线性相关性</span><br><span class="line">最大线性无关向量组（最大无关组）</span><br><span class="line">向量空间的基、维度</span><br><span class="line">向量的内积</span><br><span class="line">正交向量组</span><br><span class="line">规范正交基</span><br><span class="line">正交矩阵</span><br><span class="line">特征值</span><br><span class="line">特征向量</span><br><span class="line">特征方程</span><br><span class="line">特征多项式</span><br><span class="line">正定矩阵/半正定矩阵</span><br><span class="line">相似矩阵</span><br></pre></td></tr></table></div></figure>        <h3 id="线性代数中的线性代表的是什么？"   >          <a href="#线性代数中的线性代表的是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性代数中的线性代表的是什么？" class="headerlink" title="线性代数中的线性代表的是什么？"></a>线性代数中的线性代表的是什么？</h3>      <p><span class="exturl"><a class="exturl__link"   href="http://baike.baidu.com/view/300474.htm" >线性</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（linear）指量与量之间按比例、成直线的关系，在数学上可以理解为一阶<span class="exturl"><a class="exturl__link"   href="http://baike.baidu.com/view/30958.htm" >导数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>为<span class="exturl"><a class="exturl__link"   href="http://baike.baidu.com/view/122755.htm" >常数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的函数 </p><p><img src="https://img-blog.csdn.net/20161129141454990" alt="img"> </p>        <h3 id="矩阵的秩的含义？"   >          <a href="#矩阵的秩的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的秩的含义？" class="headerlink" title="矩阵的秩的含义？"></a>矩阵的秩的含义？</h3>      <p>基本含义：矩阵的秩就是矩阵中不等于0的子式的最大阶</p><p>对于行阶梯矩阵来说就是非零行的行数</p><p>对于向量组而言就是等于列向量组和行向量组的秩，也就是表示列向量组和行向量组的最大无关向量组所含向量的个数</p><p>对于向量空间而言那就是等于对应矩阵的行空间的维数</p><p>对于线性方程组解而言，假设A的秩为$$r_a&lt;n$$,那么对应于$Ax &#x3D; 0$这个方程他的解系含有$n-r_a$个解向量</p><p>对于线性变换而言，一个图形通过这个矩阵进行线性变化后它能保持非零体积的最大维度</p>        <h3 id="行列式的含义？"   >          <a href="#行列式的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#行列式的含义？" class="headerlink" title="行列式的含义？"></a>行列式的含义？</h3>      <p>基本概念：所有取自不同行不同列的数乘积的总和</p><p>本质意义：该矩阵在其对应维度的空间中所表示的图形的大小，二维表示的是面积，三维表示的是体积</p><p>与线性变化的关系：如果行列为0，那么说明通过该矩阵进行线性变化会丢失部分信息，可以表现为其对应空间的图形大小为0，同时该线性变化时不可逆的，将一组线性无关的矢量变成了线性相关的矢量。</p>        <h3 id="线性相关的含义？"   >          <a href="#线性相关的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性相关的含义？" class="headerlink" title="线性相关的含义？"></a>线性相关的含义？</h3>      <p>公式意义：$k_1\alpha _1+k_2\alpha _2+\dots +k_m\alpha _m&#x3D;0$至少存在一组非零解</p><p>可以理解为至少有一个向量可以由其余的向量通过线性组合表示</p><p>几何意义：n个向量线性无关那他们所张成的空间体积不为0</p><p>于是有这些线性无关向量组所构成的矩阵得到的行列式不为0，为可逆矩阵，同时矩阵的秩为n</p>        <h3 id="矩阵的特征值与特征向量有什么关系？"   >          <a href="#矩阵的特征值与特征向量有什么关系？" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的特征值与特征向量有什么关系？" class="headerlink" title="矩阵的特征值与特征向量有什么关系？"></a>矩阵的特征值与特征向量有什么关系？</h3>      <p>每个特征值都有其对应的特征向量，一个特征值可能有多个对应的特征向量（表示其重数）</p><p>一个特征向量只有一个特征值</p><p>他们符合$AX&#x3D;\lambda X$这一方程</p><p>特征值是指矩阵A对向量X的变换相当于一个伸缩变换，没有旋转变换，即相当于一个缩放因子*向量X。那么这个缩放因子是矩阵A的本质，即AX&#x3D;tX,t即为A的特征值。</p>        <h3 id="介绍一下正定矩阵"   >          <a href="#介绍一下正定矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下正定矩阵" class="headerlink" title="介绍一下正定矩阵"></a>介绍一下正定矩阵</h3>      <p>基本定义：这个矩阵所对应的所有特征值都是大于0的</p><p>广义定义：对于任意一个非零向量z，那么$z^TMz&gt;0$</p><p>判断是否为正定矩阵：①求出他的所有特征值，观察是否有小于等于0的特征值②根据两个特征值相加是正数，相乘也是正数，那么肯定特征值全部都是正数。 </p><p>性质：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行列式是大于0的， 是可逆矩阵，因此有一系列等价的。</span><br><span class="line">正定矩阵的逆也是正定矩阵，其逆的特征值分别都原来的倒数</span><br><span class="line">同时两个正定矩阵的和以及两个正定矩阵的积也都是正定矩阵。</span><br><span class="line">一个矩阵为正定矩阵当且仅当和单位矩阵合同</span><br><span class="line">矩阵的顺序主子式、主子式均为正</span><br></pre></td></tr></table></div></figure>        <h3 id="矩阵行列式不为0的充要条件"   >          <a href="#矩阵行列式不为0的充要条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵行列式不为0的充要条件" class="headerlink" title="矩阵行列式不为0的充要条件"></a>矩阵行列式不为0的充要条件</h3>      <p>&lt;&#x3D;&#x3D;&gt;该矩阵是可逆的</p><p>&lt;&#x3D;&#x3D;&gt;该矩阵的秩为n</p><p>&lt;&#x3D;&#x3D;&gt;$Ax &#x3D; 0$只有一个零解</p><p>&lt;&#x3D;&#x3D;&gt;存在同阶方阵B使得$AB&#x3D;E$</p><p>&lt;&#x3D;&#x3D;&gt;其伴随矩阵$A^*$的秩也为n，伴随矩阵的行列式也不为0</p><p>&lt;&#x3D;&#x3D;&gt;$Ax &#x3D; b$有唯一解</p><p>&lt;&#x3D;&#x3D;&gt;该矩阵对应的行向量组和列向量组都是线性无关的</p><p>&lt;&#x3D;&#x3D;&gt;任意的n维向量都可以由其列向量组唯一线性表示</p><p>&lt;&#x3D;&#x3D;&gt;该矩阵的每个特征值都不为0</p><p>&lt;&#x3D;&#x3D;&gt;其等价标准形式单位矩阵</p><p>&lt;&#x3D;&#x3D;&gt;$A^TA$为正定矩阵</p>        <h3 id="矩阵行列式为0的充要条件"   >          <a href="#矩阵行列式为0的充要条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵行列式为0的充要条件" class="headerlink" title="矩阵行列式为0的充要条件"></a>矩阵行列式为0的充要条件</h3>      <p>&lt;&#x3D;&gt; A不可逆 (又称奇异)</p><p>&lt;&#x3D;&gt; A的列(行)向量组<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3&spm=1001.2101.3001.7020" >线性相关</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>&lt;&#x3D;&gt; R(A)&lt;n &lt;&#x3D;&gt; AX&#x3D;0 有非零解 </p><p>&lt;&#x3D;&gt; A有特征值0. </p><p>&lt;&#x3D;&gt; A不能表示成初等矩阵的乘积 </p><p>&lt;&#x3D;&gt; A的等价标准形不是<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020" >单位矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>        <h3 id="求矩阵的秩"   >          <a href="#求矩阵的秩" class="heading-link"><i class="fas fa-link"></i></a><a href="#求矩阵的秩" class="headerlink" title="求矩阵的秩"></a>求矩阵的秩</h3>      <p>$\left(\begin{array}{cccc}a &amp; 1 &amp; \cdots &amp; 1 \1 &amp; a &amp; \cdots &amp; 1 \\vdots &amp; \vdots &amp; \ddots &amp; \vdots \1 &amp; 1 &amp; \cdots &amp; a\end{array}\right)$</p><p>转变成：</p><p>$$\left(\begin{array}{cccc}a-1 &amp; 0 &amp; \cdots &amp; 0 \0 &amp; a-1 &amp; \cdots &amp; 0 \\vdots &amp; \vdots &amp; \ddots &amp; \vdots \1 &amp; 1 &amp; \cdots &amp; 1\end{array}\right)$$</p><p>因此秩为n</p>        <h3 id="矩阵求逆的过程"   >          <a href="#矩阵求逆的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵求逆的过程" class="headerlink" title="矩阵求逆的过程"></a>矩阵求逆的过程</h3>      <p>1.使用待定系数法去列方程组进行求解，对于维度较低的矩阵比较好用</p><p>2.基于$A^{-1}&#x3D;\frac{1}{|A|} A *$</p><p>首先计算伴随矩阵：矩阵元素所对应的代数余子式，所构成的矩阵，转置后得到的新矩阵。</p><p>3.初等变换求逆矩阵</p><p>首先，写出增广矩阵A|E，即矩阵A右侧放置一个同阶的单位矩阵，得到一个新矩阵。</p><p>然后进行初等行变换。使得左边变成单位矩阵</p>        <h3 id="正定矩阵、正则矩阵、正交矩阵"   >          <a href="#正定矩阵、正则矩阵、正交矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#正定矩阵、正则矩阵、正交矩阵" class="headerlink" title="正定矩阵、正则矩阵、正交矩阵"></a>正定矩阵、正则矩阵、正交矩阵</h3>      <p>正定矩阵是他的特征值都大于0</p><p>正交矩阵是两个矩阵的内积为0</p><p>正则矩阵：所有矩阵经过初等行变换以后都能变成分块矩阵，其中一块是一个I矩阵，其他是0的分块矩阵，这样的分块矩阵叫做正则矩阵</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之微积分</title>
    <link href="http://example.com/2022/10/05/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    <id>http://example.com/2022/10/05/%E5%BE%AE%E7%A7%AF%E5%88%86/</id>
    <published>2022-10-05T12:52:25.223Z</published>
    <updated>2022-10-05T12:59:01.575Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">导数</span><br><span class="line">导函数</span><br><span class="line">可导</span><br><span class="line">求导</span><br><span class="line">可微</span><br><span class="line">微分</span><br><span class="line">连续可微：函数f(x)的导数f’(x)存在且是连续函数，则f(x)连续可微。</span><br><span class="line">多元函数</span><br><span class="line">偏增量</span><br><span class="line">全增量</span><br><span class="line">偏导数</span><br><span class="line">全导数</span><br><span class="line">偏微分</span><br><span class="line">全微分</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="什么是导数和导函数？"   >          <a href="#什么是导数和导函数？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是导数和导函数？" class="headerlink" title="什么是导数和导函数？"></a>什么是导数和导函数？</h3>      <p>函数y &#x3D; f(x) 在点x0的某个邻域内有定义， 则当自变量x在x0处取得增量 deltax，函数输出值也相应取得增量deltay。如果deltay与deltax的比值在delta_x趋于0时的极限存在，则f(x)在x0处的导数存在，即f(x)在x0处可导。该极限即为f(x)在x0处的导数，记作f’(x0)。如果函数的自变量和取值都是实数的话，那么函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率。</p><p>如果函数在一段区间中每个点都是可导的，那么我们将得到的导数和对应的x值对应起来，就可以得到对应区间的一个导函数，表示的是在对应x下该函数的导数。</p>        <h3 id="可导和可微之间的关系"   >          <a href="#可导和可微之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#可导和可微之间的关系" class="headerlink" title="可导和可微之间的关系"></a>可导和可微之间的关系</h3>      <p>首先可微可以推出可导</p><p>对于一元函数而言可微和可导是完全等价的，dy&#x3D;导数·dx</p><p>对于多元函数而言可微是需要在各个维度都可导才能推出的</p>        <h3 id="介绍一下夹逼定理"   >          <a href="#介绍一下夹逼定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下夹逼定理" class="headerlink" title="介绍一下夹逼定理"></a>介绍一下夹逼定理</h3>      <p>有三个函数在某一区间满足A&gt;B&gt;C，在区间中某个点$x_0$有$\lim_{x \to 0} A&#x3D;\lim_{x \to 0} C&#x3D;X$则必有$\lim_{x \to 0} B&#x3D;X$</p><p>定理内容：</p><p>若函数 <img   src="https://www.zhihu.com/equation?tex=F(x)" style=""  alt="F(x)"> 和 <img   src="https://www.zhihu.com/equation?tex=G(x)" style=""  alt="G(x)"> 在 <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 的邻域连续， <img   src="https://www.zhihu.com/equation?tex=x%5Crightarrow" style=""  alt="x\rightarrow"> <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 时极限都为 <img   src="https://www.zhihu.com/equation?tex=A" style=""  alt="A"> ，即 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BF(x)%7D+=+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BG(x)%7D+=+A" style=""  alt="\lim_{x \rightarrow x_{0}}{F(x)} = \lim_{x \rightarrow x_{0}}{G(x)} = A"> ，且在该 <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 的邻域一直满足 <img   src="https://www.zhihu.com/equation?tex=F(x)%5Cleq+f(x)+%5Cleq+G(x)" style=""  alt="F(x)\leq f(x) \leq G(x)"> 。</p><p>则当 <img   src="https://www.zhihu.com/equation?tex=x%5Crightarrow+x_%7B0%7D" style=""  alt="x\rightarrow x_{0}"> 时也有 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BF(x)%7D%5Cleq+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D%5Cleq+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BG(x)%7D" style=""  alt="\lim_{x \rightarrow x_{0}}{F(x)}\leq \lim_{x \rightarrow x_{0}}{f(x)}\leq \lim_{x \rightarrow x_{0}}{G(x)}"> ，也就是 <img   src="https://www.zhihu.com/equation?tex=A%5Cleq%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D+%5Cleq+A" style=""  alt="A\leq\lim_{x \rightarrow x_{0}}{f(x)} \leq A"> ，</p><p>所以 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D=A" style=""  alt="\lim_{x \rightarrow x_{0}}{f(x)}=A"> .</p>        <h3 id="介绍一下拉格朗日中值定理"   >          <a href="#介绍一下拉格朗日中值定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下拉格朗日中值定理" class="headerlink" title="介绍一下拉格朗日中值定理"></a>介绍一下拉格朗日中值定理</h3>      <p>定理：对于一个函数而言</p><p>（1）在(a,b)中可导  </p><p>（2）在[a,b]中连续  </p><p>（3）则必有一个 ξ∈(a,b)使得$f(b)-f(a)&#x3D;f’(\xi )*(b-a)$</p><p>几何含义：若连续曲线 y&#x3D;f(x) 在 A(a,f(a)), B(b,f(b)) 两点间的每一点处都有不垂直于x轴的切线，则曲线在 A,B 间至少存在一个点 P(c,f©)，使得该曲线在P点的切线与割线AB平行。 </p><p>物理含义：对于直线运动，在任意一个运动过程中至少存在一个位置（或一个时刻）的瞬时速度等于这个过程中的平均速度。</p>        <h3 id="介绍一下凸函数"   >          <a href="#介绍一下凸函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下凸函数" class="headerlink" title="介绍一下凸函数"></a>介绍一下凸函数</h3>      <p>定义：对于任意的$x_1,x_2$都有$f\left(\lambda x_{1}+(1-\lambda) x_{2}\right) \leq \lambda f\left(x_{1}\right)+(1-\lambda) f\left(x_{2}\right), \forall \lambda \in(0,1)$</p><p>例子：指数函数$y&#x3D;e^x$</p><p>判断条件：$f^{\prime \prime}(x) \geq 0, \forall x$</p><p>重要性质：琴生不等式（定义的推广）</p><p>那么对于任意的 $ \left{x_{1}, x_{2}, \cdots, x_{n}\right} $ ， 以及正的权重系数 $ \left{w_{1}, w_{2}, \cdots, w_{n}\right} $, 且  $w_{1}+w_{2}+\cdots+w_{n}&#x3D;1$ , 则如下不等式成立$f\left(\sum_{k&#x3D;1}^{n} w_{k} \cdot x_{k}\right) \leq \sum_{k&#x3D;1}^{n} w_{k} \cdot f\left(x_{k}\right)$</p>        <h3 id="你是如何理解e的？"   >          <a href="#你是如何理解e的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你是如何理解e的？" class="headerlink" title="你是如何理解e的？"></a>你是如何理解e的？</h3>      <p>来源命题：当增长率为100%时，让一个细胞总群能够增长的极限是扩大到e倍</p><p>含义：单位时间内，持续的翻倍增长所能达到的极限值</p><p>$lim（1+1&#x2F;x）^x $</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之数据库</title>
    <link href="http://example.com/2022/10/05/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/10/05/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-10-05T12:52:25.219Z</published>
    <updated>2022-10-05T12:59:36.821Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create database student;</span><br><span class="line">use student;</span><br><span class="line"></span><br><span class="line">create schema zhang;</span><br><span class="line">create table s ***;</span><br><span class="line">drop table zhang.s;</span><br><span class="line">drop schema zhang;</span><br><span class="line"></span><br><span class="line">foreign key(Cpno) reference s course(Cno);</span><br><span class="line"></span><br><span class="line">alter table student add graduation;</span><br><span class="line">alter table student unique(graduation);</span><br><span class="line">alter table student add foreign key(sno) references student(sno);</span><br><span class="line"></span><br><span class="line">order by子句：desc和asc</span><br><span class="line">distinct关键字：用于去重</span><br><span class="line">count：用于统计数量 </span><br><span class="line">sum、AVG、min、max条件用having</span><br><span class="line">group by子句：用于按属性分组使用group by子句后，select子句的列名列表中只能出现分组属性和聚集函数</span><br><span class="line">having短语作用于组，从中选择满足条件的元组</span><br><span class="line"></span><br><span class="line">外连接：full outer join 左外连接：left outer join 右外连接:right full outer join</span><br><span class="line">**同时原先的条件where变为on</span><br><span class="line"></span><br><span class="line">并集：union 交集：intersect 差操作：except</span><br><span class="line">插入：insert 修改数据：update 删除：delete </span><br></pre></td></tr></table></div></figure>        <h3 id="数据、数据库、数据库管系统、数据库系统"   >          <a href="#数据、数据库、数据库管系统、数据库系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据、数据库、数据库管系统、数据库系统" class="headerlink" title="数据、数据库、数据库管系统、数据库系统"></a>数据、数据库、数据库管系统、数据库系统</h3>      <p><strong>数据</strong>：数据库中存储的基本对象，描述一个事物的符号记录，数据和其语义不可分开说</p><p><strong>数据库</strong>（DB）：是长期储存在计算机内、有组织的、可共享的大量<strong>数据的集合。</strong></p><p><strong>数据库管理系统</strong>：一个管理数据的软件</p><p><strong>数据库系统</strong>：由数据库、数据库管理系统应用程序和数据库管理员（DBA）等组成的存储、管理、处理和维护数据的系统。 </p>        <h3 id="数据库提供的功能"   >          <a href="#数据库提供的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库提供的功能" class="headerlink" title="数据库提供的功能"></a>数据库提供的功能</h3>      <p><strong>数据定义功能：</strong> 建表、修改表、删除表、定义数据对象</p><p><strong>操纵功能：</strong> 增删查改</p><p><strong>事务管理和运行管理：</strong> 数据库由DBMS统一管理和控制保证数据的安全，完整性、多用户对数据的并发使用、发生故障后的系统恢复 </p><p><strong>建立和维护功能：</strong> 数据库转存、数据库恢复、性能分析</p>        <h3 id="数据的完整性约束条件"   >          <a href="#数据的完整性约束条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据的完整性约束条件" class="headerlink" title="数据的完整性约束条件"></a>数据的完整性约束条件</h3>      <p>实体完整性：具体的数据的属性信息是否完整，主键约束、唯一约束</p><p>参照完整性：该属性对应的值存在</p><p>用户定义完整性：</p>        <h3 id="数据库系统的三级模式结构"   >          <a href="#数据库系统的三级模式结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3>      <p>内模式：1）是<strong>数据物理结构和存储方式的描述</strong>；2）是数据在<strong>数据库内部的表示方式</strong> </p><p>​一个数据库只有一个内模式。 </p><p>模式：数据库中全体数据的逻辑结构和特征的描述，所有用户的公共数据视图，综合了所有用户的需求，<strong>一个数据库只有一个模式</strong> </p><p>外模式：模式的<strong>子集</strong>，一个数据库可以有多个，是数据库中局部数据的逻辑结构和特征的描述</p>        <h3 id="数据库的二级映像功能与数据的独立性"   >          <a href="#数据库的二级映像功能与数据的独立性" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的二级映像功能与数据的独立性" class="headerlink" title="数据库的二级映像功能与数据的独立性"></a>数据库的二级映像功能与数据的独立性</h3>      <p>外模式&#x2F;模式映像：保证了数据的逻辑独立性。不唯一</p><p>1）当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</p><p>2）应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p><p>模式&#x2F;内模式映像：保证了数据的物理独立性。唯一</p><p>1）当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变，进而外模式也不发生改变</p><p>2）应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性</p>        <h3 id="数据库系统的组成"   >          <a href="#数据库系统的组成" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h3>      <p>硬件，操作系统，数据库设计人员，数据库管理人员，数据库管理系统，用户等等。 </p>        <h3 id="CHAR-amp-VARCHAR"   >          <a href="#CHAR-amp-VARCHAR" class="heading-link"><i class="fas fa-link"></i></a><a href="#CHAR-amp-VARCHAR" class="headerlink" title="CHAR &amp; VARCHAR"></a>CHAR &amp; VARCHAR</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CHAR列的长度固定为创建表时声明的长度。 长度可以为从0到255的任何值。 </span><br><span class="line"></span><br><span class="line">比较时会在末尾补满空格后与现已存在的值比较。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值 </span><br><span class="line"></span><br><span class="line">VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值 </span><br><span class="line"></span><br><span class="line">VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。 </span><br></pre></td></tr></table></div></figure>        <h3 id="关系数据库标准语言SQL"   >          <a href="#关系数据库标准语言SQL" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL语句是结构化查询语句</span><br><span class="line">特点：综合统一、高度非过程化、面向集合、既可以是独立的语言也可以是嵌入式的语言</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="索引"   >          <a href="#索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引" class="headerlink" title="索引"></a>索引</h3>      <p>加入的目的是加快数据查询的速度 </p><p>DBA或者表的属主可以根据需要建立表的索引；但是有些DBMS可以自动建立以下索引 </p><p>分两种：聚簇索引和唯一性索引</p>        <h3 id="事务ACID包括代表的是什么？"   >          <a href="#事务ACID包括代表的是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务ACID包括代表的是什么？" class="headerlink" title="事务ACID包括代表的是什么？"></a>事务ACID包括代表的是什么？</h3>      <p>原子性 (Atomicity)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单个事务，为一个不可分割的最小工作单元，整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性</span><br></pre></td></tr></table></div></figure><p>一致性(Consistency)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中， 一致性确保了，即使在执行第三、四条语句之间时系统崩潰，信用卡账户也不会损失100块，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，保证数据一致性。</span><br></pre></td></tr></table></div></figure><p>隔离性(Isolation) </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</span><br></pre></td></tr></table></div></figure><p>持久性(Durability)</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</span><br></pre></td></tr></table></div></figure>        <h3 id="范式"   >          <a href="#范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#范式" class="headerlink" title="范式"></a>范式</h3>      <p>范式是指符合某一种级别的关系模式的集合，是关系型数据理论的基础。</p><p>一般涉及到1NF、2NF、3NF</p><p>1NF表示的是列的原子性，即列不能够再分为其他几列</p><p>2NF表示完全依赖与主键，不存在某非主键列只依赖于部分主键列</p><p>3NF消除了传递依赖，非主键列只能依赖于主键，不能存在传递依赖</p>        <h3 id="锁"   >          <a href="#锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁" class="headerlink" title="锁"></a>锁</h3>      <p>锁的类型有三种：  </p><p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。  </p><p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。  </p><p>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。 </p>        <h3 id="什么是视图？"   >          <a href="#什么是视图？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h3>      <p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比<span class="exturl"><a class="exturl__link"   href="https://www.zhihu.com/search?q=%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22268007494%22%7D" >多表查询</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。 </p>        <h3 id="除了关系型数据库还有什么数据库？"   >          <a href="#除了关系型数据库还有什么数据库？" class="heading-link"><i class="fas fa-link"></i></a><a href="#除了关系型数据库还有什么数据库？" class="headerlink" title="除了关系型数据库还有什么数据库？"></a>除了关系型数据库还有什么数据库？</h3>      <p>层次型数据库 IBM公司的IMS</p><p>网状数据库</p>        <h3 id="什么是数据库的完整性约束条件-可分为哪几类"   >          <a href="#什么是数据库的完整性约束条件-可分为哪几类" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是数据库的完整性约束条件-可分为哪几类" class="headerlink" title="什么是数据库的完整性约束条件?可分为哪几类?"></a>什么是数据库的完整性约束条件?可分为哪几类?</h3>      <p>完整性约束条件是指数据库中的数据应该满足的语义约束条件。一般可以分为六类:静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束。静态列级约束是对一个列的取值域的说明,包括以下几个方面: ( l )对数据类型的约束,包括数据的类型、长度、单位、精度等; ( 2 )对数据格式的约束; ( 3 )对取值范围或取值集合的约束; ( 4 )对空值的约束; ( 5 )其他约束.静态元组约束就是规定组成一个元组的各个列之间的约束关系,静态元组约束只局限在单个元组上。静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。 </p>        <h3 id="并发操作下可能会产生并发一致性问题"   >          <a href="#并发操作下可能会产生并发一致性问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发操作下可能会产生并发一致性问题" class="headerlink" title="并发操作下可能会产生并发一致性问题"></a><strong>并发操作下可能会产生并发一致性问题</strong></h3>      <p>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p>不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p>幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>        <h3 id="概念模型-逻辑模型和物理模型"   >          <a href="#概念模型-逻辑模型和物理模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念模型-逻辑模型和物理模型" class="headerlink" title="概念模型 逻辑模型和物理模型"></a>概念模型 逻辑模型和物理模型</h3>      <p>概念模型是现实世界的第一层抽象 E-R图</p><p>逻辑模型将概念模型转化为具体的数据模型的过程 层次&#x2F;网状&#x2F;关系&#x2F;面向对象</p><p>物理模型针对上述逻辑模型所说的内容 , 在具体的物理介质上实现出来 </p><p>这三个过程 , 就是实现一个数据库设计的三个关键的步骤 , 是一个从抽象到具体的一个不断细化完善的分析 , 设计和开发的过程 ; </p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之数据结构</title>
    <link href="http://example.com/2022/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-10-05T12:52:25.215Z</published>
    <updated>2022-10-05T12:59:49.003Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="算法的基本特征"   >          <a href="#算法的基本特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法的基本特征" class="headerlink" title="算法的基本特征"></a>算法的基本特征</h3>      <p>有效性、确定性、有穷性、有零个或多个输入、有一个或多个输出 </p><p>算法是一个有穷规则的集合，这些规则确定了解决某类问题的一个运算序列。对于该类问题的任何初始输入值，它都能机械地一步一步地执行计算，经过有限步骤后终止计算并产生输出结果。归纳起来，算法具有以下基本特征： (1)有穷性：一个算法必须在执行有限个操作步骤后终止； (2)确定性：算法中每一步的含义必须是确切的，不可出现任何二义性； (3)有效性：算法中的每一步操作都应该能有效执行，一个不可执行的操作是无效的。例如，一个数被0除的操作就是无效的，应当避免这种操作。 (4)有零个或多个输入：这里的输入是指在算法开始之前所需要的初始数据。这些输入的多少取决于特定的问题。 (5)有一个或多个输出：所谓输出是指与输入有某种特定关系的量，在一个完整的算法中至少会有一个输出。</p>        <h3 id="什么是数据结构？"   >          <a href="#什么是数据结构？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h3>      <p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020" >集合</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。结构包括逻辑结构和物理结构。</p><p><strong>数据的逻辑结构包括4种</strong></p><p>(1)集合：数据元素之间除了有相同的数据类型再没有其他的关系</p><p>(2)线性结构：数据元素之间是一对一的关系 ——线性表、栈、<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020" >队列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>(3)<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >树形结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：数据元素之间是一对多的关系</p><p>(4)图状结构：数据元素之间是多对多的关系。</p><p><strong>物理结构包括顺序存储结构和链式存储结构。</strong></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的存储结构有：顺序、链接、索引等存储结构</span><br></pre></td></tr></table></div></figure>        <h3 id="解释一下顺序存储与链式存储"   >          <a href="#解释一下顺序存储与链式存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#解释一下顺序存储与链式存储" class="headerlink" title="解释一下顺序存储与链式存储"></a>解释一下顺序存储与链式存储</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >顺序存储结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是用一段连续的存储空间来存储数据元素，可以进行随机访问，访问效率较高。链式存储结构是用任意的存储空间来存储数据元素，不可以进行随机访问，访问效率较低。 </p>        <h3 id="头指针和头结点的区别？"   >          <a href="#头指针和头结点的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#头指针和头结点的区别？" class="headerlink" title="头指针和头结点的区别？"></a>头指针和头结点的区别？</h3>      <p>头指针：是指向第一个节点存储位置的指针，具有标识作用，头指针是链表的必要元素，无论链表是否为空，头指针都存在。</p><p>头结点：是放在第一个元素节点之前，便于在第一个元素节点之前进行插入和删除的操作，头结点不是链表的必须元素，可有可无，头结点的数据域也可以不存储任何信息。</p>        <h3 id="数组和链表的区别？"   >          <a href="#数组和链表的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组和链表的区别？" class="headerlink" title="数组和链表的区别？"></a>数组和链表的区别？</h3>      <p>从逻辑结构来看：数组的存储长度是固定的，它不能适应数据动态增减的情况。链表能够动态分配存储空间以适应数据动态增减的情况，并且易于进行插入和删除操作。</p><p>从访问方式来看：数组在内存中是一片连续的存储空间，可以通过数组下标对数组进行随机访问，访问效率较高。链表是链式<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >存储结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，存储空间不是必须连续的，可以是任意的，访问必须从前往后依次进行，访问效率较数组来说比较低。</p><p>如果从第i个位置插入多个元素，对于数组来说每一次插入都需要往后移动元素，每一次的时间复杂度都是O(n)，而单链表来说只需要在第一次寻找i的位置时时间复杂度为O(n)，其余的插入和删除操作时间复杂度均为O(1)，提高了插入和删除的效率。</p>        <h3 id="栈和队列的区别"   >          <a href="#栈和队列的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h3>      <p>队列是允许在一段进行插入另一端进行删除的线性表，对于进入队列的元素按“先进先出”的规则处理，在表头进行删除在表尾进行插入。</p><p>栈是只能在表尾进行插入和删除操作的线性表。对于插入到栈的元素按“后进先出”的规则处理，插入和删除操作都在栈顶进行。由于进栈和出栈都是在栈顶进行，所以要有一个size变量来记录当前栈的大小，当进栈时size不能超过数组长度，size+1，出栈时栈不为空，size-1。</p>        <h3 id="栈和堆的区别，以及为什么栈要快"   >          <a href="#栈和堆的区别，以及为什么栈要快" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈和堆的区别，以及为什么栈要快" class="headerlink" title="栈和堆的区别，以及为什么栈要快"></a>栈和堆的区别，以及为什么栈要快</h3>      <ul><li><strong>堆和栈的区别</strong>：1、堆是由低地址向高地址扩展；栈是由高地址向低地址扩展 2、堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存 3、堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片 4、堆的分配效率较低，而栈的分配效率较高</li><li><strong>栈的效率高的原因：</strong> 栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C&#x2F;C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</li></ul>        <h3 id="介绍一下字符串匹配算法KMP算法"   >          <a href="#介绍一下字符串匹配算法KMP算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下字符串匹配算法KMP算法" class="headerlink" title="介绍一下字符串匹配算法KMP算法"></a>介绍一下字符串匹配算法KMP算法</h3>      <p>首先计算nextval</p><p>①上下子串前缀匹配</p><p>②找到公共前后缀（取最长且小于比较的上下字串长度）</p><p>③将下面的p子串前缀移动到后缀位置</p>        <h3 id="介绍下prim算法和Kruskal算法"   >          <a href="#介绍下prim算法和Kruskal算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下prim算法和Kruskal算法" class="headerlink" title="介绍下prim算法和Kruskal算法"></a>介绍下prim算法和Kruskal算法</h3>      <p>目的是得到最小生成树</p><p><strong>普里姆(prim)算法的基本思想为：顶点集到其他点权值最小边，加入新的顶点集，再找边…直到遍历所有点</strong> </p><p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。 </p><p>1.在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code> </p><p>2.任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>. </p><p>3.重复以下操作，直到所有点都被标记为<code>visit</code>： </p><p><strong>克鲁斯卡尔(kruskal)算法的基本思想为：依次选择最小边，使得无环且所有点遍历结束</strong> </p><p>Kruskal是另一个计算最小生成树的算法，其算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。 </p>        <h3 id="介绍下拓扑排序算法"   >          <a href="#介绍下拓扑排序算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下拓扑排序算法" class="headerlink" title="介绍下拓扑排序算法"></a>介绍下拓扑排序算法</h3>      <p>每次都应当从入度为0的结点开始遍历。因为只有入度为0的结点才能够成为拓扑排序的起点。否则根据拓扑排序的定义，只要一个结点<code>v</code>的入度不为0，则至少有一条边起始于其他结点而指向<code>v</code>，那么这条边的起点在拓扑排序的顺序中应当位于<code>v</code>之前，则<code>v</code>不能成为当前遍历的起点。 </p><p> 拓扑排序可以用深度优先遍历或广度优先遍历算法来实现。 </p>        <h3 id="关键路径如何确定？"   >          <a href="#关键路径如何确定？" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键路径如何确定？" class="headerlink" title="关键路径如何确定？"></a>关键路径如何确定？</h3>      <p>关键路径的特征是：从起点 (起点是唯一的，入度为0) 到终点 (终点是唯一的，出度为0) 的一个有向图中，该路径上的弧 (有向图的边称之为“弧”) 的权重的和最大。 </p><p>1.我们需要计算每个节点的earlyTime (最早开始时间)。终点的earlyTime 就是从起点到终点的最大权重和。 </p><p>2.如果我们从终点到起点，进行反向的计算lastTime (最晚开始时间)，如果某一条路径的每一个结点的earlyTime 与lastTime都相等，那么这条路径就是关键路径。 </p>        <h3 id="介绍散列表处理冲突的几种方法"   >          <a href="#介绍散列表处理冲突的几种方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍散列表处理冲突的几种方法" class="headerlink" title="介绍散列表处理冲突的几种方法"></a>介绍散列表处理冲突的几种方法</h3>      <p><strong>开放地址法：</strong>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020" >散列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。   包括线性探测法、二次探测法、随机探测法</p><p><strong>再散列函数法：</strong></p><blockquote><p><strong>fi ( key ) &#x3D; RHi ( key ) (i&#x3D;1,2,…,k)</strong></p></blockquote><p>RHi 就是不同的散列函数，可以将前面说<span class="exturl"><a class="exturl__link"   href="https://editor.csdn.net/md/?articleId=104356727" >散列表查找及其函数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的除留余数、折叠、平方取中全部用上。每当出现散列地址冲突，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，但是相应地会增加计算的时间。</p><p><strong>链地址法</strong>：将所有关键字为同义词的记录存储在一个单链表中，我们称之为同义词子表，在<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97%E8%A1%A8&spm=1001.2101.3001.7020" >散列表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中只存储所有同义词子表的头指针。 </p><p><strong>公共溢出区法</strong>：当发生冲突的时候，凡是冲突的跟我走，给这些冲突找个地儿呆着。我们为所有冲突的关键字建立一个公共的溢出区来存放。 </p>        <h3 id="排序算法知道哪些，哪个是最快的，为什么？"   >          <a href="#排序算法知道哪些，哪个是最快的，为什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序算法知道哪些，哪个是最快的，为什么？" class="headerlink" title="排序算法知道哪些，哪个是最快的，为什么？"></a><strong>排序算法知道哪些，哪个是最快的，为什么？</strong></h3>      <p>插入排序：简单插入、折半插入排序、希尔排序</p><p>交换排序：冒泡排序、快速排序</p><p>选择排序：</p><p>归并排序：</p><p>外部排序：</p>        <h3 id="介绍一下B-树"   >          <a href="#介绍一下B-树" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下B-树" class="headerlink" title="介绍一下B+树"></a>介绍一下B+树</h3>      <p>b+树是一种树状数据结构，一般用在数据库和操作系统的文件管理中。</p><p>特点是支持顺序存储，能够保证数据稳定有序，是b树的一种变体。</p><p>1）B+树只在叶节点存放记录，其他结点只起到索引作用；B树在所有结点中保存记录</p><p>2）B+树的叶节点支持顺序查找，B树不支持</p><p>3）B+树n个结点对应n个分叉；B树n个结点对应n+1个分叉</p>        <h3 id="AVL树和红黑树的区别？"   >          <a href="#AVL树和红黑树的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#AVL树和红黑树的区别？" class="headerlink" title="AVL树和红黑树的区别？"></a>AVL树和红黑树的区别？</h3>      <p>红黑树平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，红黑树的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。</p><p>在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于红黑树只追求大致平衡，因此红黑树至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(logn) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除红黑树更加合适。</p>        <h3 id="如何在无序数组中查找第k小的值"   >          <a href="#如何在无序数组中查找第k小的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何在无序数组中查找第k小的值" class="headerlink" title="如何在无序数组中查找第k小的值"></a>如何在无序数组中查找第k小的值</h3>      <p>1.首先进行排序  然后找出下标为k-1的数，时间复杂度为O(n*logn)</p><p>2.建立大小为k的大顶堆，遍历数据如果大于大顶堆的顶那么先pop然后push该值，时间复杂度为O(n*logk)</p><p>3.基于快排找基准的方法，首先建立一个类似快排的函数，然后返回值为基准对应的下标，调用该函数，如果返回值刚好等于k-1则返回答案，如果大于k-1则递归左半部分数组，否则递归右半部分数组，时间复杂度为O(n)</p><p><strong>追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</strong></p><p>当有相同元素的时候， 首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)。 </p>        <h3 id="海量数据如何去取最大的k个"   >          <a href="#海量数据如何去取最大的k个" class="heading-link"><i class="fas fa-link"></i></a><a href="#海量数据如何去取最大的k个" class="headerlink" title="海量数据如何去取最大的k个"></a>海量数据如何去取最大的k个</h3>      <p><strong>1.直接全部排序（只适用于内存够的情况）</strong> 当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。 这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出topK个数据，所以该方法并不十分高效，不建议使用。</p><p><strong>2.快速排序的变形 （只使用于内存够的情况）</strong> 这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。 这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index&gt;K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回TopK个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p><p><strong>3.最小堆法 这是一种局部淘汰法。</strong> 先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p><p><strong>4.分治法</strong> 将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p><p><strong>5.Hash法</strong> 如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>        <h3 id="哪些图算法用到了动态规划思想"   >          <a href="#哪些图算法用到了动态规划思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#哪些图算法用到了动态规划思想" class="headerlink" title="哪些图算法用到了动态规划思想"></a>哪些图算法用到了动态规划思想</h3>      <p>floyd算法</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int k = 1; k &lt;= n; k ++)</span><br><span class="line">    for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">        for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">             d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br></pre></td></tr></table></div></figure>        <h3 id="判断链表是否有环"   >          <a href="#判断链表是否有环" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>      <p>使用双指针法，一个慢指针每次往后走一个单位，一个快指针每次往后走两个长度，如果在慢指针遍历完成之前没有相遇，则没有环，如果相遇了那么证明有环。</p><p>如果要找到成环的开头，可以让一个指针从开头开始走，每次往后一个单位，当它与慢指针相遇时得到便是那个开头。</p>        <h3 id="介绍一下深度优先搜索和广度优先搜索是如何实现的？"   >          <a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？" class="headerlink" title="介绍一下深度优先搜索和广度优先搜索是如何实现的？"></a>介绍一下深度优先搜索和广度优先搜索是如何实现的？</h3>      <p>深度优先搜索：(1)访问起始点v0(2)若v0的第一个邻接点没有被访问过，则深度遍历该邻接点；(3)若v0的第一个邻接点已经被访问，则访问其第二个邻接点，进行深度遍历；重复以上步骤直到所有节点都被访问过为止</p><p>广度优先搜索：(1)访问起始点v0(2)依次遍历v0的所有未访问过得邻接点 (3)再依次访问下一层中未被访问过得邻接点；重复以上步骤，直到所有的顶点都被访问过为止</p>        <h3 id="哈希表的概念、构造方法、冲突的解决办法？"   >          <a href="#哈希表的概念、构造方法、冲突的解决办法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希表的概念、构造方法、冲突的解决办法？" class="headerlink" title="哈希表的概念、构造方法、冲突的解决办法？"></a>哈希表的概念、构造方法、冲突的解决办法？</h3>      <p>哈希表又称为散列表，是根据关键字码的值直接进行访问的数据结构，即它通过把关键码的值映射到表中的一个位置以加快查找速度，其中映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>哈希函数的构造方法包括：直接定址法，除留余数法，数字分析法，平方取中法，折叠法，随机数法</p><p>(1)直接定址法：取关键字的某个线性函数值作为散列地址，H(key)&#x3D;a*key+b。</p><p>(2)除留余数法：取关键字对p取余的值作为散列地址，其中p</p><p>(3)数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列的地址，适用于所有关键字都已知的情况。</p><p>(4)平方取中法：对关键字求平方，再取结果中的中间几位作为散列地址。</p><p>(5)折叠法：将关键字分为位数相同的几部分，然后取这几部分的叠加和作为散列地址。适用于关键字位数较多，且关键字中每一位上数字分布大致均匀。</p><p>(6)随机数法：选择一个随机函数，把关键字的随机函数值作为散列地址。适合于关键字的长度不相同时。</p><p>哈希冲突的解决方法包括：开放定址法和拉链法，当冲突发生时，使用某种探测技术形成一个探测序列，然后沿此序列逐个单单元查找，直到找到该关键字或者碰到一个开放的地址为止，探测到开放的地址表明该表中没有此关键字，若要插入，则探测到开放地址时可将新节点插入该地址单元。其中开放定址法包括：线性探查法，二次探查法，双重散列法</p><p>(1)线性探查法：基本思想，探查时从地址d开始，首先探查T[d],在探查T[d+1]…直到查到T[m-1]，此后循环到T[0],T[1]…直到探测到T[d-1]为止。</p><p>(2)二次探查法：基本思想，探查时从地址d开始，首先探查T[d],再探查T[d+12],T[d+22]…等，直到探查到有空余地址或者探查到T[d-1]为止，缺点是无法探查到整个散列空间。</p><p>(3)双重散列法：基本思想，使用两个散列函数来确定地址，探查时从地址d开始，首先探查T[d],再探查T[d+h1(d)],T[d+2*h1(d)]…</p><p>链接法：将所有关键字为同义词的节点链接在同一个单链表中，若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组，凡是散列地址为i的节点均插入到头指针为i的单链表中。</p>        <h3 id="各种排序算法"   >          <a href="#各种排序算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种排序算法" class="headerlink" title="各种排序算法"></a>各种排序算法</h3>      <p>内部排序包括：插入排序、选择排序、交换排序、归并排序、基数排序。其中插入排序包括：直接插入排序、折半插入排序、希尔排序；选择排序包括：简单选择排序，堆排序；交换排序包括：冒泡排序、快速排序。</p><p>(1)直接插入排序(稳定)：基本思想为：将序列分为有序部分和无序部分，从无序部分依次选择元素与有序部分比较找到合适的位置，将原来的元素往后移，将元素插入到相应位置上。时间复杂度为：O(n^2),空间复杂度为O(1)</p><p>(2)折半插入排序(稳定)：基本思想为：设置三个变量low high mid，令mid&#x3D;(low+high)&#x2F;2,若a[mid]&gt;key,则令high&#x3D;mid-1,否则令low&#x3D;mid+1,直到low&gt;high时停止循环，对序列中的每个元素做以上处理，找到合适位置将其他元素后移进行插入。比较次数为O(nlog2n),但是因为要后移，因此时间复杂度为O(n^2),空间复杂度为O(1)。 优点是：比较次数大大减少。</p><p>(3)希尔排序(不稳定)：基本思想为：先将序列分为若干个子序列，对各子序列进行直接插入排序，等到序列基本有序时再对整个序列进行一次直接插入排序。优点是：让关键字值小的元素能够很快移动到前面，且序列基本有序时进行直接插入排序时间效率会提升很多，空间复杂度为O(1)。</p><p>(4)简单选择排序(不稳定)：基本思想为：将序列分为2部分，每经过一趟就在无序部分找到一个最小值然后与无序部分的第一个元素交换位置。优点是：实现简单，缺点是：每一趟只能确定一个元素的位置，时间效率低。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><p>(5)堆排序(不稳定)：设有一个任意序列，k1,k2,…,kn，当满足下面特点时称之为堆：让此序列排列成完全二叉树，该树具有以下特点，该树中任意节点均大于或小于其左右孩子，此树的根节点为最大值或者最小值。优点是：对大文件效率明显提高，但对小文件效率不明显。时间复杂度为O(nlog2n),空间复杂度为O(1)。</p><p>(6)冒泡排序(稳定)：基本思路为：每一趟都将元素进行两两比较，并且按照“前小后大”的规则进行交换。优点是：每一趟不仅能找到一个最大的元素放到序列后面，而且还把其他元素理顺，如果下一趟排序没有发生交换则可以提前结束排序。时间复杂度为O(n^2),空间复杂度为O(1)。</p><p>(7)快速排序(不稳定)：基本思路为：在序列中任意选择一个元素作为中心，比它大的元素一律向后移动，比它小的元素一律向前移动，形成左右两个子序列，再把子序列按上述操作进行调整，直到所有的子序列中都只有一个元素时序列即为有序。优点是：每一趟不仅能确定一个元素，时间效率较高。时间复杂度为O(nlog2n),空间复杂度为O(log2n).</p><p>(8)归并排序(稳定)：基本思想为：把两个或者两个以上的有序表合并成一个新的有序表。时间复杂度为O(nlogn),空间复杂度和待排序的元素个数相同。</p><p>(9)基数排序：时间复杂度为：对于n个记录进行链式基数排序的时间复杂度为O(d(n+rd)),其中每一趟分配的时间复杂度为O(n),回收的时间复杂度为O(rd)。</p><p>“前小后大”的规则进行交换。优点是：每一趟不仅能找到一个最大的元素放到序列后面，而且还把其他元素理顺，如果下一趟排序没有发生交换则可以提前结束排序。时间复杂度为O(n^2),空间复杂度为O(1)。</p><p>(7)快速排序(不稳定)：基本思路为：在序列中任意选择一个元素作为中心，比它大的元素一律向后移动，比它小的元素一律向前移动，形成左右两个子序列，再把子序列按上述操作进行调整，直到所有的子序列中都只有一个元素时序列即为有序。优点是：每一趟不仅能确定一个元素，时间效率较高。时间复杂度为O(nlog2n),空间复杂度为O(log2n).</p><p>(8)归并排序(稳定)：基本思想为：把两个或者两个以上的有序表合并成一个新的有序表。时间复杂度为O(nlogn),空间复杂度和待排序的元素个数相同。</p><p>(9)基数排序：时间复杂度为：对于n个记录进行链式基数排序的时间复杂度为O(d(n+rd)),其中每一趟分配的时间复杂度为O(n),回收的时间复杂度为O(rd)。</p>        <h3 id="贪心算法和动态规划以及分治法的区别"   >          <a href="#贪心算法和动态规划以及分治法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法和动态规划以及分治法的区别" class="headerlink" title="贪心算法和动态规划以及分治法的区别"></a>贪心算法和动态规划以及分治法的区别</h3>      <p>贪心算法：局部最优，划分的每个子问题都最优，得到全局最优，但是不能保证是全局最优解，所以对于贪心算法来说，解是从上到下的，一步一步最优，直到最后。</p><p>动态规划：将问题分解成重复的子问题，每次都寻找左右子问题解中最优的解，一步步得到全局的最优解.重复的子问题可以通过记录的方式，避免多次计算。所以对于动态规划来说，解是从小到上，从底层所有可能性中找到最优解，再一步步向上。</p><p>分治法：和动态规划类似，将大问题分解成小问题，但是这些小问题是独立的，没有重复的问题。独立问题取得解，再合并成大问题的解。</p>        <h3 id="用循环比递归的效率高吗？"   >          <a href="#用循环比递归的效率高吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#用循环比递归的效率高吗？" class="headerlink" title="用循环比递归的效率高吗？"></a><strong>用循环比递归的效率高吗？</strong></h3>      <p>循环和递归两者是可以互换的，不能决定性的说循环的效率比递归高。</p><p><strong>递归</strong></p><p>【优点】：代码简洁清晰，容易检查正确性；</p><p>【缺点】：当递归调用的次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，对执行效率有一定的影响。</p><p><strong>循环</strong></p><p>【优点】：结构简单，速度快；</p><p>【缺点】：它并不能解决全部问题，有的问题适合于用递归来解决不适合用循环。</p>        <h3 id="如何区分循环队列是队空还是队满？"   >          <a href="#如何区分循环队列是队空还是队满？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何区分循环队列是队空还是队满？" class="headerlink" title="如何区分循环队列是队空还是队满？"></a><strong>如何区分循环队列是队空还是队满？</strong></h3>      <p><strong>普通情况</strong>下，</p><p><strong>循环队列</strong>队空和队满的判定条件是一样的，都是<strong>Q.front &#x3D;&#x3D; Q.rear。</strong></p><p><em>ps:队头指针指向第一个数；队尾指针指向最后一个数的下一个位置，即将要入队的位置。</em></p><blockquote><p>方法一：<strong>牺牲一个单元</strong>来区分队空和队满，这个时候**(Q.rear+1)%MaxSize &#x3D;&#x3D; Q.front**才是队满标志 。</p></blockquote><blockquote><p>方法二：类型中<strong>增设表示元素个数的数据成员</strong>。这样，队空的条件为Q.size &#x3D;&#x3D; 0;队满的条件为Q.size &#x3D;&#x3D; MaxSize。</p></blockquote>        <h3 id="快排存在的问题，如何优化"   >          <a href="#快排存在的问题，如何优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#快排存在的问题，如何优化" class="headerlink" title="快排存在的问题，如何优化"></a>快排存在的问题，如何优化</h3>      <p>时间复杂度最快平均是O（nlogn）,最慢的时候是O(n2); </p><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序 原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排 </p><p>优化2：随机选取分割位置； 当分割位置不理想时，考虑是否重新选取分割位置； </p><p>优化3：优化递归操作 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化</p>        <h3 id="队列在计算机系统中的应用？"   >          <a href="#队列在计算机系统中的应用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列在计算机系统中的应用？" class="headerlink" title="队列在计算机系统中的应用？"></a><strong>队列在计算机系统中的应用？</strong></h3>      <p>队列在计算机系统中的应用非常广泛，以下仅从两个方面来简述队列在计算机系统中的作用：</p><p>第一个方面是解决<strong>主机与外部设备之间速度不匹配</strong>的问题</p><p>第二个方面是解决由<strong>多用户引起的资源竞争</strong>问题。</p><blockquote><p>（对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的 数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。</p><p>对于第二个方面， CPU (即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型 的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU 各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU 的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU 分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU 分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU 能够正常运行。）</p></blockquote>        <h3 id="矩阵的压缩存储"   >          <a href="#矩阵的压缩存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a><strong>矩阵的压缩存储</strong></h3>      <p>数据结构中，提供针对某些<strong>特殊矩阵</strong>的压缩存储结构。这里所说的特殊矩阵，主要分为以下两类：</p><ul><li>含有大量<strong>相同数据元素</strong>的矩阵，比如对称矩阵；</li><li>含有<strong>大量 0 元素的矩阵</strong>，比如稀疏矩阵、上（下）三角矩阵；</li></ul><p>针对以上两类矩阵，数据结构的<strong>压缩存储思想</strong>是：矩阵中的<strong>相同数据元素（包括元素 0）只存储一个</strong>。</p>        <h3 id="线索二叉树的概念？"   >          <a href="#线索二叉树的概念？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线索二叉树的概念？" class="headerlink" title="线索二叉树的概念？"></a><strong>线索二叉树的概念？</strong></h3>      <p>对于<strong>n个结点</strong>的二叉树，在二叉链存储结构中有<strong>n+1个空链域</strong>，利用这些空链域存放在某种遍历次序下该结点的<strong>前驱结点和后继结点</strong>的指针，这些指针称为<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>。</p><p>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为<strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种。</p><p><strong>注意：</strong>线索链表解决了<strong>无法直接找到该结点在某种遍历序列中的前驱和后继结点</strong>的问题，解决了二叉链表找左、右孩子困难的问题。</p>        <h3 id="树的存储结构？"   >          <a href="#树的存储结构？" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的存储结构？" class="headerlink" title="树的存储结构？"></a><strong>树的存储结构？</strong></h3>      <p><strong>双亲表示法</strong></p><p>这种存储方式采用<strong>一组连续空间</strong>来存储每个结点，同时在每个结点中增设一个<strong>伪指针</strong>，指示其<strong>双亲结点在数组中的位置</strong>。</p><p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iY2Y1ZjhlNi02ODhmLTRhZmUtOTQxYS03NjQzMjhkNDNjNjAucG5n?x-oss-process=image/format,png" style=""  alt="img"></p><p>该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。</p><p><strong>孩子表示法</strong></p><p>孩子表示法是将<strong>每个结点</strong>的<strong>孩子结点</strong>都用<strong>单链表</strong>链接起来形成一个线性结构，此时n 个结点就有n 个孩子链表（叶子结点的孩子链表为空表）</p><p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83ZDQzNDA3NC1hOGRiLTQwYTYtOWI0Yy04NGFjYWNjYzQ5YTcucG5n?x-oss-process=image/format,png" style=""  alt="img"></p><p>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。</p><p><strong>孩子兄弟表示法</strong></p><p>孩子兄弟表示法又称<strong>二叉树表示法</strong>，即以<strong>二叉链表</strong>作为树的存储结构。孩子兄弟表示法使<strong>每个结点</strong>包括三部分内容：<strong>结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针</strong>（沿此域可以找到结点的所有兄弟结点）</p><p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83OTU0NmU3Zi0wZDdiLTRmYmQtOGQyMi00ZDg1ZDUwMzFiY2IucG5n?x-oss-process=image/format,png" style=""  alt="img"></p><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现<strong>树转换为二叉树</strong>的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。</p>        <h3 id="什么是哈夫曼编码"   >          <a href="#什么是哈夫曼编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是<strong>哈夫曼编码</strong></h3>      <p>在数据通信中，若对每个字符用<strong>相等长度的二进制位</strong>表示，称这种编码方式为<strong>固定长度编码</strong>。 若允许对不同字符用<strong>不等长的二进制位</strong>表示，则这种编码方式称为<strong>可变长度编码</strong>。</p><p><strong>可变长度编码</strong>比固定长度编码要好得多，其<strong>特点</strong>是对<strong>频率高</strong>的字符赋以<strong>短编码</strong>，而对<strong>频率较低</strong>的字符则赋以<strong>较长一些的编码</strong>，从而可以使字符的平均编码长度减短，起到<strong>压缩数据</strong>的效果。</p><p>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。若<strong>没有一个编码是另一个编码的前缀</strong>，则称这样的编码为<strong>前缀编码</strong>。</p><p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为<strong>从根至该字符的路径上边标记的序列</strong>，其中<strong>边标记****为0</strong> 表示“转向<strong>左孩子</strong>”，<strong>标记为1</strong> 表示“转向<strong>右孩子</strong>“ </p>        <h3 id="图的存储结构"   >          <a href="#图的存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h3>      <p><strong>邻接矩阵法</strong></p><p>所谓邻接矩阵存储，是指用一个<strong>一维数组</strong>存储图中<strong>顶点的信息</strong>用一个<strong>二维数组</strong>存储图中<strong>边的信息</strong>（即各顶点之间的邻接关系），存储<strong>顶点之间邻接关系</strong>的二维数组称为<strong>邻接矩阵</strong>。</p><p>适合<strong>稠密图</strong>。</p><p><strong>邻接表法</strong></p><p>当一个图为<strong>稀疏图</strong>时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了<strong>顺序存储</strong>和<strong>链式存储</strong>方法，大大减少了这种不必要的浪费。</p><p>所谓<strong>邻接表</strong>，是指对图G 中的每个<strong>顶点V建立一个单链表</strong>，第i个单链表中的结点表示依附于顶点v, 的边（对于有向图则是以顶点v, 为尾的弧），这个单链表就称为顶点vi 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：<strong>顶点表结点</strong>和<strong>边表结点</strong>。 </p><p><strong>十字链表法</strong></p><p>十字链表法是<strong>有向图</strong>的一种<strong>链式存储结构</strong>。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p><p><strong>邻接多重表</strong></p><p>邻接多重表是<strong>无向图</strong>的另一种<strong>链式</strong>存储结构。 在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示。</p><p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80MWVkYTg1NS01ZjkyLTQxODEtODdmYi0zZjUyN2ExYThlMDQucG5n?x-oss-process=image/format,png" style=""  alt="img"></p>        <h3 id="海量数据问题"   >          <a href="#海量数据问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#海量数据问题" class="headerlink" title="海量数据问题"></a>海量数据问题</h3>      <p>目前关于海量数据想到的解决办法： 1.bitmap 2.桶排序，外部排序，将需要排序的放到外存上，不用全部放到内存上 </p>        <h3 id="反转链表"   >          <a href="#反转链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void translateLinklist(Linklist&amp; L) //三指针法实现链表的反转</span><br><span class="line">&#123;</span><br><span class="line">Linklist pre;// 记录之前的结点</span><br><span class="line">Linklist cur;// 记录当前的结点</span><br><span class="line">Linklist r;// 记录剩下的结点</span><br><span class="line"></span><br><span class="line">pre = NULL; //要先pre指针置为空</span><br><span class="line">cur = L-&gt;next;   //指向第一个结点</span><br><span class="line">while (cur)</span><br><span class="line">&#123;</span><br><span class="line">r = cur-&gt;next;  //这样r不会成为野指针,且这一步一定要在最前面。即当cur不为空的时候才指向下一个</span><br><span class="line">cur-&gt;next = pre; //转方向</span><br><span class="line">pre = cur;      //往后移</span><br><span class="line">cur = r;</span><br><span class="line">&#125;</span><br><span class="line">//结束后cur为空，所以L-&gt;next要指向pre;</span><br><span class="line">L-&gt;next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="两个栈实现队列"   >          <a href="#两个栈实现队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h3>      <p>①输入的时候先让B都进A，然后输入到A中</p><p>②输出的时候A都进到B，然后B输出栈顶</p>        <h3 id="两个队列实现栈"   >          <a href="#两个队列实现栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3>      <p>①输入的时候直接输入到队列中</p><p>②输出的时候A往B走，当A只有一个时输出，然后B再进回A</p><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;算法的基本特征&quot;   &gt;
          &lt;a href=&quot;#算法的基本特征&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#算法的基本特征&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之日常提问</title>
    <link href="http://example.com/2022/10/05/%E6%97%A5%E5%B8%B8/"/>
    <id>http://example.com/2022/10/05/%E6%97%A5%E5%B8%B8/</id>
    <published>2022-10-05T12:52:25.208Z</published>
    <updated>2022-10-05T13:00:01.931Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="有什么兴趣爱好"   >          <a href="#有什么兴趣爱好" class="heading-link"><i class="fas fa-link"></i></a><a href="#有什么兴趣爱好" class="headerlink" title="有什么兴趣爱好"></a>有什么兴趣爱好</h3>              <h3 id="遇到过什么挫折-怎么解决"   >          <a href="#遇到过什么挫折-怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到过什么挫折-怎么解决" class="headerlink" title="遇到过什么挫折?怎么解决?"></a>遇到过什么挫折?怎么解决?</h3>              <h3 id="你认为机器学习方法和数学建模方法有什么不同吗？"   >          <a href="#你认为机器学习方法和数学建模方法有什么不同吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你认为机器学习方法和数学建模方法有什么不同吗？" class="headerlink" title="你认为机器学习方法和数学建模方法有什么不同吗？"></a>你认为机器学习方法和数学建模方法有什么不同吗？</h3>              <h3 id="房价预测用的什么模型"   >          <a href="#房价预测用的什么模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#房价预测用的什么模型" class="headerlink" title="房价预测用的什么模型"></a>房价预测用的什么模型</h3>              <h3 id="你参加过什么社会实践活动"   >          <a href="#你参加过什么社会实践活动" class="heading-link"><i class="fas fa-link"></i></a><a href="#你参加过什么社会实践活动" class="headerlink" title="你参加过什么社会实践活动?"></a>你参加过什么社会实践活动?</h3>      ]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;有什么兴趣爱好&quot;   &gt;
          &lt;a href=&quot;#有什么兴趣爱好&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#有什么兴趣爱好&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之密码学</title>
    <link href="http://example.com/2022/10/05/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>http://example.com/2022/10/05/%E5%AF%86%E7%A0%81%E5%AD%A6/</id>
    <published>2022-10-05T12:52:25.204Z</published>
    <updated>2022-10-05T13:02:21.992Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="DES加密算法"   >          <a href="#DES加密算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2>      <p>分组加密算法，对称加密算法</p><p>以64bit的单位称为分组</p><p>DES的基本结构是Feistel网络</p><p>在Feistel网络中，加密的各个步骤称为<strong>轮</strong>（round），整个加密过程就是进行若干次轮的循环。</p><ul><li>加密：将64 6464bit的数据分为两部分，每部分32 3232bit，分别对应“左侧”和“右侧”。重复多轮，两轮之间左右对调。</li><li>解密：使用与加密时相反的子密钥。 </li><li>子密钥：每一轮都需要使用一个不同的密钥，因为它只是一个局部密钥，所以称为<strong>子密钥</strong>（subkey）。</li><li>轮函数：根据“右侧”和子密钥生成对“左侧”进行加密的比特序列。</li></ul><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轮数可以任意增加。</span><br><span class="line">加密时使用任何函数作为轮函数都可以正确解密，即使该函数不存在反函数。</span><br><span class="line">加密和解密可以用完全相同的结构来实现。</span><br></pre></td></tr></table></div></figure>        <h2 id="三重DES"   >          <a href="#三重DES" class="heading-link"><i class="fas fa-link"></i></a><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h2>      <p>由于现在DES已经可以在短时间内被暴力破解，所以三重DES出于这个目的被开发出来了。<strong>三重DES</strong>（triple-DES，3DES）是将DES重复3次得到的一种密码算法。</p><ul><li>加密：使用3个DES密钥，进行DES加密-&gt;<strong>解密</strong>-&gt;加密的过程。</li><li>解密：与加密过程相反。 </li><li>特点<ul><li>向下兼容：当密钥1 11、2 22、3 33相同时，三重DES就等同于普通的DES。</li><li>处理速度慢，除了特别重视向下兼容的情况以外，很少被用于新用途。</li></ul></li></ul>        <h2 id="ECB模式"   >          <a href="#ECB模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h2>      <p><strong>ECB模式</strong>（Electronic CodeBook）非常简单，但由于存在弱点因此通常不会被使用。ECB将明文分组加密后的结果直接变成密文分组：<br><img   src="https://img-blog.csdnimg.cn/cb94014aca3440c0a63fc09a8f0cc174.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="ECB模式"></p><ul><li>当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行<strong>填充</strong>（padding）。</li><li>特点<ul><li>由于明文分组与密文分组一一对应，因此根据密文就知道明文中存在怎样的重复组合，可以以此为线索来破译密码。</li><li>由于每个明文分组都独立地加密解密，所以密文分组的顺序改变会导致相应的明文分组的顺序改变，因此<strong>攻击者Mallory无需破译密码就能操纵明文</strong>。</li></ul></li></ul>        <h2 id="CBC模式"   >          <a href="#CBC模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2>      <p><strong>CBC模式</strong>（Cipher Block Chaining）将前一个密文分组与当前明文分组进行异或运算，然后再进行加密，这样可以避免ECB模式的弱点：<br><img   src="https://img-blog.csdnimg.cn/083cc694756e481faec10e6d5a510eea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="CBC模式"></p><ul><li>由于第一个明文分组不存在“前一个密文分组”，因此通常需要随机产生一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为<strong>初始化向量</strong>（Initialization Vector），通常缩写为<strong>IV</strong>。</li><li>特点<ul><li>由于明文分组在加密前会与“前一个密文分组“进行异或运算，因此即便明文分组1 11和2 22的值是相等的，密文分组1 11和2 22的值也不一定是相等的。</li><li>假设CBC模式的密文分组中有一个密文分组<strong>损坏</strong>（分组的长度不变，值变）了，此时解密时最多只有2 22个分组收到影响（即损坏的分组和损坏分组的下一个分组）。</li><li>假设CBC模式的密文分组中有一些比特<strong>缺失</strong>（分组的长度改变）了，那么缺失比特之后的密文分组就无法解密了。</li><li>当初始化向量被篡改时，CBC模式的第一个明文分组会受到影响。使用消息认证码可以判断数据是否被篡改。</li></ul></li></ul><p><img   src="https://img-blog.csdnimg.cn/de9ed933916047c99f2e9e5527155820.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="img"> </p>        <h2 id="解决密钥配送问题的方法"   >          <a href="#解决密钥配送问题的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决密钥配送问题的方法" class="headerlink" title="解决密钥配送问题的方法"></a>解决密钥配送问题的方法</h2>      <p>公钥密码无法解决的问题：</p><ul><li>会受到中间人攻击。</li><li>处理速度慢，只有对成密码的几百分之一。</li></ul>        <h2 id="RSA算法"   >          <a href="#RSA算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">取两个大质数p、q；</span><br><span class="line"></span><br><span class="line">计算公共模数n=p*q；</span><br><span class="line"></span><br><span class="line">计算n的欧拉函数f(n)=(p-1)*(q-1);</span><br><span class="line"></span><br><span class="line">任取公钥e大于1小于f(n)且与f(n)互质；</span><br><span class="line"></span><br><span class="line">根据ed mod f(n) =1算出私钥d；</span><br><span class="line"></span><br><span class="line">公钥（e，n) C=M^e mod n；</span><br><span class="line"></span><br><span class="line">私钥（d，n) M=C^d mod n；</span><br><span class="line"></span><br><span class="line">RSA大于等于124bit比较安全。</span><br></pre></td></tr></table></div></figure>        <h2 id="对称加密算法与非对称加密算法区别与优缺点"   >          <a href="#对称加密算法与非对称加密算法区别与优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#对称加密算法与非对称加密算法区别与优缺点" class="headerlink" title="对称加密算法与非对称加密算法区别与优缺点"></a>对称加密算法与非对称加密算法区别与优缺点</h2>      <p>对称加密与非对称加密的主要区别在于密钥的个数。</p><p>对称加密，双方用相同密钥，加密速度快、高效、适用于大量数据的加密场景 ，但是无法解决密钥管理、无法确认消息来源。</p><p>非对称加密，公钥私钥，能提供身份验证、数字签名，但是加密速度慢、算法复杂。</p>        <h2 id="HASH算法和SHA-1算法？"   >          <a href="#HASH算法和SHA-1算法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HASH算法和SHA-1算法？" class="headerlink" title="HASH算法和SHA-1算法？"></a>HASH算法和SHA-1算法？</h2>      <p>hash算法就是一个散列函数对于输入的变长信息产生一个定长的散列码。</p><p>即已知c好求散列值，但由散列值不好求c。</p><p><strong>SHA-1 secure hash algorithm 安全哈希算法</strong></p><p>MD-5                                                              输出128bit</p><p>SHA-1报文最长2^ 64           80轮运算            输出160 bit</p><p>SHA-256                                                        输出256 bit</p><p>SHA-512                                                        输出512 bit</p>        <h2 id="分组加密算法与序列加密算法区别"   >          <a href="#分组加密算法与序列加密算法区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#分组加密算法与序列加密算法区别" class="headerlink" title="分组加密算法与序列加密算法区别"></a>分组加密算法与序列加密算法区别</h2>      <p>分组加密每次处理特定长度的快数据，输出定长密文。扩散性好，插入敏感，但处理速度慢。</p><p>序列加密&#x2F;流加密对数据流进行连续处理，明密文长度相同。速度快，低错误传播 但扩散性差，插入不敏感。</p>        <h2 id="加密攻击有哪些工作模式-x2F-威胁模型？"   >          <a href="#加密攻击有哪些工作模式-x2F-威胁模型？" class="heading-link"><i class="fas fa-link"></i></a><a href="#加密攻击有哪些工作模式-x2F-威胁模型？" class="headerlink" title="加密攻击有哪些工作模式&#x2F;威胁模型？"></a>加密攻击有哪些工作模式&#x2F;威胁模型？</h2>      <p>唯密文攻击        只知道密文或密文的一部分 ，可通过统计学方法破密。</p><p>已知明文攻击      同一密钥的几个明-密文对</p><p>选择明文攻击      攻击者可选明文获得密文</p><p>选择密文攻击      攻击者可选密文获得明文</p>        <h2 id="AES-x2F-DES加密"   >          <a href="#AES-x2F-DES加密" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES-x2F-DES加密" class="headerlink" title="AES&#x2F;DES加密"></a>AES&#x2F;DES加密</h2>      <p>DES data encryption standard 对称密码 分组密码&#x2F;块加密</p><p> IP置换 16轮迭代 IP逆置换    64bit&#x2F;块   密钥64bit</p><p>每64位</p><p>先进行IP置换，64位分成左右两个32位部分</p><p>在密钥的参与下进行16轮迭代，48E扩展、与密钥异或、32S压缩等</p><p>16轮后，左右两部分交换并连接，再进行逆置换。</p><p><img   src="https://img-blog.csdnimg.cn/1d46a37329cd4c86bb68a1a90d05ed04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"><img   src="https://img-blog.csdnimg.cn/c2de879ef1604343a70e2e1b40aed41b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"></p><p> AES advanced encryption standard 对称密码 分组密码&#x2F;块加密</p><p> AES      128bit&#x2F;块  密钥每多64位多两轮   128-10  192-12  256-14</p><p>先进行一次明文与子密钥矩阵异或初始变换，</p><p>再进行 9轮运算，具体是字节代换，行列变换、轮密钥加密等，</p><p>最后进行一次最终轮变换（无列变换）。</p><p><img   src="https://img-blog.csdnimg.cn/98aa5c31fc2e49949c286b343c2a2175.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"></p>        <h2 id="数字签名"   >          <a href="#数字签名" class="heading-link"><i class="fas fa-link"></i></a><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2>      <p>主要是防止抵赖、认证、防篡改的技术，一般先hash处理。</p><p>私钥加密 公钥解密</p>        <h2 id="密码学攻击"   >          <a href="#密码学攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#密码学攻击" class="headerlink" title="密码学攻击"></a>密码学攻击</h2>      <p><strong>主动攻击</strong></p><p>在主动攻击中，攻击者尝试修改信息。 由于修改，由于可见性，可以容易地检测到这种攻击。比如重放、篡改等。</p><p><strong>被动攻击</strong></p><p>在被动攻击中，攻击者尝试获取信息而不修改信息。 因此，这些类型的攻击很难进行攻击，因为在数据中看不到任何干预迹象。比如窃听等。</p>        <h2 id="密码学安全性"   >          <a href="#密码学安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#密码学安全性" class="headerlink" title="密码学安全性"></a><strong>密码学安全性</strong></h2>      <p>密码学中的安全性可以分为两种：理论安全性与计算安全性。</p><p>理论安全性：当攻击者拥有无限时间和资源还是不能破译密码时，称其为理论安全，也叫做无条件安全。</p><p>计算安全性：如果一个密码算法在给定时间和资源内无法被攻破，则称其为计算安全的。</p><p><strong>评估某密码算法的安全性，我们一般会通过数学证明得到。</strong></p><p>在密码学中其被称为可证明安全性，它可以证明某个密码方案至少和解决另一个已知的困难问题是同等困难的，只要困难问题仍然存在，那么方案就是安全的，这种证明方式被称为规约，其来自复杂性理论。</p>        <h2 id="MAC消息认证码-message-authentication-code"   >          <a href="#MAC消息认证码-message-authentication-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#MAC消息认证码-message-authentication-code" class="headerlink" title="MAC消息认证码 message authentication code"></a>MAC消息认证码 message authentication code</h2>      <p>是一种确认完整性并进行认证的技术。</p><p>通过消息认证码可以确认自己收到的消息是否就是发送者的本意，也就是说可以判断消息是否被篡改，是否有人伪装成发送者发送了这条消息。</p><p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享密钥。输出固定长度的数据，输出的数据就是 MAC 值。</p><p>消息认证码是一种与密钥相关联的单向散列函数。</p><p>单向散列函数保证消息的一致性，完整性，没有被篡改。</p><p>消息认证码保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装。</p><p>数字签名保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装，并且能防止抵赖。</p>        <h2 id="重放攻击"   >          <a href="#重放攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h2>      <p>窃听者不直接破解消息认证码，而是把它保存起来，反复利用，这种攻击就叫做重放攻击(replay attack)。</p><p>防止重放攻击的3种方法：</p><ol><li>加入序列号</li><li>加入时间戳</li><li>加入随机数</li></ol>        <h2 id="生日攻击"   >          <a href="#生日攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2>      <p>生日攻击不是真实的一个攻击，而是一种概率的结果。生日攻击是以概率论中的生日问题为数据基础的一种密码学攻击方法。</p><p>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。对于60人以上，这种概率要大于99%。70人为99%，严格意义上，这并不是一个悖论，称之为悖论是由于跟人们的常识相悖。</p><p>所以由生日悖论结论可以看出来：<strong>产生哈希冲突所需的输入样本数量，远低于所有可能哈希值的全集数量。</strong></p>        <h2 id="信息熵"   >          <a href="#信息熵" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2>      <p>香农在信息论中提出了信息熵的概念 </p><p>熵是表示随机变量不确定性的度量</p><p>从直观上，信息熵越大，变量包含的信息量越大，变量的不确定性也越大。</p>        <h2 id="什么是哈希碰撞"   >          <a href="#什么是哈希碰撞" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是哈希碰撞" class="headerlink" title="什么是哈希碰撞"></a>什么是哈希碰撞</h2>      <p>两个不同的输入，经过哈希算法后，得到了同样的哈希值，就叫做哈希碰撞。</p><p>产生原因：</p><p>一个空间较大的集合(输入)通过哈希算法映射到一个空间较小的集合(哈希值)，必然会造成多个输入映射到一个哈希值上。</p><p>避免方法：</p><p>避免哈希碰撞的主要手段是，根据输入集合的数量级，<strong>选取输出合适哈希值长度的哈希函数</strong>，将哈希碰撞的概率降为“几乎不可能”</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;DES加密算法&quot;   &gt;
          &lt;a href=&quot;#DES加密算法&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#DES加密算法&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之离散数学</title>
    <link href="http://example.com/2022/10/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2022/10/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</id>
    <published>2022-10-05T12:52:25.200Z</published>
    <updated>2022-10-05T13:00:45.929Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="关键词："   >          <a href="#关键词：" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3>      <ul><li><input disabled="" type="checkbox"> 命题、主析取范式、主合取范式、极小项、极大项</li><li><input disabled="" type="checkbox"> 个体词、谓词、量词 </li><li><input disabled="" type="checkbox"> P规则、T规则、CP规则</li><li><input disabled="" type="checkbox"> 辖域、自由变元、约束变元</li><li><input disabled="" type="checkbox"> 环和、环积，幂集，补集，对称差集，笛卡尔乘积，文氏图</li><li><input disabled="" type="checkbox"> 关系的定义域、值域、域、逆、合成、限制和像 </li><li><input disabled="" type="checkbox"> 自反、对称、传递、偏序关系 </li><li><input disabled="" type="checkbox"> 闭包、自反闭包、对称闭包、传递闭包</li><li><input disabled="" type="checkbox"> 覆盖、划分、等价关系、等价类</li><li><input disabled="" type="checkbox"> <span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E5%93%88%E6%96%AF%E5%9B%BE&spm=1001.2101.3001.7020" >哈斯图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、上下界、偏序</li><li><input disabled="" type="checkbox"> 幺元、零元、逆元</li><li><input disabled="" type="checkbox"> 代数、半群、独异点、群、阿贝尔群、循环独异点、生成元</li><li><input disabled="" type="checkbox"> 简单图、平凡图、多重图、线图、子图、补图、出度、入度、同构</li><li><input disabled="" type="checkbox"> 出度、入度、度、同构、子图、真子图、生成子图、有向完全图、无向完全图、补图</li><li><input disabled="" type="checkbox"> 连通图、单向连通图、弱连通图、强连通图、基图、连通分图、点连通度、边连通度</li><li><input disabled="" type="checkbox"> 基本路径、基本回路、简单路径、简单回路</li><li><input disabled="" type="checkbox"> 欧拉路径、欧拉回路、欧拉图、哈密顿路径、哈密顿回路、哈密顿图、哈密尔顿图、欧拉公式</li><li><input disabled="" type="checkbox"> 树、无向树、平凡树、森林、连通分支、树叶、分支点、生成树、树枝、弦、余树、Kruskal</li></ul>        <h3 id="主析取范式和主合取范式"   >          <a href="#主析取范式和主合取范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h3>      <p>极小项是若命题变元或其否定的合取∧；</p><p>极大项是若命题变元或其否定的析取∨； </p><p><img src="C:\Users\86150\AppData\Local\Temp\1656988084687.png" alt="1656988084687"></p>        <h3 id="推理规则"   >          <a href="#推理规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3>      <p>P规则：就是直接利用推理中给出的前提，即前提引入。</p><p>T规则：就是由某一个或几个前提可以通过等价、蕴含得到其他命题公式，即推理规则。 </p><p>I表示在T规则中通过蕴含式推出其他命题公式，即推理规则中的蕴含推理。</p><p>E表示在T规则中通过等价式推出其他命题公式，即推理规则中的置换规则。 </p><p>CP(Conditional Proof)规则，若证明AB→C, B可作为附加前提引入。通俗点说，就是咱在做证明题时，看到待证结论是B→C这样的，把B当作前提来用，这就是CP规则。 </p>        <h3 id="代数、半群、独异点、群、阿贝尔群之间的关系"   >          <a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="headerlink" title="代数、半群、独异点、群、阿贝尔群之间的关系"></a>代数、半群、独异点、群、阿贝尔群之间的关系</h3>      <p><img src="C:\Users\86150\AppData\Local\Temp\1657009248374.png" alt="1657009248374"></p>        <h3 id="欧拉图和哈密顿图"   >          <a href="#欧拉图和哈密顿图" class="heading-link"><i class="fas fa-link"></i></a><a href="#欧拉图和哈密顿图" class="headerlink" title="欧拉图和哈密顿图"></a>欧拉图和哈密顿图</h3>      <p>欧拉回路：若存在一条从起点S出发的路径，每条边恰好只走一次，最终回到起点S的路径被称为欧拉路径。</p><p>欧拉通路：若存在一条从起点S出发的路径，经过每条边一次，但是不要求回到起点S的路径被称作欧拉通路。</p><p>哈密顿路径：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级路径</p><p>哈密顿回路：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级回路</p><p>哈密顿图：具有哈密顿回路的无向图</p><p>欧拉公式：n-m+k&#x3D;2</p>        <h3 id="离散数学讲了什么"   >          <a href="#离散数学讲了什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#离散数学讲了什么" class="headerlink" title="离散数学讲了什么"></a>离散数学讲了什么</h3>      <p>数理逻辑，二元关系，群与环，数论什么的，是一门比较抽象的学科，主要作用是建立相关的数学模型，把实际问题抽象成为计算机能够理解的逻辑结构，并且用计算机的思维去解决实际问题，往往实际用的不多，主要是训练思维。</p>        <h3 id="什么是完全图？"   >          <a href="#什么是完全图？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是完全图？" class="headerlink" title="什么是完全图？"></a>什么是完全图？</h3>      <p>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图<br>在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图</p>        <h3 id="什么是群？"   >          <a href="#什么是群？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是群？" class="headerlink" title="什么是群？"></a>什么是群？</h3>      <p>代数系统封闭性 结合律 他就是 半群 含有单位元 就是含幺半群 有逆元就是 群</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;关键词：&quot;   &gt;
          &lt;a href=&quot;#关键词：&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#关键词：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之计算机网络</title>
    <link href="http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/"/>
    <id>http://example.com/2022/10/05/%E8%AE%A1%E7%BD%91/</id>
    <published>2022-10-05T12:52:25.197Z</published>
    <updated>2022-10-05T13:01:25.166Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>        <h3 id="TCP-x2F-IP-网络模型有哪几层？"   >          <a href="#TCP-x2F-IP-网络模型有哪几层？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h3>      <p>4层：应用层、传输层、网络层、网络套接层</p>        <h3 id="流量控制和拥塞控制有什么区别？"   >          <a href="#流量控制和拥塞控制有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制和拥塞控制有什么区别？" class="headerlink" title="流量控制和拥塞控制有什么区别？"></a>流量控制和拥塞控制有什么区别？</h3>      <p>流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的；</p><p>拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。 </p>        <h3 id="https和http相比有什么区别"   >          <a href="#https和http相比有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#https和http相比有什么区别" class="headerlink" title="https和http相比有什么区别"></a>https和http相比有什么区别</h3>      <ol><li>建立连接时候：https 比 http多了 TLS 的握手过程；</li><li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li></ol>        <h3 id="TCP-和-UDP-区别："   >          <a href="#TCP-和-UDP-区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-和-UDP-区别：" class="headerlink" title="TCP 和 UDP 区别："></a><strong>TCP 和 UDP 区别：</strong></h3>      <p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。慢开始、拥塞避免、快重传、快恢复 </li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul>        <h3 id="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"   >          <a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="headerlink" title="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"></a><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></h3>      <ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul>        <h3 id="不使用「两次握手」和「四次握手」的原因："   >          <a href="#不使用「两次握手」和「四次握手」的原因：" class="heading-link"><i class="fas fa-link"></i></a><a href="#不使用「两次握手」和「四次握手」的原因：" class="headerlink" title="不使用「两次握手」和「四次握手」的原因："></a>不使用「两次握手」和「四次握手」的原因：</h3>      <p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。 </p><p>（1）三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p><p>（2）三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul>        <h3 id="为什么需要-TIME-WAIT-状态"   >          <a href="#为什么需要-TIME-WAIT-状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h3>      <p>TIME_WAIT 状态持续 2MSL（最大报文存活时间），约4分钟才转换成CLOSE状态。由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接，TIME_WAIT 的主要作用有：</p><p>（1）重发丢失的 ACK 报文，保证连接可靠的关闭：</p><blockquote><p>由于网络等原因，无法保证最后一次挥手的 ACK 报文一定能传送给对方，如果 ACK 丢失，对方会超时重传 FIN，主动关闭端会再次响应ACK过去；如果没有 TIME_WAIT 状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。同时，服务器就因为接收不到客户端的信息而无法正常关闭。</p></blockquote><p>（2）保证本次连接的重复数据段从网络中消失：</p><blockquote><p>如果存在两个连接，第一个连接正常关闭，第二个相同的连接紧接着建立；如果第一个连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达，则会干扰第二连接，等待 2MSL 可以让上次连接的报文数据消逝在网络中。</p></blockquote>        <h3 id="为什么需要四次挥手"   >          <a href="#为什么需要四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3>      <p>TCP 是全双工模式，并且支持半关闭特性，提供了连接的一端在结束发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>        <h3 id="什么是拆包粘包："   >          <a href="#什么是拆包粘包：" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是拆包粘包：" class="headerlink" title="什么是拆包粘包："></a><strong>什么是拆包粘包：</strong></h3>      <p>拆包粘包在数据链路层、网络层以及传输层都可能存在。而在传输层中，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。 </p>        <h3 id="网络层-IP数据报分片："   >          <a href="#网络层-IP数据报分片：" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层-IP数据报分片：" class="headerlink" title="网络层 - IP数据报分片："></a><strong>网络层 - IP数据报分片：</strong></h3>      <p>​ MTU 是数据链路层中的网络对数据帧的一个限制（以太网中 MTU 为1500个字节），一个 IP 数据报在以太网中传输，如果它的长度大于 MTU 值，就要进行分片传输，使得每片数据报的长度小于 MTU。而分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装，IP数据报的分片与重组是在网络层进完成的。</p><p>​        前面提到，MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 在建立连接时通常会协商双方的 MSS 值（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（IP 数据包包头的大小 20 Bytes 和 TCP 数据段的包头 20 Bytes），TCP报文段的分段与重组是在传输层完成的。</p><blockquote><p>如果用链路层以太网，MSS的值往往为1460。而 Internet 上标准的 MTU（最小的 MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。</p></blockquote><p>​        到这里我们就能看出，TCP 分段的原因是 MSS，IP 分片的原因是 MTU，由于一直有 MSS &lt;&#x3D; MTU，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了，因此TCP报文段很少会发生IP分片的情况。</p><p>​        而由于 UDP 数据报不会自己进行分段，因此当长度超过了 MTU 时，会在网络层进行 IP 分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p><p>​        所以，总的来说，UDP 不会分段，就由 IP 来分，TCP会分段，当然就不用 IP 来分了！</p>        <h3 id="IPv4和IPv6首部的差异"   >          <a href="#IPv4和IPv6首部的差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4和IPv6首部的差异" class="headerlink" title="IPv4和IPv6首部的差异"></a>IPv4和IPv6首部的差异</h3>      <p>IPv6 相比 IPv4 的首部改进：</p><ul><li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li></ul>        <h3 id="TCP-如何保证可靠性传输："   >          <a href="#TCP-如何保证可靠性传输：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-如何保证可靠性传输：" class="headerlink" title="TCP 如何保证可靠性传输："></a>TCP 如何保证可靠性传输：</h3>      <ul><li>（1）三次握手</li><li>（2）应答机制与超时重传：TCP接收端收到发送端的数据时，它将发送一个确认。当TCP发送端发出一个报文段后，它会启动一个定时器，等待接收端的确认报文段，如果不能及时收到一个确认，将重发这个报文段。</li><li>（3）数据包校验与丢弃重复数据：TCP会检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP会超时重发数据；对于重复数据，则进行丢弃；</li><li>（4）对失序数据包进行重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>（5）流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li><li>（6）拥塞控制：网络拥塞时，减少数据的发送。</li></ul>        <h3 id="交换机和路由器的区别"   >          <a href="#交换机和路由器的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3>      <p>（1）工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层；</p><p>（2）寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址；</p><p>（3）转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</p><p>（4）交换机用于连接局域网，路由器用于连接外网和局域网</p>        <h3 id="集线器和交换机的区别"   >          <a href="#集线器和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器和交换机的区别" class="headerlink" title="集线器和交换机的区别"></a><strong>集线器和交换机的区别</strong></h3>      <p>集线器和交换机都是工作在TCP&#x2F;IP协议的最后一层，数据链路（物理层），都是连接多个设备形成局域网的。<br>集线器会把接收到的数据包每次都广播给局域网局域网的所有计算机，而交换机只有首次在MAC地址表找不到记录才广播，其他时候是直接单独发送给对应MAC地址的计算机。交换机可以说是集线器的升级改良版，在集线器的基础上多了MAC地址表，可以分割冲突域，更加智能化。</p><p>集线器的数据传输方式是广播方式，而交换机的数据传输是有目的的，数据只对目的节点发送，只是在自己的MAC地址表中找不到的情况下第一次使用广播方式发送，然后因为交换机具有MAC地址学习功能，第二次以后就不再是广播发送了，又是有目的的发送。这样的好处是数据传输效率提高，不会出现广播风暴，在安全性方面也不会出现其它节点侦听的现象</p>        <h3 id="网桥和交换机的区别"   >          <a href="#网桥和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#网桥和交换机的区别" class="headerlink" title="网桥和交换机的区别"></a><strong>网桥和交换机的区别</strong></h3>      <ul><li>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个输出输入端口，而交换机具有高密度的端口。所以一般的交换机，网桥就有桥接作用。</li><li>网桥主要由软件实现，交换机主要由硬件实现</li></ul><p>网桥也可以理解成只有两个端口的交换机，交换机可以理解成由多个网桥组成的 </p>        <h3 id="介绍一下TCP的拥塞控制："   >          <a href="#介绍一下TCP的拥塞控制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下TCP的拥塞控制：" class="headerlink" title="介绍一下TCP的拥塞控制："></a>介绍一下<strong>TCP的拥塞控制：</strong></h3>      <p>拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。 </p><p><strong>（1）慢开始算法：</strong>当发送主机开始发送数据时，不要一开始就发送大量的数据，因为不清楚网络的拥塞情况，而是试探一下网络的拥塞情况，由小到大逐渐增大发送窗口。</p><p><strong>（2）拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p><strong>（3）快重传：</strong>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不必等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><strong>（4）快恢复：</strong>与快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减少”算法，把ssthresh门限设置为拥塞窗口cwnd的一半，但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法：因为如果网络出现拥塞的话，就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以此时并不执行慢开始算法，而是执行拥塞避免算法。</p>        <h3 id="拥塞控制和流量控制的差别："   >          <a href="#拥塞控制和流量控制的差别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制和流量控制的差别：" class="headerlink" title="拥塞控制和流量控制的差别："></a>拥塞控制和流量控制的差别：</h3>      <p>（1）相同点：拥塞控制和流量控制的相同点都是控制丢包现象，实现机制都是让发送方发得慢一点。</p><p>（2）不同点：</p><p>① 拥塞控制是一个全局性的过程，防止过多的数据注入到网络中，造成网络拥塞</p><p>② 流量控制指点对点通信量的控制，要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p><p>如何判断多个数据包是属于同一个信息？以及他们的先后次序？</p><p>为什么网络传输中会出现丢包？</p>        <h3 id="Ip协议中用来分片和重组的依据"   >          <a href="#Ip协议中用来分片和重组的依据" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ip协议中用来分片和重组的依据" class="headerlink" title="Ip协议中用来分片和重组的依据"></a>Ip协议中用来分片和重组的依据</h3>      <p>标志：根据DF来判断是否可以进行分片</p><p>标识：根据标识来判断原始报文和分片报文的关系</p><p>偏移量：收集所有的分片</p><p><img   src="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p><p>一个表示网段地址、一个表示广播地址</p><p>网络号是<span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的第一个地址，<span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80" >广播地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E7%BD%91%E6%AE%B5&spm=1001.2101.3001.7020" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的最后一个地址，这两个地址是不能配置在计算机<span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" >主机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的。 </p>        <h3 id="DHCP协议"   >          <a href="#DHCP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名称：动态主机配置协议</span><br><span class="line">作用：当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址</span><br><span class="line">协议：基于UDP</span><br><span class="line">工作方式：客户/服务段模式C/S模式</span><br><span class="line">端口号：服务器在67号  客户端在68号</span><br><span class="line">过程：DHCPDISCOVER-&gt;DHCPOFFER-&gt;DHCPREQUEST-&gt;DHCPACK</span><br><span class="line">协议层：网络层</span><br></pre></td></tr></table></div></figure>        <h3 id="ARP协议"   >          <a href="#ARP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">名称：地址解析协议</span><br><span class="line">作用：根据IP地址获取物理地址的一个TCP/IP协议</span><br><span class="line">协议层：网络层</span><br><span class="line">过程：</span><br><span class="line">A已知B的IP地址，需要获得B的MAC地址（物理地址）</span><br><span class="line">    如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取</span><br><span class="line">    如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组</span><br><span class="line">    在局域网上的所有节点都可以接收到ARP query</span><br><span class="line">    B接收到ARP query分组后，将自己的MAC地址发送给A</span><br><span class="line">    A在ARP表中缓存B的IP地址和MAC地址的映射关系</span><br><span class="line">    超时时删除</span><br></pre></td></tr></table></div></figure>        <h3 id="ICMP协议"   >          <a href="#ICMP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：互联网控制报文协议</span><br><span class="line">作用：ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</span><br><span class="line">ICMP 报文携带在IP 数据报中： IP上层协议号为1</span><br><span class="line">类型：差错报告报文、询问报文</span><br></pre></td></tr></table></div></figure>        <h3 id="路由选择协议RIP"   >          <a href="#路由选择协议RIP" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议RIP" class="headerlink" title="路由选择协议RIP"></a>路由选择协议RIP</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于：距离矢量算法</span><br><span class="line">衡量标准：跳数、即距离近</span><br><span class="line">基本思想：①只与邻居路由器交换信息②交换的是整个路由表</span><br><span class="line">特点：算法简单、收敛慢</span><br><span class="line">适用场景：中小网络</span><br></pre></td></tr></table></div></figure>        <h3 id="BGP-外部网关路由协议"   >          <a href="#BGP-外部网关路由协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#BGP-外部网关路由协议" class="headerlink" title="BGP-外部网关路由协议"></a>BGP-外部网关路由协议</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对于：内部网关路由协议IGP：比如RIP、OSPF等</span><br><span class="line">适用于：不同的自治域间的路由协议</span><br><span class="line">交换信息：路径通告</span><br><span class="line">基于：TCP连接用于交换BGP报文</span><br><span class="line">两类报文：eBGP用于相邻的AS，iBGP用于AS内的全部路由器（即内部）</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="路由器中三种典型的交换结构"   >          <a href="#路由器中三种典型的交换结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器中三种典型的交换结构" class="headerlink" title="路由器中三种典型的交换结构"></a>路由器中三种典型的交换结构</h3>      <p>共享内、共享总线、纵横式 crossbar</p><p><img   src="https://img-blog.csdnimg.cn/20210701184819348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>        <h3 id="远程登录Telnet"   >          <a href="#远程登录Telnet" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程登录Telnet" class="headerlink" title="远程登录Telnet"></a>远程登录Telnet</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用：定义客户进程与远程服务器进程之间的交互过程</span><br><span class="line">基于：TCP协议</span><br><span class="line">协议层：应用层协议</span><br><span class="line">传输数据格式：NVT网络虚拟终端（定义的一组通用字符集）</span><br><span class="line">工作过程：①建立TCP连接 </span><br><span class="line">②将本地终端上输入的用户名和口令及以后输入的任何命令或字符以网络虚拟终端NVT格式传输给远程主机</span><br><span class="line">③将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果</span><br><span class="line">④本地终端对远程主机撤销连接，从而结束 Telnet远程登录过程</span><br></pre></td></tr></table></div></figure>        <h3 id="文件传输协议FTP"   >          <a href="#文件传输协议FTP" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a><strong>文件传输协议FTP</strong></h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限</span><br><span class="line">实现方式：C/S模式</span><br><span class="line">协议层：应用层协议</span><br><span class="line">基于：TCP协议（21号端口）</span><br><span class="line">两个端口与两个连接：21号端口用于控制连接  20号端口用于数据连接</span><br></pre></td></tr></table></div></figure>        <h3 id="传输层是干嘛的？"   >          <a href="#传输层是干嘛的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层是干嘛的？" class="headerlink" title="传输层是干嘛的？"></a>传输层是干嘛的？</h3>      <p>为主机的进程之间提供通信，是两个主机通信中第一个端对端的层次，具有缓冲作用。由于一个主机有多个进程，因此传输层具有分用复用的功能。传输层在终端用户中进行透明的数据传输，向上层提供可靠的数据传输服务。当网络层服务质量不能满足要求时（比如无法保证可靠传输）它可以将服务质量提高到达需要的要求。通过流量控制、分段&#x2F;重组、差错控制来保证数据传输的可靠性。</p><p>在传输层上又两个经常用到的协议：TCP和UDP，TCP可以保证可靠传输协议，它是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手来建立连接，四次挥手来中断连接。它具有拥塞控制和流量控制机制。UDP是尽最大努力交付的协议，比较的简单，没有那么多机制，对于那些数据质量要求不高但是时效性要求高的应用经常使用。</p>        <h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"   >          <a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3>      <p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p><p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>        <h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"   >          <a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3>      <p>主要原因有三：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p>当历史连接由于网络拥塞导致其在客户端重新请求之后，新请求达到之前先一步到达客户端，那么客户端发送的ACK便是历史的连接请求，此时客户端发现后便需要RST中断连接，但此时服务端已经是established因此会发送数据造成浪费，主要原因是两次握手「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</p><p>除此之外通过三次握手才能约定客户端和服务段双方的初始化序列号，如果两次的话只能确定客户端的初始化序列号。</p><p>如果是两次握手，当网络拥挤时由于SYN报文的丢失，会导致服务端手段多个重复的SYN，由于经过了一段时间的传输因此可能会造成多余连接的建立，造成资源浪费。</p><p>每次都是接收到数据包的一方可以得到对方的状态，发送的一方其实没有任何头绪。因此至少需要三次握手才能使得双方都确定对方已经完成发送数据的准备。</p>        <h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"   >          <a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3>      <p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p><p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>        <h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"   >          <a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3>      <p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。 </p>        <h3 id="说下网络中的主机通信流程"   >          <a href="#说下网络中的主机通信流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下网络中的主机通信流程" class="headerlink" title="说下网络中的主机通信流程"></a>说下网络中的主机通信流程</h3>      <p>主机A和主机B在同一个二层网络中，直接走二层交换</p><p>主机A和主机B不在同一个网络中，走三层路由</p>        <h3 id="介绍一下Socket"   >          <a href="#介绍一下Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Socket" class="headerlink" title="介绍一下Socket"></a>介绍一下Socket</h3>      <p>Socket是一组编程接口（API）。介于传输层和应用层，向应用层提供统一的编程接口。应用层不必了解TCP&#x2F;IP协议细节。直接通过对Socket接口函数的调用完成数据在IP网络的传输。</p><p>套接字&#x3D;IP地址+网络协议+端口号</p>        <h3 id="HTTP和HTTPS"   >          <a href="#HTTP和HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3>      <p>他们都是应用层协议</p><p>HTTP协议是超文本传输协议，最初的目的是为了提供一种发布和接收HTML页面的方法</p><p>HTTPS是HTTP协议的安全版本，将其传输过程中的数据使用SSL&#x2F;TLS进行了加密，并且他是需要申请证书的</p><p>他们使用的端口号不同，HTTP为80端口，HTTPS为443端口</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立</span><br><span class="line">（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息</span><br><span class="line">（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</span><br><span class="line">（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</span><br><span class="line">（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</span><br></pre></td></tr></table></div></figure>        <h3 id="CSMA-x2F-CD协议"   >          <a href="#CSMA-x2F-CD协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3>      <p>载波监听多点接入&#x2F;碰撞检测协议  三大特点</p><p>1.多点接入：作用在总线型网络中，许多计算机以多点接入的方式连接在同一个总线上</p><p>2.载波监听：每个站在发送数据前都会先检测总线上是否有其他站在发送数据，如果有则先等待</p><p>3.碰撞检测：边发送边监听，通过监听电压值的变化来判断是否和其他站发送进行了冲突，一段时间后无冲突则不再检测，如果发送冲突则停止发送数据，等待一段空闲时间后再次发送。</p><p>碰撞不可能完全避免，CSMA&#x2F;CD只能减少碰撞。</p>        <h3 id="如何扩充局域网？"   >          <a href="#如何扩充局域网？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何扩充局域网？" class="headerlink" title="如何扩充局域网？"></a>如何扩充局域网？</h3>      <p>在物理层：通过集线器将多个计算机进行互联</p><p>链路层：通过交换机来进行扩展，相当于多接口的网桥</p><p>网络层：通过虚拟局域网VLAN</p>        <h3 id="私有地址的范围"   >          <a href="#私有地址的范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#私有地址的范围" class="headerlink" title="私有地址的范围"></a>私有地址的范围</h3>      <p>A类：10.0.0.0-10.255.255.255</p><p>B类：172.16.0.0-172.31.255.255</p><p>C类：192.168.0.0-192.168.255.255</p><p>D类地址(224~239)：以1110开头，保留位多播地址。</p><p>E类地址(240~255)：以1111开头，保留位今后使用</p>        <h3 id="介绍一下虚电路"   >          <a href="#介绍一下虚电路" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下虚电路" class="headerlink" title="介绍一下虚电路"></a>介绍一下虚电路</h3>      <p>虚电路是分组交换的两种传输方式中的一种，另一种是电路交换</p><p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p><p>提前定义好一条路径，可以改进性能，并且消除了帧和分组对头的需求，从而增加了吞吐率</p>        <h3 id="电路交换、报文交换、分组交换"   >          <a href="#电路交换、报文交换、分组交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3>      <p>电路交换：在使用电路交换进行通话之前，必须先拨号建立一条连接，也就是一条专用的物理通路，这条通路在通话中只允许通话的两个用户使用，而不允许其他人使用。</p><p>优点：实现简单</p><p>缺点：建立大型网络时资源利用率不高，当用户比较多时，可能会出现通路短缺的情况。</p><p>报文交换：报文是通信链路中一次要发送的数据，报文交换就是把整个报文完整的发送到链路中，在某个节点存储下来之后再发送到下一个节点。</p><p>优点：相比电路交换，来说更加灵活。不需要事先建立连接之后再进行通信。</p><p>缺点：当每个报文的数据量较大时，每次在节点处转发再存储的话时延较大。</p><p>分组交换：分组交换采用转发存储技术，将一个完整的报文，分成若干个分组，再进行转发，而且每个分组之间经过哪一个节点，与上一个分组完全没有关系，这一点在某些网络节点发生网络阻塞时会显得尤其重要。</p><p>优点：发送数据更加灵活，时延更下。</p><p>缺点：发送设备和接收设备就更加复杂。</p>        <h3 id="什么是SYN洪泛"   >          <a href="#什么是SYN洪泛" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SYN洪泛" class="headerlink" title="什么是SYN洪泛"></a>什么是SYN洪泛</h3>      <p> SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，耗尽其资源，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p><blockquote><p>半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。</p></blockquote>        <h3 id="cookie-和-session-的区别："   >          <a href="#cookie-和-session-的区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#cookie-和-session-的区别：" class="headerlink" title="cookie 和 session 的区别："></a><strong>cookie 和 session 的区别：</strong></h3>      <p>1）保存位置与安全性：cookie保存在客户端，session保存在服务端，所以在安全性上面，cookie存在安全隐患，可以通过拦截或本地文件找到cookie后进行攻击，而session相对更加安全。因此，可以将登陆信息等重要信息存放为session中；其他信息如果需要保留，可以放在cookie中。</p><p>（2）存储容量：单个cookie最大只允许4KB，一个站点最多保存20个Cookie；session没有大小限制，个数只跟服务器的内存大小有关。</p><p>（3）有效期与实现机制：cookie可长期有效存在；session依赖于cookie，过期时间默认为-1，只需关闭窗口该 session 就会失效。每个客户端对应一个session ，客户端之间的 session  相互独立；</p>        <h3 id="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"   >          <a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="headerlink" title="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"></a>一个完整的http请求是怎么样？即从输入网址到获得页面的过程</h3>      <p>（1）解析url，获取 url 中包含的域名；</p><p>（2）通过DNS系统查询域名对应的IP；</p><p>（3）浏览器得到域名对应的IP地址之后，向服务器发起三次握手请求建立TCP链接；</p><p>（4）TCP链接链接建立起来后，浏览器向服务器发送http请求，如果 html文件在缓存里，浏览器则直接返回， 如果没有，则去后台拿；</p><p>（5）服务器接收到请求后，根据路径参数映射到特定的处理器进行处理，并将处理结果以及相应的视图返回给浏览器。</p><p>（6）浏览器解析视图，并根据请求到的资源、数据进行渲染页面，最终向用户呈现一个完整的页面。</p>        <h3 id="http的长连接和短连接？"   >          <a href="#http的长连接和短连接？" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的长连接和短连接？" class="headerlink" title="http的长连接和短连接？"></a><strong>http的长连接和短连接？</strong></h3>      <p>http的长连接和短连接本质上是TCP长连接和短连接。从http1.1开始就默认使用长连接。</p><p>短链接是指客户端与服务端每进行一次请求操作，就建立一次TCP连接，收到服务器响应后，就断开连接。</p><p>长连接是指客户端和服务建立TCP连接后，它们之间的连接会持续存在，不会因为一次HTTP请求后关闭，后续的请求也是用这个连接进行通信，使用长连接的HTTP协议，会在响应头有加入：Connection:keep-alive。长连接可以省去每次TCP建立和关闭的握手和挥手操作，节约时间提高效率。但在长连接下，客户端一般不会主动关闭连接，如果客户端和服务端之间的连接一直不关闭的话，随着连接数越来越多，会对服务端造成压力。</p><p>所以长连接多用于频繁请求资源，而且连接数不能太多的情况，例如数据库的连接用长连接。而像Web网站这种并发量大，但是每个用户无需频繁操作的场景，一般都使用短连接，因为长连接对服务端来说会耗费一定的资源。</p>        <h3 id="get和-post-请求的区别"   >          <a href="#get和-post-请求的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a><strong>get和 post 请求的区别</strong></h3>      <ul><li>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。</li><li>（2）幂等性：get 是幂等的，post 为非幂等的</li><li>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。</li><li>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。</li><li>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。</li><li>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</li></ul>        <h3 id="Http-常见的状态码"   >          <a href="#Http-常见的状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-常见的状态码" class="headerlink" title="Http 常见的状态码"></a><strong>Http 常见的状态码</strong></h3>      <p>（1）1xx：请求处理中，请求已被接受，正在处理。</p><p>（2）2xx：请求成功，请求被成功处理。</p><p>（3）3xx：重定向，要完成请求必须进一步处理。</p><p>（4）4xx：客户端错误，请求不合法。</p><ul><li>404：未找到请求的资源</li></ul><p>（5）5xx：服务端错误，服务端不能处理合法请求。</p><ul><li>500：服务器内部错误。</li></ul>        <h3 id="DNS-为什么用-UDP"   >          <a href="#DNS-为什么用-UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h3>      <p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>        <h3 id="保活计时器的作用？"   >          <a href="#保活计时器的作用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#保活计时器的作用？" class="headerlink" title="保活计时器的作用？"></a>保活计时器的作用？</h3>      <p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p><p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>        <h3 id="UDP-如何实现可靠传输？"   >          <a href="#UDP-如何实现可靠传输？" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-如何实现可靠传输？" class="headerlink" title="UDP 如何实现可靠传输？"></a>UDP 如何实现可靠传输？</h3>      <p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p><ul><li>1、添加seq&#x2F;ack机制，确保数据发送到对端</li><li>2、添加发送和接收缓冲区，主要是用户超时重传。</li><li>3、添加超时重传机制。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;

        &lt;h3 id=&quot;TCP-x2F-IP-网络模型有哪几层？&quot;   &gt;
          &lt;a href=&quot;#TCP-x2F-IP-网络模型有哪几层？&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之计算机知识</title>
    <link href="http://example.com/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/</id>
    <published>2022-10-05T12:52:25.194Z</published>
    <updated>2022-10-05T13:01:12.447Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="switch为什么比if快？"   >          <a href="#switch为什么比if快？" class="heading-link"><i class="fas fa-link"></i></a><a href="#switch为什么比if快？" class="headerlink" title="switch为什么比if快？"></a>switch为什么比if快？</h3>      <p>switch以空间换时间。<br>1、当分支较多时，当时用switch的效率是很高的。因为switch是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是if…else是遍历所以得可能值，知道找到符合条件的分支。如此看来，switch的效率确实比ifelse要高的多。<br>2、由汇编代码可知道，switch…case占用较多的代码空间，因为它要生成跳表，特别是当case常量分布范围很大但实际有效值又比较少的情况，switch…case的空间利用率将变得很低。<br>3、switch…case只能处理case为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用switch…case来处理的。所以，switch只能是在常量选择分支时比ifelse效率高，但是ifelse能应用于更多的场合，ifelse比较灵活。</p>        <h3 id="并发和并行的区别？"   >          <a href="#并发和并行的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h3>      <p>一、意思不同</p><p>1、并发：并发是指两个或多个事件在同一时间间隔发生。</p><p>2、并行：并行是指两个或者多个事件在同一时刻发生。</p><p>二、侧重不同</p><p>1、并发：并发侧重于在同一实体上。</p><p>2、并行：并行侧重于在不同实体上。</p><p>三、处理不同</p><p>1、并发：并发在一台处理器上“同时”处理多个任务。</p><p>2、并行：并行在多台处理器上同时处理多个任务。</p>        <h3 id="局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？"   >          <a href="#局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？" class="headerlink" title="局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？"></a>局部变量在定义时不初始化则初始值是不确定的，但全局变量初始化为0？</h3>      <p>定义局部变量,其实就是在栈中通过移动栈指针,来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上,而栈内存是反复使用的(脏的,上次用完没清零的) ,所以说使用栈来实现的局部变量定义时如果不初始化,里面的值就是一个垃圾值。由此我们扩展一下,其实不仅仅是局部变量,所有的变量在定义时只是在内存中分配一块空间,并没有对这块空间进行任何的初始化。如果这块内存以前被用过,里面的数据还在,那它对于我们来说是没有任何意义的垃圾值。</p><p>全局变量是定义在堆中的，为静态存储。变量定义的时候,分配了一定的内存单元,在整个程序中,内存单元都不变.只能初始化一次,可以多次赋值,静态存储变量不初始化则初始为0.由堆进行初始化和收回，因此在定义时会默认初始化为0</p>        <h3 id="如何求圆周率？"   >          <a href="#如何求圆周率？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何求圆周率？" class="headerlink" title="如何求圆周率？"></a>如何求圆周率？</h3>      <p>①基于蒙特卡洛来计算，比如构造一个半径为1的圆和它的外切正方形，然后向其中去随机大量的点，计算落在圆中的概率应该是等于π&#x2F;4,当随机量足够多时可以认为这个比例就是概率即可计算。</p><p>②圆周率定义为一个圆形的周长和直径的比值。构造一个圆，然后用一个软绳去算出圆的周长去除于直径即可得到。</p>        <h3 id="多个点拟合使用什么算法？"   >          <a href="#多个点拟合使用什么算法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#多个点拟合使用什么算法？" class="headerlink" title="多个点拟合使用什么算法？"></a>多个点拟合使用什么算法？</h3>      <p>首先通过观察这些点，如果能够发现明显的线性关系，则去尝试使用多元线性回归。比如可以明显的看出他们可以拟合为一条直线，则可以使用最小二乘法去求解最合适的k和b。然后去计算拟合优度$R^2$去判断拟合的效果。</p><p>除此之外也可以针对我们研究的问题去查阅文献，尝试去获取具有科学性的模型，然后将我们的实际问题赋予此去求出相应的参数。</p><p>如果没有其他办法则可以尝试使用神经网络去进行预测，比如在数学建模美赛中我就尝试使用XGboost去针对过去十年的比特币价格进行合理预测，得到的不错的拟合度。</p>        <h3 id="面向过程和面向对象的区别，面向对象的性质？"   >          <a href="#面向过程和面向对象的区别，面向对象的性质？" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向过程和面向对象的区别，面向对象的性质？" class="headerlink" title="面向过程和面向对象的区别，面向对象的性质？"></a>面向过程和面向对象的区别，面向对象的性质？</h3>      <p>区别：①首先他们都是软件开发的思想，先有的面向过程再有的面向对象。面向对象是为了弥补在大型项目中面向过程的不足。②面向过程可以抽象为程序&#x3D;数据结构+算法，但在面向对象的编程中是对象&#x3D;数据结构+算法，程序&#x3D;对象+对象，具有更好的迁移性，控制和复用③编程思想不同，面向过程是专注于涉及功能函数，面向对象编程则是抽象出类、属性、方法等元素，然后进行封装实现④他们都具有封装性，但是面向对象的对象具有多态、继承等特点。</p><p>性质：三大特性</p><p>a)封装：将对象中的属性、方法进行隐藏，仅对外提供公共访问方法，使得外部无法获取其中的实现过程，易于复用同时提高安全性。</p><p>b)继承:使用目前已经定义好的类来作为基础建立新类的技术，在基础类上添加新的数据和函数，是多态的基础。</p><p>c)多态:一个已经定义好的引用变量只有在程序运行时才能确定指向的是哪个类的实例对象，调用的是哪个类的实现方法。</p>        <h3 id="你是怎么理解类和对象的？"   >          <a href="#你是怎么理解类和对象的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你是怎么理解类和对象的？" class="headerlink" title="你是怎么理解类和对象的？"></a>你是怎么理解类和对象的？</h3>      <p>类是一个概念，是一类具有相同特性对象的抽象，是一个模板。代表的是一类事物，当我们遇到多个对象具有相同的特性时我们便可以进行类的抽象。</p><p>对象是类的实例化，是实际存在的个体。</p><p>他们之间的关系就是类时对象的抽象，对象是类的实例化。</p>        <h3 id="介绍一下c-的多态"   >          <a href="#介绍一下c-的多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下c-的多态" class="headerlink" title="介绍一下c++的多态"></a>介绍一下c++的多态</h3>      <p>主要包括两种，静态多态和动态多态。</p><p>静态多态是指在编译的时候实现函数的多个状态，比如通过修改函数的参数数量、参数类型来实现函数重载。这个的实现原理是通过编译器在编译c++函数时函数名会发生变化，包含参数的数量以及类型等信息，依次来区分不同的函数调用。</p><p>静态多态是指在程序运行才确定调用的是哪个函数，是一种动态绑定。比如具有虚函数的基类和实现了虚函数的子类，我们可以通过基类指针来调用子类中的虚函数。实现原理是通过虚函数指针以及虚函数表。当一个有虚函数的类在实例化的时候编译器会为其分配一个指向虚函数表的指针vptr,通过函数指针来调用虚函数时只会根据所指向对象类型来执行相对应的虚函数。</p>        <h3 id="C语言中-局部变量和全局变量都是存储在什么区"   >          <a href="#C语言中-局部变量和全局变量都是存储在什么区" class="heading-link"><i class="fas fa-link"></i></a><a href="#C语言中-局部变量和全局变量都是存储在什么区" class="headerlink" title="C语言中 局部变量和全局变量都是存储在什么区"></a>C语言中 局部变量和全局变量都是存储在什么区</h3>      <p>局部变量是分配在栈中的，也可以手动分配在堆上不过需要记得手动回收。这个局部变量所在的函数被多次调用时，每次调用这个局部变量在栈上的位置都不一定相同 </p><p>全局变量分布在堆上，也就是静态存储器。在程序开始执行时给全局变量分配存储区，程序行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不动态地进行分配和释放； </p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;switch为什么比if快？&quot;   &gt;
          &lt;a href=&quot;#switch为什么比if快？&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#switc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之计算机与网络安全</title>
    <link href="http://example.com/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2022-10-05T12:52:25.190Z</published>
    <updated>2022-10-05T13:01:01.855Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="信息安全的基本属性"   >          <a href="#信息安全的基本属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息安全的基本属性" class="headerlink" title="信息安全的基本属性"></a>信息安全的基本属性</h3>      <ul><li><strong>保密性（Confidentiality）</strong>：保证信息不泄露给未经授权的用户。</li><li><strong>完整性（Integrity）</strong>：保证信息从真实的发信者传送到真实的收信者手中，传送过程中没有被非法用户添加、删除、替换等。</li><li><strong>可用性（Availability）</strong>：保证授权用户能对数据进行及时可靠的访问。</li></ul>        <h3 id="防范缓冲区溢出的手段"   >          <a href="#防范缓冲区溢出的手段" class="heading-link"><i class="fas fa-link"></i></a><a href="#防范缓冲区溢出的手段" class="headerlink" title="防范缓冲区溢出的手段"></a>防范缓冲区溢出的手段</h3>      <p>1.使用更安全的函数，比如scanf_s()、gets_s() </p><p>2.使用更加安全的语言，比如Java等安全的语言编写程序 </p><p>3.改进编译器，它的主要思想是在编译器中增加边界检查以及保护堆栈的功能 </p>        <h3 id="防火墙技术"   >          <a href="#防火墙技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3>      <p>计算机网络中的<strong>边境检查站</strong>，保护内部网络，无法抵御网络中的内部攻击。</p><p>有三种类型：包过滤防火墙、状态监测防火墙、代理服务器防火墙</p><p>包过滤防火墙在网络中的适当位置对数据包按照规则进行过滤，状态监测防火墙是通过检测模块在不影响网络正常工作的前提下，抽取部分数据，即状态信息动态地保存起来作为以后指定安全决策的参考，代理服务器防火墙运行在两个网络之间，从站点取回所需信息再转发给客户。</p><p>防火墙并非单纯的软件或硬件，它实质是软件和硬件加上一组安全策略的集合。 </p>        <h3 id="入侵检测技术"   >          <a href="#入侵检测技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h3>      <p>对周围正在进行的各种活动进行监视以此来判断系统的安全性</p><p>有两种模型：基于主机的IDS和基于网络的IDS</p><p>核心部件都是通信流收集器，分析引擎以及特征数据库</p><p>基于主机的IDS搜集本机的日志文件和其他关键文件，基于网络的IDS搜集的是流经本网段的所有数据包。 分析引擎获得数据之后与特征数据库中的记录进行模式匹配，从而觉得哪些行为是好的，哪些行为是坏的。 </p>        <h3 id="身份认证技术"   >          <a href="#身份认证技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h3>      <p>身份认证技术用来确定用户的合法身份。 </p><p>基于口令认证技术：通过口令来验证用户的合法有效性（账号密码）</p><p>双因素身份认证技术：添加了额外的身份验证令牌，而不仅仅是静态口令 </p><p>数字证书的身份认证技术：通过CA认证机构发放的数字证书来对用户身份进行证明，常用在网络协议</p><p>基于生物特征的身份认证技术：采用独一无二的生物特征来认证用户身份的技术 ，比如指纹识别、虹膜识别、行为识别等。</p>        <h3 id="网络层安全问题"   >          <a href="#网络层安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层安全问题" class="headerlink" title="网络层安全问题"></a>网络层安全问题</h3>      <p>关于<strong>ARP协议</strong>，由于计算机会对收到的每个ARP应答报文作出响应，并更新自己的ARP缓冲表，攻击者利用这个漏洞可以发起中间人攻击，或者用地址冲突使得目标主机不能联网 </p><p>关于<strong>ip协议</strong>，由于ip的源地址不可靠，攻击者可以利用这个漏洞发起盲目飞行攻击以及利用源路由机制发起<strong>中间人攻击</strong>，针对这个漏洞可以采用单播反向验证进行预防。 </p><p>关于<strong>ICMP协议</strong>，利用回送报文可以发起smurf攻击，利用路由重定向报文可以改变主机的路由。 </p><p>介绍下SYN扫描、FIN扫描、idle扫描</p>        <h3 id="传输层的安全问题"   >          <a href="#传输层的安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层的安全问题" class="headerlink" title="传输层的安全问题"></a>传输层的安全问题</h3>      <p><strong>1.SYN泛洪攻击</strong><br>漏洞：服务器端的资源是在第二次握手之后分配的，客户端资源是在第三次握手之后分配的。攻击者发送大量第一次握手的数据包，对服务器回复的ACK不予确认。导致服务器所有的连接处于挂起状态，消耗服务器资源。</p><p>防御：限制一台计算机向服务器发起SYN包的次数；先用代理服务器过滤掉可以的SYN包。</p><p><strong>2.RST复位攻击</strong><br>漏洞：TCP释放连接有两种方式，友好终止（FIN）和突然终止（RST）。RST&#x3D;1说明连接中出现严重差错，丢弃缓冲区中的包，立刻断开TCP连接。</p><p>手段：攻击者创建tcp复位数据报，将数据报发送给受害者和服务器，终止两者的连接。复位数据报的伪造要求【源IP、源端口、目标IP、目标端口、序号】都要正确，而且序号要落在窗口内，因此窗口越大，越容易发起复位攻击。</p><p><strong>3.会话劫持</strong><br>基本思想：扰乱客户和服务器之间的同步状态，改写客户与服务器之间的会话</p><p>过程：</p><p>攻击者等待客户与服务器之间的TCP连接正常开启<br>攻击者伪装成客户向服务器发送RST包，使服务器的TCP连接关闭<br>攻击者伪装成客户向服务器发送TCP连接请求，序列号与客户最初选择的不同<br>服务器与攻击者建立TCP连接，它为自己选择的序列号也与之前的不同<br>客户并不知道这些，它仍然保持着之前双方的序列号<br>这样，客户与服务器之间的序列号就被扰乱了，它们之间传输的报文不被对方接受<br>攻击者作为中间人，通过改写收到的数据包，来维持客户与服务器之间的数据传输<br><strong>4.ACK风暴</strong><br>漏洞：主机会在接收到一个它不期望的报文后，向对方返回一个ACK报文，告知对方它想接收什么报文，希望重新与对方同步。而对方在收到报文之后，也发现报文的序号不对，它又会向主机发送ACK报文。这样就构成死循环，使网络上充满ACK报文，导致网络拥塞。</p><p><strong>5.UDP Flood</strong></p><p>UDP Flood是日渐猖厥的流量型DoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击<span class="exturl"><a class="exturl__link"   href="http://www.qycn.com/qydns/" >DNS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>服务器或Radius认证服务器、流媒体视频服务器。</p>        <h3 id="应用层安全问题"   >          <a href="#应用层安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层安全问题" class="headerlink" title="应用层安全问题"></a>应用层安全问题</h3>      <p>针对<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=DHCP&spm=1001.2101.3001.7020" >DHCP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>协议：</p><p><strong>1.伪造发现报文：拒绝服务攻击</strong><br>攻击方法：攻击者向DHCP服务器发送大量伪造的DHCP发现报文（虚假的硬件地址）</p><p>目的：消耗掉地址池中的所有IP地址</p><p>注意：DHCP服务器会释放到期的IP，攻击者需持续发包</p><p><strong>2.伪造释放报文：ip冲突</strong><br>攻击方法：伪装成客户端，向DHCP服务器发送释放报文</p><p>目的：导致DHCP服务器向多台客户端提供同一个IP</p><p>注意：需要知道DHCP分配过的IP</p><p><strong>3.伪造提供报文：DHCP欺骗</strong><br>漏洞：客户不对收到的DHCP提供报文进行来源确认</p><p>攻击方法：攻击者伪装成DHCP服务器向客户端回应恶意DHCP提供报文</p><p>后果：给客户分配无效IP地址，造成客户无法使用网络，或将攻击者的IP作为默认网关提供给客户，嗅探客户流量</p><p>防御方法：配置交换机的信任端口。连接真正DHCP服务器的端口被配置为信任端口，只有从信任端口接收到的DHCP提供包才能继续转发，其余一律丢弃。</p><p>针对DNS协议:</p><p><strong>1.伪造查询报文：拒绝服务</strong></p><ul><li>向受害者DNS服务器发送大量的DNS查询请求包，导致DNS服务器无法正常工作</li></ul><p><strong>2.伪造应答报文：DNS劫持</strong></p><ul><li>漏洞：客户端永远相信DNS应答是正确的</li><li>攻击手段：直接向客户端发送恶意的DNS应答，或者将恶意条目插入到DNS服务器，修改域名和ip地址的对应项。</li></ul><p>针对HTTP协议：</p><p>http存在sql注入的风险</p>        <h3 id="访问控制"   >          <a href="#访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3>      <p><strong>自主访问控制（DAC）</strong>的特点是客体的创建者可以授予其他主体对客体的访问权限，十分灵活，实现方式有访问控制矩阵，访问控制列表，访问控制能力列表。访问控制矩阵是一个三元组，包括主体，客体和访问权限；访问控制列表是以文件为中心创建的，而访问控制能力列表则是基于用户为中心创建的。 </p><p>**强制访问控制(MAC)**，这是一种基于安全级别的访问控制，每一个主体和客体都被授予了不同的安全级别，通过判断主客体之间的安全级别进行访问控制。 </p><p>**基于角色的访问控制(RBAC)**，与上面两种访问控制不同的是这种策略不直接对用户授予权限，而是给用户赋予不同的角色，每个角色有不同的权限。 </p><p>**基于属性的访问控制(ABAC)**，每个用户携带自己的属性，包括主体属性，资源属性和环境属性来访问客体，授权引擎根据这些属性进行访问控制。 </p>        <h3 id="蠕虫-VS-木马-VS-病毒"   >          <a href="#蠕虫-VS-木马-VS-病毒" class="heading-link"><i class="fas fa-link"></i></a><a href="#蠕虫-VS-木马-VS-病毒" class="headerlink" title="蠕虫 VS 木马 VS 病毒"></a>蠕虫 VS 木马 VS 病毒</h3>      <p>蠕虫是一种可以独立运行，并能自动传播到其他计算机上的程序。<strong>利用缓冲区溢出漏洞使攻击代码自动运行</strong></p><p>木马通过网络在用户未察觉的情况下窃取用户信息或控制用户主机的程序。<strong>可建立远程连接</strong> </p><p>病毒是计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。 </p>        <h3 id="防火墙的局限性"   >          <a href="#防火墙的局限性" class="heading-link"><i class="fas fa-link"></i></a><a href="#防火墙的局限性" class="headerlink" title="防火墙的局限性"></a>防火墙的局限性</h3>      <p>1.防火墙只是一种边界安全保护系统，如果攻击者在内网，那将无法进行防护</p><p>2.防火墙是基于已有攻击知识制定的，无法对新的动机进行防护，难以防范零日漏洞</p><p>3.防火墙对通信内容的控制很弱，因此其对病毒、蠕虫、木马等恶意代码的防护能力很弱</p>        <h3 id="什么是SQL-注入？"   >          <a href="#什么是SQL-注入？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SQL-注入？" class="headerlink" title="什么是SQL 注入？"></a>什么是SQL 注入？</h3>      <p>SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>1). SQL注入攻击的总体思路</p><p>　　(1). 寻找到SQL注入的位置<br>　　(2). 判断服务器类型和后台数据库类型<br>　　(3). 针对不同的服务器和数据库特点进行SQL注入攻击</p>        <h3 id="什么是匿名网络"   >          <a href="#什么是匿名网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是匿名网络" class="headerlink" title="什么是匿名网络?"></a>什么是匿名网络?</h3>      <ol><li>匿名网络：暗网，使用洋葱路由，一层一层包裹数据包，网络节点都不知道目的端和起始端，所以匿名</li></ol><blockquote><p>被称作洋葱路由的原因在于消息一层一层的加密包装成被称作洋葱数据包的<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，层数取决于到目的地中间会经过的节点数，每经过一个节点层会将数据包的最外层解密，因此任一个节点都无法同时知晓这个消息最初与最终的目的地，使发送者达到匿名的效果。</p></blockquote>        <h3 id="用户隐私泄露怎么看，怎样防止泄露："   >          <a href="#用户隐私泄露怎么看，怎样防止泄露：" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户隐私泄露怎么看，怎样防止泄露：" class="headerlink" title="用户隐私泄露怎么看，怎样防止泄露："></a>用户隐私泄露怎么看，怎样防止泄露：</h3>      <p>用户隐私泄露，即用户在注册和使用相关网络应用上传的个人信息和数据被他人盗取，比如CSDN社区600万用户账号密码泄露，说明相关企业的网络安全意识淡薄，相关安全策略缺失。 在今天“数据为王”的当今社会,数据所给企业带来的收益，已远大于其它资产产生收益，数据泄露直接会给企业造成经济损失并影响其品牌形象。</p><p>如何防止泄露：首先相关安全技术实施好，比如密码不要明文存储，采用MD5加密，页面数据交互部分后端处理不能采取简单的拼接，防止SQL注入等等，然后也是最重要的相关技术人员和管理人员的网络安全意识一定要有，不然即使安全技术再好，也抵不住社会工程学攻击。 网络安全三分靠技术七分靠管理 </p>        <h3 id="什么是漏洞扫描"   >          <a href="#什么是漏洞扫描" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是漏洞扫描" class="headerlink" title="什么是漏洞扫描"></a>什么是漏洞扫描</h3>      <ol><li>漏洞扫描：漏洞扫描器包括网络漏扫、主机漏扫、数据库漏扫等不同种类。</li></ol><blockquote><p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。</p></blockquote>        <h3 id="什么是XSS攻击"   >          <a href="#什么是XSS攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h3>      <p>XSS（Cross-site scripting） 服务器对客户端的输入检测不严格 ，导致客户端输入的恶意JS代码被植入到HTML代码中，这些JavaScript代码得以执行，实现一些特殊的目的. 防御对策： 对输入内容中特殊字符进行转义 种类：持久型XSS、非持久型XSS 持久型XSS也叫存储型XSS 非持久性XSS分为反射型XSS和DOM型XSS </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。</span><br><span class="line">非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。</span><br><span class="line">持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</span><br><span class="line">DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。</span><br></pre></td></tr></table></div></figure>        <h3 id="什么是CSRF攻击"   >          <a href="#什么是CSRF攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3>      <p>跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>通过伪装来自受信任用户的请求来利用受信任的网站。<br>防御对策：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 阻止不明外域的访问：验证HTTP Referer字段</span><br><span class="line">   根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL(本例中，通常是以bank. test域名开头的地址)。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</span><br><span class="line">2. 提交时要求附加本域才能获取的信息：在请求地址中添加token并验证</span><br><span class="line">   CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="DES加密的大致过程"   >          <a href="#DES加密的大致过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#DES加密的大致过程" class="headerlink" title="DES加密的大致过程"></a>DES加密的大致过程</h3>      <p>64位明文经过初始置换之后，然后进行16轮迭代，进行逆置换，生成64位密文。</p><ul><li>用56位密钥加密64位数据（8个奇偶校验）</li><li>采用分组加密，feistel密码结构（feistel:简单地说Feistel结构就是顺序地执行两个或多个基本密码系统，使最后结果的密码强度高于每个密码系统的结果）</li><li>对称算法：加密和解密除密钥编排不同外，使用同一算法</li><li>密钥较短，加密处理简单，加解密速度快，适用于加密大量数据的场合</li></ul><p>流程：</p><p><strong>1.ip置换（先是左边的明文<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020" >加密</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>部分）</strong></p><p>给定明文，通过一个固定的初始置换IP来重排输入明文块P中的比特，得到比特串P0&#x3D;IP(P)&#x3D;L0R0，这里L0和R0分别是P0的前32比特和后32比特</p><p><strong>2.将ip置换后的明文分成两组</strong> </p><p><strong>3.右边进入分组密码的轮函数F</strong> </p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">轮函数包括E盒拓展、与轮密钥异或、S盒压缩、置换运算</span><br><span class="line">·右半部分继续进入E盒扩展</span><br><span class="line">因为子密钥是48bit，所以将数据通过e盒扩展从32bit——&gt;48bit(注意e盒扩展的规律)</span><br><span class="line"></span><br><span class="line">·与子密钥异或后，再通过S盒压缩</span><br><span class="line">48bit分成8组，通过8个s盒进行压缩恢复为32bit(注意压缩的方法：第一位与第六位组成行，中间四位组成列。最后查s盒得到的数据的二进制位压缩后的四位结果)</span><br><span class="line"></span><br><span class="line">·s盒的输出结果，通过p盒置换输出，轮函数F结束</span><br></pre></td></tr></table></div></figure><p><strong>4.轮函数F的输出结果再与左半部分异或形成新的R,而原来的R则转为L本轮结束</strong> </p><p>子密钥生成流程：密钥严格是64位，但是8位是奇偶校验位，因此是56位的</p><p><strong>1.先减掉8奇偶校验位，再通过pc-1置换</strong> </p><p><strong>2.分两组C0与D0进行循环左移位</strong> </p><p><strong>3.再进行pc-2的置换。52bit——&gt;48bit，本轮子密钥生成结束，下一轮密钥靠C1、D1循环左移位后继续通过pc-2置换</strong> </p>        <h3 id="AES加密的大致过程"   >          <a href="#AES加密的大致过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES加密的大致过程" class="headerlink" title="AES加密的大致过程"></a>AES加密的大致过程</h3>      <p>输入明文、子密钥，进行r轮迭代得到密文。 每一轮迭代过程为：明文先进行字节代替变换、行移位变换、列混合变换，再进行轮密钥加变换，得到下一轮输入  </p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;信息安全的基本属性&quot;   &gt;
          &lt;a href=&quot;#信息安全的基本属性&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#信息安全的基本属性&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之计算机组成原理</title>
    <link href="http://example.com/2022/10/05/%E6%9C%BA%E7%BB%84/"/>
    <id>http://example.com/2022/10/05/%E6%9C%BA%E7%BB%84/</id>
    <published>2022-10-05T12:52:25.185Z</published>
    <updated>2022-10-05T13:00:13.385Z</updated>
    
    <content type="html"><![CDATA[        <h4 id="总线是什么？"   >          <a href="#总线是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#总线是什么？" class="headerlink" title="总线是什么？"></a>总线是什么？</h4>      <p>1）总线是一组能功能部件之间分时共享的公共信息传送线路。分时、共享是它的两大特点。<br>2）分时是指同一时刻只能有一个部件向总线上发出信息。<br>3）总线分为三大类：片内总线、系统总线（数据总线+控制总线+地址总线）、通信总线。<br>4）通信方式分为：异步通信和并行通信。<br>5）一些特性：功能特性、电气特性、机械特性、时间特性。</p>        <h4 id="DMA是什么？"   >          <a href="#DMA是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA是什么？" class="headerlink" title="DMA是什么？"></a>DMA是什么？</h4>      <p>（1）CPU和外设之间数据传输的方式，外部设备发送DMA请求，CPU同意之后就让出总线控制权，DMA控制器接管总线控制权之后开始进行外部设备与内存之间的直接数据的，CPU不再作为中枢。比较适合大量数据的传输，跟中断相比减少了中断请求、相应、保存上下文（即环境）的时间，使得资源利用率以及吞吐量更大。<br>（2）DMA请求、DMA响应、数据传输、DMA结束<br>   （预处理–&gt;数据传输–&gt;后处理）</p>        <h4 id="说下五级流水CPU的各阶段"   >          <a href="#说下五级流水CPU的各阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下五级流水CPU的各阶段" class="headerlink" title="说下五级流水CPU的各阶段"></a>说下五级流水CPU的各阶段</h4>      <p>五级流水线指的是：取指、译码、执行、访存、写回五个操作。<br>1）取指：<br>指令取指（InstrucTIon Fetch）是指将指令从存储器中读取出来的过程。</p><p>2）译码：<br>指令译码（InstrucTIon Decode）是指将存储器中取出的指令进行翻译的过程。经过译码之后得到指令需要的操作数寄存器索引，可以使用此索引从通用寄存器组（Register File，Regfile）中将操作数读出。</p><p>3）执行：<br>指令译码之后所需要进行的计算类型都已得知，并且已经从通用寄存器组中读取出了所需的操作数，那么接下来便进行指令执行（InstrucTIon Execute）。指令执行是指对指令进行真正运算的过程。譬如，如果指令是一条加法运算指令，则对操作数进行加法操作；如果是减法运算指令，则进行减法操作。<br>在“执行”阶段的最常见部件为算术逻辑部件运算器（ArithmeTIc Logical Unit，ALU），作为实施具体运算的硬件功能单元。</p><p>4）访存：<br>存储器访问指令往往是指令集中最重要的指令类型之一，访存（Memory Access）是指存储器访问指令将数据从存储器中读出，或者写入存储器的过程。</p><p>5）写回：<br>写回（Write-Back）是指将指令执行的结果写回通用寄存器组的过程。如果是普通运算指令，该结果值来自于“执行”阶段计算的结果；如果是存储器读指令，该结果来自于“访存”阶段从存储器中读取出来的数据。</p>        <h4 id="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"   >          <a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？" class="headerlink" title="执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？"></a>执行单条指令时单周期CPU和五级流水CPU谁更快？为什么？</h4>      <p>1）五级流水CPU就是在多周期CPU的基础上+流水线思想——–&gt;实现并行。<br>2）传统的单周期CPU是指指令在一个时钟周期（即时钟到来一次）内执行完成，包括所有的操作。但这里存在的确定就是时钟周期的时间是固定的，所以时钟周期的时间应该是最长的指令所需要的时间，对于那种很短的指令，就会造成浪费。引入多周期，这时就可以减少浪费的时间。<br>3）单周期CPU（是指在一个时钟周期内完成这五个阶段的处理）。因为五级流水CPU中每一个操作的流水时间是一样的，取得是这五步中的最大执行时间，那么就是最大操作时间*需要执行的操作数目（取指、译码、、、）。<br>4）因为只有一条指令嘛，所以单周期最快，多条指令是考虑流水线比较好。</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h4 id=&quot;总线是什么？&quot;   &gt;
          &lt;a href=&quot;#总线是什么？&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#总线是什么？&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之概率论</title>
    <link href="http://example.com/2022/10/05/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    <id>http://example.com/2022/10/05/%E6%A6%82%E7%8E%87%E8%AE%BA/</id>
    <published>2022-10-05T12:52:25.182Z</published>
    <updated>2022-10-05T13:00:37.184Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="什么是最大似然估计？"   >          <a href="#什么是最大似然估计？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是最大似然估计？" class="headerlink" title="什么是最大似然估计？"></a>什么是最大似然估计？</h3>      <p>基本介绍：在所有θ 可能的取值中，寻找一个值使得这个采样的可能性最大化，可以通过使得似然函数的一阶导数等于零，使得这个函数取到最大值。这个使得可能性最大的值称为最大似然估计</p><p>定义：设  $X 1, X 2, \ldots, X n  $为来自总体$  X  $的简单随机样本，$  x 1, x 2, \ldots, x n  $为样本观测值称</p><p>$L(\theta)&#x3D;\prod_{i&#x3D;1}^{n} p\left(x_{i}, \theta\right)$为参数θ的似然函数,通过使得这个似然函数取得最大值，得到的对应参数值就是最大似然估计。</p><p><strong>⚠️注意：</strong>1）这里的似然函数是指 x1,x2,…,xn 不变时，关于 θ 的一个函数。</p><p>2）最大似然估计不一定存在，也不一定唯一。</p>        <h3 id="什么是中心极限定理？"   >          <a href="#什么是中心极限定理？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是中心极限定理？" class="headerlink" title="什么是中心极限定理？"></a>什么是中心极限定理？</h3>      <p>定义：如果样本量足够大，则变量均值的采样分布将近似于正态分布，而与该变量在总体中的分布无关。</p><p>说明：中心极限定理意味着即使数据分布不是正态的，从中抽取的样本均值的分布也是正态的。 </p><p>核心：独立同分布随机变量的均值呈正态分布。</p>        <h3 id="什么是大数定理？"   >          <a href="#什么是大数定理？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是大数定理？" class="headerlink" title="什么是大数定理？"></a>什么是大数定理？</h3>      <p>沟通概率论和统计的桥梁。</p><p>样本容量极大时，样本的均值必然趋近于总体的期望。</p><p><strong>大数定律告诉我们当样本量很大时能用频率近似代替概率；能用样本均值近似代替总体均值。</strong> </p>        <h3 id="一句话概括假设检验"   >          <a href="#一句话概括假设检验" class="heading-link"><i class="fas fa-link"></i></a><a href="#一句话概括假设检验" class="headerlink" title="一句话概括假设检验"></a>一句话概括假设检验</h3>      <ul><li><p><strong>假设检验</strong>：</p></li><li><ul><li>你提出假设：说你的硬币是公平的</li><li>我提出要检验你的假设：扔十次，看实验的结果是不是和你的假设相符</li></ul></li><li><p><strong>P值</strong></p></li><li><ul><li>一般认为<br>p−value≤0.05<br>就可以认为假设是不正确的。0.05这个标准就是<strong>显著水平</strong>，当然选择多少作为显著水平也是主观的。</li></ul></li><li></li></ul>        <h3 id="概率和统计的区别"   >          <a href="#概率和统计的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#概率和统计的区别" class="headerlink" title="概率和统计的区别"></a>概率和统计的区别</h3>      <p><strong>概率是已知模型和参数，推数据。统计是已知数据，推模型和参数。</strong> </p><p>概率一般是个确定的值，统计得到的具有一定的随机性</p>        <h3 id="概率和似然的区别"   >          <a href="#概率和似然的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#概率和似然的区别" class="headerlink" title="概率和似然的区别"></a>概率和似然的区别</h3>      <ul><li><p>P(x|θ)<br>输入有两个：x表示某一个具体的数据；θ表示模型的参数。</p></li><li><ul><li><strong>如果θ是已知确定的，x是变量</strong>，这个函数叫做概率函数(probability function)，它描述对于不同的样本点x，其出现概率是多少。</li><li><strong>如果x是已知确定的，θ是变量</strong>，这个函数叫做似然函数(<span class="exturl"><a class="exturl__link"   href="https://www.zhihu.com/search?q=likelihood+function&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22268007494%22%7D" >likelihood function</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>), 它描述对于不同的模型参数，出现x这个样本点的概率是多少。</li></ul></li></ul>        <h3 id="介绍一下欧拉公式"   >          <a href="#介绍一下欧拉公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下欧拉公式" class="headerlink" title="介绍一下欧拉公式"></a>介绍一下欧拉公式</h3>      <p>公式：$e^{i \theta}&#x3D;\cos (\theta)+i \sin (\theta)$</p><p>指数函数的定义域扩大到了复数域 </p><p>建立和三角函数和指数函数的关系 </p><p>在傅里叶变换中用到了欧拉函数</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;什么是最大似然估计？&quot;   &gt;
          &lt;a href=&quot;#什么是最大似然估计？&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#什么是最大似然估计？&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之操作系统</title>
    <link href="http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/10/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-05T12:52:25.178Z</published>
    <updated>2022-10-05T12:59:27.533Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>        <h3 id="操作系统的功能"   >          <a href="#操作系统的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3>      <p>作为资源的管理者</p><ul><li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li><li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li><li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li><li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li><li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li></ul>        <h3 id="操作系统的特征"   >          <a href="#操作系统的特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3>      <p>并发性：是在计算机系统中同时存在多个程序，宏观上看，这些程序是同时向前推进的。 在单CPU上，这些并发执行的程序是交替在CPU上运行的。 </p><p>共享性：资源共享是操作系统程序和多个用户程序共用系统中的资源。</p><p>异步性：即不确定性。同一程序和数据的多次运行可能得到不同的结果；程序的运行时间、运行顺序也具有不确定性；外部输入的请求、运行故障发生的时间难以预测。这些都是不确定性的表现</p><p>虚拟：是指通过技术将一个物理实体变成若干个逻辑上的对应物。在操作系统中虚拟的实现主要是通过分时的使用方法。显然，如果n是某一个物理设备所对应的虚拟逻辑设备数，则虚拟设备的速度必然是物理设备速度的1&#x2F;n。</p>        <h3 id="处理器的三级调度"   >          <a href="#处理器的三级调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a><strong>处理器的三级调度</strong></h3>      <p>高级调度（作业调度）：作业从磁盘调入内存所采取的调度算法，先来先服务调度算法、短作业优先调度算法 </p><p>中级调度：外存对换区的具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待。内存中暂时不能运行的进程对换到外存兑换区，此时状态为挂起状态。 </p><p>进程调度：采用什么样的算法将处理器分配给进程 </p>        <h3 id="线程、进程、管程的区别？"   >          <a href="#线程、进程、管程的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程、进程、管程的区别？" class="headerlink" title="线程、进程、管程的区别？"></a>线程、进程、管程的区别？</h3>      <p>进程：是系统进行资源分配的基本单位，创建一个进程，系统会为其分配相应的内存空间等资源。（我们平时用的exe类型的就是一个进程，比如WeChat和QQ以及浏览器）。一个进程可以拥有一个或者多个线程，线程的引入增加了并发度。 </p><p>线程：是轻量型进程，由进程创建，是系统进行独立调度和分配的基本单位，线程会与同属于一个进程的其他线程共享该进程所具备的资源，但是线程本身也具备一些自己特有的信息，比如程序寄存器等。 </p><p>管程：定义了一个<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。面向对象思想，表征共享资源的数据结构及其对数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节。 </p><p>进程定义的是私有数据结构PCB，管程定义的是公共数据结构 </p>        <h3 id="什么是死锁？死锁产生的条件？如何处理死锁问题"   >          <a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是死锁？死锁产生的条件？如何处理死锁问题" class="headerlink" title="什么是死锁？死锁产生的条件？如何处理死锁问题"></a>什么是<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020" >死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>？死锁产生的条件？<strong>如何处理死锁问题</strong></h3>      <p>死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。</p><p><img src="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210607160841587.png" alt="image-20210607160841587"></p><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。 </p>        <h3 id="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"   >          <a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）" class="headerlink" title="死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）"></a><strong>死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）</strong></h3>      <p>互斥条件：一个资源一次只能被一个进程使用</p><p>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</p><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</p><p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</p><p>常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略 </p>        <h3 id="解决死锁的基本方法？"   >          <a href="#解决死锁的基本方法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决死锁的基本方法？" class="headerlink" title="解决死锁的基本方法？"></a>解决死锁的基本方法？</h3>      <ol><li>预防死锁</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ol>        <h3 id="怎么预防死锁？"   >          <a href="#怎么预防死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么预防死锁？" class="headerlink" title="怎么预防死锁？"></a>怎么预防死锁？</h3>      <ol><li>破坏请求条件：一次性分配所有资源，这样就不会再有请求了；</li><li>破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：</li><li>破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；</li><li>破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。</li></ol>        <h3 id="怎么避免死锁？"   >          <a href="#怎么避免死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h3>      <p><strong>1. 安全状态</strong></p><p><img src="https://image.iamshuaidi.com/picture/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><p><strong>2. 单个资源的银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://image.iamshuaidi.com/picture/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><p><strong>3. 多个资源的银行家算法</strong></p><p><img src="https://image.iamshuaidi.com/picture/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img"></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>        <h3 id="怎么解除死锁？"   >          <a href="#怎么解除死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么解除死锁？" class="headerlink" title="怎么解除死锁？"></a>怎么解除死锁？</h3>      <ol><li>资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；</li><li>撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；</li><li>进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol>        <h3 id="windows和linux系统有什么区别"   >          <a href="#windows和linux系统有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#windows和linux系统有什么区别" class="headerlink" title="windows和linux系统有什么区别?"></a>windows和linux系统有什么区别?</h3>      <p>linux是免费开源的，windows是微软开发需要付费且用户无法修改的。</p><p>软件的兼容性windows更好，比较的丰富。</p><p>linux有很多的发行版本，易用性没有windows那么好。</p><p>因为用的更加普及，在windows平台的病毒更多。</p><p>linux比较的稳定，因此很多服务器都是用linux</p>        <h3 id="如何创建进程，如何创建线程？"   >          <a href="#如何创建进程，如何创建线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建进程，如何创建线程？" class="headerlink" title="如何创建进程，如何创建线程？"></a>如何创建进程，如何创建线程？</h3>      <p>linux使用fork()和thread()来创建</p><p>windows使用clone()来创建</p>        <h3 id="单线程进程一定比多线程进行慢吗？"   >          <a href="#单线程进程一定比多线程进行慢吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程进程一定比多线程进行慢吗？" class="headerlink" title="单线程进程一定比多线程进行慢吗？"></a>单线程进程一定比多线程进行慢吗？</h3>      <p>不一定，多线程存在上下文切换。</p><p>分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑。 </p>        <h3 id="进程之间的通信方式"   >          <a href="#进程之间的通信方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a><strong>进程之间的通信方式</strong></h3>      <p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。 </p><p><strong>管道</strong></p><p>它是半双工的，具有固定的读端和写端；<br>它只能用于父子进程或者兄弟进程之间的进程的通信；</p><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p><strong>命名管道</strong></p><p>FIFO 可以在无关的进程之间交换数据，与无名管道不同；<br>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p><strong>消息队列</strong></p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；<br>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</p><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；</p><p>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p><p><strong>信号量</strong></p><p>信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；<br>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</p><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</p><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</p><p>支持信号量组。</p><p><strong>共享内存</strong></p><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；</p><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p>        <h3 id="进程同步应遵循的原则"   >          <a href="#进程同步应遵循的原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程同步应遵循的原则" class="headerlink" title="进程同步应遵循的原则"></a><strong>进程同步应遵循的原则</strong></h3>      <p>空闲让进：当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。所以基本上不存在等待进程为n的情况。</p><p>忙则等待：当已有进程进入自己的临界区时，即相应的临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</p><p>有限等待：对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</p><p>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等</p>        <h3 id="分页和分段有什么区别"   >          <a href="#分页和分段有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#分页和分段有什么区别" class="headerlink" title="分页和分段有什么区别"></a>分页和分段有什么区别</h3>      <ol><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；</li><li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ol><p>段页式：先分段、再分页</p>        <h3 id="临界区？"   >          <a href="#临界区？" class="heading-link"><i class="fas fa-link"></i></a><a href="#临界区？" class="headerlink" title="临界区？"></a>临界区？</h3>      <p>每个进程中访问临界资源的那段代码称为临界区 </p><p>每次只允许一个进程进入临界区 </p><p>通过互斥进入来实现对临界资源的互斥访问</p>        <h3 id="文件管理系统管理的对象"   >          <a href="#文件管理系统管理的对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件管理系统管理的对象" class="headerlink" title="文件管理系统管理的对象"></a>文件管理系统管理的对象</h3>      <ol><li><strong>文件</strong>。在文件系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li><li><strong>目录</strong>。为了方便用户对文件的存取和检索，在文件系统中必须配置目录，在目录的每个目录项中，必须含有文件名、对文件属性的说明，以及该文件所在的物理地址（或指针）。对目录的组织和管理，是方便用户和提高对文件存取速度的关键。</li><li><strong>磁盘（磁带）存储空间</strong>。文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ol>        <h3 id="简单说下你对并发和并行的理解？"   >          <a href="#简单说下你对并发和并行的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单说下你对并发和并行的理解？" class="headerlink" title="简单说下你对并发和并行的理解？"></a>简单说下你对并发和并行的理解？</h3>      <ol><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；</li></ol>        <h3 id="同步、异步、阻塞、非阻塞的概念"   >          <a href="#同步、异步、阻塞、非阻塞的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步、异步、阻塞、非阻塞的概念" class="headerlink" title="同步、异步、阻塞、非阻塞的概念"></a>同步、异步、阻塞、非阻塞的概念</h3>      <p><strong>同步</strong>：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。</p><p><strong>异步</strong>：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><p><strong>阻塞</strong>：是指调用结果返回前，当前线程会被挂起，即阻塞。</p><p><strong>非阻塞</strong>：是指即使调用结果没返回，也不会阻塞当前线程。</p>        <h3 id="为什么有了进程，还要有线程呢？"   >          <a href="#为什么有了进程，还要有线程呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么有了进程，还要有线程呢？" class="headerlink" title="为什么有了进程，还要有线程呢？"></a>为什么有了进程，还要有线程呢？</h3>      <p>进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：</p><p>进程在同一时间只能干一件事情；<br>进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。</p><p>基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。</p>        <h3 id="进程的状态转换"   >          <a href="#进程的状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3>      <p>进程包括三种状态：就绪态、运行态和阻塞态。</p><p><img src="https://image.iamshuaidi.com/picture/image-20210907124303344.png" alt="image-20210907124303344"></p><ol><li><p>就绪 —&gt; 执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p></li><li><p>执行 —&gt; 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入&#x2F;输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；</p></li><li><p>阻塞 —&gt; 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入&#x2F;输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p></li><li><p>执行 —&gt; 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p></li></ol>        <h3 id="什么是缓冲区溢出？有什么危害？"   >          <a href="#什么是缓冲区溢出？有什么危害？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是缓冲区溢出？有什么危害？" class="headerlink" title="什么是缓冲区溢出？有什么危害？"></a>什么是缓冲区溢出？有什么危害？</h3>      <p>缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。 </p>        <h3 id="物理地址、逻辑地址、虚拟内存的概念"   >          <a href="#物理地址、逻辑地址、虚拟内存的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理地址、逻辑地址、虚拟内存的概念" class="headerlink" title="物理地址、逻辑地址、虚拟内存的概念"></a>物理地址、逻辑地址、虚拟内存的概念</h3>      <ol><li>物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。</li><li>逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</li><li>虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li></ol>        <h3 id="页面置换算法有哪些？"   >          <a href="#页面置换算法有哪些？" class="heading-link"><i class="fas fa-link"></i></a><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h3>      <p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。常用的页面置换算法如下：</p><ul><li><strong>先进先出置换算法（FIFO）</strong></li></ul><p>先进先出，即淘汰最早调入的页面。</p><ul><li><strong>最佳置换算法（OPT）</strong></li></ul><p>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</p><ul><li><strong>最近最久未使用（LRU）算法</strong></li></ul><p>即选择最近最久未使用的页面予以淘汰</p><ul><li><strong>时钟（Clock）置换算法</strong></li></ul><p>时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。</p>        <h3 id="谈谈你对动态链接库和静态链接库的理解？"   >          <a href="#谈谈你对动态链接库和静态链接库的理解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈你对动态链接库和静态链接库的理解？" class="headerlink" title="谈谈你对动态链接库和静态链接库的理解？"></a>谈谈你对动态链接库和静态链接库的理解？</h3>      <p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。</p><p>动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能</p>        <h3 id="外中断和异常有什么区别？"   >          <a href="#外中断和异常有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#外中断和异常有什么区别？" class="headerlink" title="外中断和异常有什么区别？"></a>外中断和异常有什么区别？</h3>      <p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>        <h3 id="一个程序从开始运行到结束的完整过程，你能说出来多少？"   >          <a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个程序从开始运行到结束的完整过程，你能说出来多少？" class="headerlink" title="一个程序从开始运行到结束的完整过程，你能说出来多少？"></a>一个程序从开始运行到结束的完整过程，你能说出来多少？</h3>      <p>四个过程：</p><p><strong>（1）预编译</strong> 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p><p><strong>（2）编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><p><strong>（3）汇编</strong></p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p><p><strong>（4）链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><p><strong>1、静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><p><strong>2、动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>        <h3 id="什么是用户态和内核态"   >          <a href="#什么是用户态和内核态" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h3>      <p>用户态和内核态是操作系统的两种运行状态。</p><ul><li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li><li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li></ul><blockquote><p>那么为什么要有用户态和内核态呢？</p></blockquote><p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>        <h3 id="用户态和内核态是如何切换的？"   >          <a href="#用户态和内核态是如何切换的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h3>      <p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p><p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p><p>他们的工作流程如下：</p><p><img src="https://image.iamshuaidi.com/picture/v2-1dfd23c107cca552b4e511ed526f75c4_720w.jpg" alt="img"></p><ul><li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li><li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li><li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li><li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li><li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li><li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li><li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li></ul>        <h3 id="进程终止的方式"   >          <a href="#进程终止的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程终止的方式" class="headerlink" title="进程终止的方式"></a>进程终止的方式</h3>      <p><strong>进程的终止</strong></p><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li><code>正常退出(自愿的)</code></li><li><code>错误退出(自愿的)</code></li><li><code>严重错误退出(非自愿的)</code></li><li><code>被其他进程杀死(非自愿的)</code></li></ul><p><strong>正常退出</strong></p><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p><p><strong>错误退出</strong></p><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></div></figure><p>Text</p><p>Copy</p><p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><p><strong>严重错误退出</strong></p><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><p><strong>被其他进程杀死</strong></p><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>        <h3 id="守护进程、僵尸进程和孤儿进程"   >          <a href="#守护进程、僵尸进程和孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程、僵尸进程和孤儿进程" class="headerlink" title="守护进程、僵尸进程和孤儿进程"></a>守护进程、僵尸进程和孤儿进程</h3>              <h5 id="守护进程"   >          <a href="#守护进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5>      <p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>        <h5 id="孤儿进程"   >          <a href="#孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5>      <p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>        <h5 id="僵尸进程"   >          <a href="#僵尸进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5>      <p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p><p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>        <h3 id="如何避免僵尸进程？"   >          <a href="#如何避免僵尸进程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何避免僵尸进程？" class="headerlink" title="如何避免僵尸进程？"></a>如何避免僵尸进程？</h3>      <ul><li>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</li><li>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</li><li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</li><li>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</li></ul><p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p>        <h3 id="介绍一下几种典型的锁？"   >          <a href="#介绍一下几种典型的锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下几种典型的锁？" class="headerlink" title="介绍一下几种典型的锁？"></a>介绍一下几种典型的锁？</h3>              <h5 id="读写锁"   >          <a href="#读写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5>      <ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul>        <h5 id="互斥锁"   >          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5>      <p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>        <h5 id="条件变量"   >          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5>      <p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>        <h5 id="自旋锁"   >          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5>      <p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>        <h3 id="常见内存分配内存错误"   >          <a href="#常见内存分配内存错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见内存分配内存错误" class="headerlink" title="常见内存分配内存错误"></a>常见内存分配内存错误</h3>      <p>（1）内存分配未成功，却使用了它。</p><p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p><p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p><p>（4）忘记了释放内存，造成内存泄露。</p><p>（5）释放了内存却继续使用它。常见于以下有三种情况：</p>        <h3 id="内存交换中，被换出的进程保存在哪里？"   >          <a href="#内存交换中，被换出的进程保存在哪里？" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存交换中，被换出的进程保存在哪里？" class="headerlink" title="内存交换中，被换出的进程保存在哪里？"></a>内存交换中，被换出的进程保存在哪里？</h3>      <p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。 </p>        <h3 id="原子操作的是如何实现的"   >          <a href="#原子操作的是如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#原子操作的是如何实现的" class="headerlink" title="原子操作的是如何实现的"></a>原子操作的是如何实现的</h3>      <p><strong>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</strong></p><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p>（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。</p><p>处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p><p>（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>        <h3 id="什么是虚拟内存"   >          <a href="#什么是虚拟内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3>      <p>传统的内存空间分配方式需要将作业一次性调入内存，太占空间，而程序运行的时候是有局部性的，可以将需要的调入内存，不需要的调出内存。</p><p>局部性原理：</p><p>①时间局部性：一条指令运行后，不久可能再次运行；数据被访问后，不久可能再次访问（因程序中有大量循环）</p><p>②空间局部性：程序访问了某个存储单元，与这个存储单元相邻的可能被再次访问（因为指令按顺序存放；数据是簇聚存储的）</p><p>实现方式：在非连续分配管理的基础上 引入了中断机制        一条指令执行期间可能产生多次缺页中断</p><p>1）请求分页存储管理        2）请求分段存储管理        3）段页式存储管理</p><p>在发生缺页后 发送缺页中断调入所缺页 若内存已满 要进行页面置换</p>        <h3 id="I-x2F-O控制方式："   >          <a href="#I-x2F-O控制方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O控制方式：" class="headerlink" title="I&#x2F;O控制方式："></a><strong>I&#x2F;O控制方式：</strong></h3>      <p>1）程序控制方式：CPU不断查询I&#x2F;O设备是否已经做好准备               </p><p>2）中断驱动方式（程序中断方式）：I&#x2F;O准备好数据 才发生中断通知CPU传数据</p><p>3）DMA方式：主存和I&#x2F;O之间有一条数据通路，传输数据由DMA负责，传完一个或多个数据块 通知CPU                    </p><p>4）通道控制方式：将数据传到哪 以及数据的传输都交给通道</p>        <h3 id="介绍下假脱机-Spooling-技术"   >          <a href="#介绍下假脱机-Spooling-技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下假脱机-Spooling-技术" class="headerlink" title="介绍下假脱机(Spooling)技术"></a>介绍下<strong>假脱机(Spooling)技术</strong></h3>      <p>通俗的讲，为了将独占的设备转化为逻辑上共享的设备，就是设备被占用，往设备发送的数据就先在磁盘暂存一下，等设备空闲再输入设备</p><p>组成：输入&#x2F; 出设备 输入&#x2F;出缓冲区 输入&#x2F;出井</p><p>常见应用：共享打印机</p>        <h3 id="DMA和中断方式的主要区别"   >          <a href="#DMA和中断方式的主要区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA和中断方式的主要区别" class="headerlink" title="DMA和中断方式的主要区别"></a><strong>DMA和中断方式的主要区别</strong></h3>      <p>1）谁控制数据传输：DMA方式是由DMA控制；中断方式是CPU控制</p><p>2）优先级：DMA中断优先级大于普通I&#x2F;O中断</p><p>3）中断相应的时机：DMA方式可以在每个机器周期结束时候响应；中断方式只能在指令执行周期结束后响应</p><p>4）DMA方式在结束一个数据块传送后才发中断；中断方式每传输一个字就要中断</p>        <h3 id="程序中断和子程序调用的区别"   >          <a href="#程序中断和子程序调用的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序中断和子程序调用的区别" class="headerlink" title="程序中断和子程序调用的区别"></a><strong>程序中断和子程序调用的区别</strong></h3>      <p>1）调用子程序的CALL指令的时机是固定的；中断是随机发生的</p><p>2）子程序的调用只涉及到软件；中断是软硬结合的过程</p><p>3）子程序由调用指令直接给出目标地址；中断要通过中断隐指令得到中断向量</p>        <h3 id="什么是上下文切换"   >          <a href="#什么是上下文切换" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3>      <p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 <strong>将 CPU 资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;

        &lt;h3 id=&quot;操作系统的功能&quot;   &gt;
          &lt;a href=&quot;#操作系统的功能&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#操作系统的功</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>保研复习之英语单词</title>
    <link href="http://example.com/2022/10/05/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"/>
    <id>http://example.com/2022/10/05/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/</id>
    <published>2022-10-05T12:52:25.175Z</published>
    <updated>2022-10-05T12:58:19.548Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>abstraction layer，抽象层</p></li><li><p>access，获取，存取</p></li><li><p>Active Directory，活动目录</p></li><li><p>acyclic digraph，有向无环图</p></li><li><p>Parameter ,参数</p></li><li><p>affinity，绑定</p></li><li><p>Aggregate，聚合</p></li><li><p>analog，模拟的</p></li><li><p>architecture，体系机构，结构</p></li><li><p>margin [ˈmɑ:dʒin] n. 余量，边缘，边际</p></li><li><p>deep neural network (DNN) 深度神经网络 </p></li><li><p>Linear Regression 线性回归 </p></li><li><p>Max-Pooling 最大池化 </p></li><li><p>Reinforcement Learning (RL) 强化学习</p></li><li><p>gradient descent 梯度下降</p></li><li><p>Threhold 阈值 </p></li><li><p>exploding gradient  [ˈɡreɪdiənt]梯度爆炸 </p></li><li><p>mometum 动量</p></li><li><p>hyperparameter 超参数</p></li><li><p>Activation Function 激活函数</p></li><li><p>Convolutional Neural Network (CNN) 卷积神经网络 </p></li><li><p>Backpropagation 反向传播 </p></li><li><p>bias units 激活值 </p></li><li><p>hidden (layer) units 隐藏层&#x2F;隐藏单元 </p></li><li><p>forward pass 前向传播 </p></li><li><p>correlation 相关系数 </p></li><li><p>dataset augmentation 数据增强 </p></li><li><p>derivative 导数 </p></li><li><p>Normalization 归一化 </p></li><li><p>Objective function 目标函数</p></li><li><p>Generalization 泛化 </p></li><li><p>Global Optimization 全局优化 </p></li><li><p>directed 有向 </p></li><li><p>dot product 点积 </p></li><li><p>embedding 嵌入 </p></li><li><p>determinant 行列式 </p></li><li><p>infinite 无穷 </p></li><li><p>integral 积分 </p></li><li><p>atomicity，原子性</p></li><li><p>attribute，特性</p></li><li><p>autonomous，独立性</p></li><li><p>baud，波特</p></li><li><p>block，阻断</p></li><li><p>Central Processing Unit，中央处理器（CPU）</p></li><li><p>channel，信道，频道</p></li><li><p>compatibility，兼容性</p></li><li><p>properties  特性</p></li><li><p>emergence 出现</p><hr></li><li><p>convolutional  卷积</p></li><li><p>spectral domain  谱域</p></li><li><p>implemented by  实现</p></li><li><p>supplemented  补充</p></li><li><p>comprehensively summarizes   全面总结</p></li><li><p>prospected  勘测</p></li><li><p>systematically review  系统回顾</p></li><li><p>Furthermore  进而</p></li><li><p>hybrid attention mechanism 混合注意力机制</p></li><li><p>namely  也即是</p></li><li><p>mitigate the interference  减轻干扰</p></li><li><p>cognitive intelligence 认知智能</p></li><li><p>knowledge graphs 知识图谱</p></li><li><p>distantly supervised training samples 远程监督训练样本</p></li><li><p>intelligent recommendation 智能推荐</p></li><li><p>conversation system 对话系统</p></li><li><p>Internet of things 物联网</p></li><li><p>secure multiparty computation 安全多方计算</p></li><li><p>jointly  共同地</p></li><li><p>cryptographic technology  密码技术</p></li><li><p>implementation framework 实施框架</p></li><li><p>oblivious transfer 不经意传输</p></li><li><p>threshold  阈值</p></li><li><p>adversary model 对抗型模式</p></li><li><p>security proof  安全证明</p></li><li><p>overview  概述；概况 </p></li><li><p>distribution statistics 分布统计</p></li><li><p>evaluations  定值，估计</p></li><li><p>prospected 勘测</p></li><li><p>corresponding to 对应的</p></li><li><p>Federated learning 联邦学习</p></li><li><p>model convergence rate 模型收敛速度</p></li><li><p>resource coordination 资源协调</p></li><li><p>expounded 阐述；说明； </p></li><li><p>adaptive learning 自适应学习</p></li><li><p>incentive mechanisms 激励机制</p></li><li><p>deploys  部署</p></li><li><p>Specifically 具体地;特别是</p></li><li><p>heterogeneous  各种各样的</p></li><li><p>innovation points 创新点</p></li><li><p>small perturbation 扰动</p></li><li><p>clean examples  自然样本</p></li><li><p>input dissociation 输入解离 </p></li><li><p>survey researches 调查研究 </p></li><li><p>evolution  演变</p></li><li><p>analyzes  分析 </p></li><li><p>selective redundancy 选择性冗余</p></li><li><p>adopts  采用</p></li><li><p>linear approximation[əˌprɑːksɪˈmeɪʃn] 线性逼近</p></li><li><p>data suite 数据集</p></li><li><p>subjoins  添加</p></li><li><p>predicate slice 谓词片 </p></li><li><p>adverse influence 负作用</p></li><li><p>distribution  分布</p></li><li><p>incrementally   增量的；迭代的</p></li><li><p>decimal[ˈdesɪml]  places 小数位</p></li><li><p>critical  临界的；危急的；关键的 </p></li><li><p>deviations  偏差</p></li><li><p>emerge in 出现在</p></li><li><p>representation 表示</p></li><li><p>intensity 强烈;紧张;</p></li><li><p>nominal model 标称模型</p></li><li><p>invalidation [ɪnˌvælɪˈdeɪʃn] 失效</p></li><li><p>Reversible  可逆的</p></li><li><p>error-free 无损</p></li><li><p>pixel 像素</p></li><li><p>preprocessing step 预处理阶段</p></li><li><p>non-overlapping blocks 非重叠；不重叠的； </p></li><li><p>compressed  压缩</p></li><li><p>corresponding key 对应的密钥</p></li><li><p>arithmetic coding 算数编码</p></li><li><p>pseudo-random 伪随机</p></li><li><p>domestic and foreign 国内外</p></li><li><p>temporal correlation 时间相关性</p></li><li><p>literatures  文献</p></li><li><p>so as to  为了</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstraction layer，抽象层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;access，获取，存取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Active Directory，活动目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;acyclic digraph，有向无环</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/05/hello-world/"/>
    <id>http://example.com/2022/10/05/hello-world/</id>
    <published>2022-10-05T09:17:44.543Z</published>
    <updated>2022-10-05T12:56:28.217Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl"><a class="exturl__link"   href="https://hexo.io/" >Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/" >documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   href="https://github.com/hexojs/hexo/issues" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>        <h2 id="Quick-Start"   >          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>              <h3 id="Create-a-new-post"   >          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure><p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/writing.html" >Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Run-server"   >          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure><p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/server.html" >Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Generate-static-files"   >          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure><p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/generating.html" >Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Deploy-to-remote-sites"   >          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure><p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;https://hexo.io/&quot; &gt;Hexo&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-ex</summary>
      
    
    
    
    
  </entry>
  
</feed>
