<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="时光cool的博客仓库">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="时光cool的博客仓库">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="水水水">
<meta name="twitter:card" content="summary"><title>时光cool的博客仓库</title><link ref="canonical" href="http://example.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="时光cool的博客仓库" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">时光cool的博客仓库</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E5%8A%9B%E6%89%A310.5/">剑指offer</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="剑指-Offer-II-004-只出现一次的数字"   >
          <a href="#剑指-Offer-II-004-只出现一次的数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-004-只出现一次的数字" class="headerlink" title="剑指 Offer II 004. 只出现一次的数字 "></a><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/WGki4K/" >剑指 Offer II 004. 只出现一次的数字 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>
      <p><strong>哈希</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; freq;</span><br><span class="line">        for (int num: nums) &#123;</span><br><span class="line">            ++freq[num];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (auto [num, occ]: freq) &#123;</span><br><span class="line">            if (occ == 1) &#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p><strong>位统计</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int a[32];</span><br><span class="line">		memset(a,0,sizeof a);</span><br><span class="line">		for(auto c:nums)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int i=0;i&lt;32;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(c&gt;&gt;i&amp;1)a[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;32;i++) a[i]=a[i]%3;</span><br><span class="line">		int ans=0;</span><br><span class="line">		for(int i=31;~i;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			ans&lt;&lt;=1;</span><br><span class="line">			ans+=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h4 id="剑指-Offer-II-005-单词长度的最大乘积"   >
          <a href="#剑指-Offer-II-005-单词长度的最大乘积" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/aseY1I/" >剑指 Offer II 005. 单词长度的最大乘积</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h4>
      <p><strong>暴力</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool st[1005][26];</span><br><span class="line">    int maxProduct(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        int len=words.size();</span><br><span class="line">        memset(st,0,sizeof st);</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;words[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                st[i][words[i][j]-&#x27;a&#x27;]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">            for(int j=i+1;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                bool f=false;</span><br><span class="line">                int len1=words[i].size(),len2=words[j].size();</span><br><span class="line">                for(int k=0;k&lt;words[i].size();k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(st[j][words[i][k]-&#x27;a&#x27;]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        f=true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(!f) ans=max(ans,len1*len2);</span><br><span class="line">            &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p><strong>位优化</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        int len=words.size();</span><br><span class="line">        vector&lt;int&gt;mask;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int t=0;</span><br><span class="line">            for(int j=0;j&lt;words[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t|=(1&lt;&lt;(words[i][j]-&#x27;a&#x27;));</span><br><span class="line">            &#125;</span><br><span class="line">            mask.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">            for(int j=i+1;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int len1=words[i].size(),len2=words[j].size();</span><br><span class="line">                if(mask[i]&amp;mask[j]) continue;</span><br><span class="line">                ans=max(ans,len1*len2);</span><br><span class="line">            &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/">保研复习之杂乱知识点</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><code>printf``(``&quot;%o&quot;``, a); </code> 表示输出为8进制</p>
<p><code> ``int</code> <code>x = -1;</code></p>
<p><code>    ``unsigned ``int</code> <code>y = 2;</code></p>
<p>有符号数与无符号数比较，会自动转换为无符号数，x&gt;y</p>
<p>C++编译器也不保证浮点数a+b的结果等于b+a </p>
<p>随机访问且易于文件扩展的是索引结构的特性。 </p>
<p>对IP数据报分片的重组通常发生在目的主机<br>分段是发生在传输层，一般是TCP进行分段；分片是发生在网络层，IP层会将数据进行分片传输</p>
<p><strong>UDP不会分段，那就又IP来分片；TCP会自行分段，那么就不需要IP来分片了。</strong> </p>
<p>通道技术实现了I&#x2F;O系统的独立性和各个部件的并行性。（可以理解为不同的CPU主存可以<strong>通过不同的通道，执行不同的通道指令，控制控制器执行不同操作</strong>） </p>

        <h4 id="广义表"   >
          <a href="#广义表" class="heading-link"><i class="fas fa-link"></i></a><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4>
      <p>（1）对任意一个非空的广义表，其表头可能是单元素，也可能是广义表。</p>
<p>（2）而其表尾一定是广义表。</p>
<p>广义表A&#x3D;((a),a)的表头是（a),表尾是(a)</p>
<p>把对视图的查询转化为对基本表的查询称为视图的消解 </p>
<p>select的执行顺序为：from where group having order by limit </p>
<p>有三类存储设备：独占设备、共享设备、虚拟设备</p>
<p>通过文件目录可以实现从文件名到文件（物理地址）的转化。 </p>
<p>C++中，能作为函数重载判断依据的是 参数类型、参数个数、Const</p>
<p>FTP使用21和20端口，用户通过21连接FTP服务器，服务器通过20与用户连接并传送数据 </p>
<p>多态有静态多态（编译时）和动态多态（运行时），静态多态主要实现了函数的重载和运算符的重载，动态时的多态主要实现了虚函数 </p>
<p>ICMP 差错控制报文不享受特别优先权</p>
<p>在父类的构造函数 和 析构函数 中都不能调用纯虚函数(不能以任何方式调用)。 </p>
<p>析构函数不能是虚函数和调用纯虚函数，但是可以自己申明为纯虚函数</p>
<p>构造函数可以被重载，不能为虚函数，没有返回值，创建对象时，基类的构造先调用，然后才是派生类里的</p>
<p>指针在64位系统中占用8个字节，A类中有3个指针，故占用24个字节。B类继承自A类且无成员变量和虚函数表，占用字节和A相同。 </p>
<p>分时系统最关键的问题是及时接收，及时处理。 </p>
<p>SATA 串口硬盘，是未来PC机硬盘的趋势， <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://baike.so.com/doc/1070721-1132939.html" >串行接口</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 还具有结构简单、支持热插拔的优点； </p>
<p>怎么标志分布在整个互联网上的万维网文档—统一资源定位符URL</p>
<p>用什么样的协议实现万维网上的各种链接—超文本传送协议HTTP</p>
<p>怎样使用不同风格的万维网文档都能在互联网上的主机上显示—超文本标记语言HTML</p>
<p>物理层中继系统：转发器(repeater)。</p>
<p>数据链路层中继系统：网桥或桥接器(bridge)。</p>
<p>网络层中继系统：路由器(router)。</p>
<p>网桥和路由器的混合物：桥路器(brouter)。</p>
<p>网络层以上的中继系统：网关(gateway)。</p>
<p> 对进程间互斥的使用临界资源，进程可以（互斥的进入各自的同类资源临界区）。 </p>
<hr>
<hr>
<hr>
<p>线性代数:正定矩阵、正则矩阵、矩阵求逆方法</p>
<p>英语问题:研究生规划</p>
<p>离散数学:相等关系和偏序关系是什么?闭包是什么?给你一个关系，怎么得到它的自反闭包?对称闭包?传递闭包?</p>
<p>优先级队列学过吗?什么时候用?怎么实现?</p>
<p>计算机网络:客户端和服务器传输数据怎么保证数据不丢失不错乱?</p>
<p>软件测试:白盒测试路径覆盖原理是什么?条件逻辑覆盖指的是什么?</p>
<p>研究生阶段最重要的品质,你觉得是什么?</p>
<p>英语介绍操作系统干啥的</p>
<p>应用软件怎么与操作系统协同工作？从计算机体系结构和操作系统的角度去说</p>
<p>操作系统：做过多线程吗？怎么样利用多核？做过多台电脑协同操作的项目吗？</p>
<p>AI：CNN的原理是什么？机器学习和深度学习的关系是什么？</p>
<p>两个栈实现队列</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈A  栈B</span><br><span class="line">队列入：栈B的数据都入栈A，然后数据入栈A</span><br><span class="line">队列出：栈A的数据入B直到有一个，然后A中数据输出出队列</span><br></pre></td></tr></table></div></figure>



<p>论文里的最让我感到棘手的地方是哪个</p>
<p>解释全概率公式</p>
<p>如何可视化高维特征</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不同的视图去表示数据的一部分属性</span><br><span class="line">利用平行坐标系</span><br></pre></td></tr></table></div></figure>



<p>求半副牌抽两张，没有大小王的概率</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(2,52)/C(2,54)</span><br></pre></td></tr></table></div></figure>



<p>十张考核牌里有四个难牌，甲乙丙三人抽题，抽出不放回，问1）三人都抽到难牌的概率？2）每个人抽到难牌的概率</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(3,4)/C(3,10)         4/10</span><br></pre></td></tr></table></div></figure>



<p>解释什么是二分</p>
<p>用动态规划解爬楼梯问题</p>
<p>求平方根的算法</p>
<p>汉诺塔问题，写伪代码</p>
<p>N个人围成圈，每三个人报数，报到3的人都离开，问最后还剩下的人，初始序号为？（约瑟夫环）</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//f(n)=(f(n-1)+3)%n;</span><br><span class="line">int dp[100001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[1]=0;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=(dp[i-1]+3)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>桌面上开始按钮的作用</p>
<p>回收站的作用</p>
<p>Linux的哲学是什么</p>
<p>指令和程序的区别是什么？指令的执行过程？指令和程序哪一个对计算机的性能影响更大？</p>
<p>解释检错码和纠错码？</p>
<p>浏览网页时在你输入网址到页面显示出来之间都发生了什么</p>
<p>你如何看待现在网络不安全的问题</p>
<p>什么是两个矩阵等价？用矩阵乘法严谨的表述</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线性代数和矩阵论中，有两个m×n阶矩阵A和B，如果这两个矩阵满足B=QAP(P是n×n阶可逆矩阵，Q是m×m阶可逆矩阵)，那么这两个矩阵之间是等价关系。</span><br></pre></td></tr></table></div></figure>



<p>为什么RGB三通道可以表示彩色图像？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为人眼对红、绿、蓝最为敏感,人的眼睛像一个三色接收器的体系,大多数的颜色可以通过红、绿、蓝三色按照不同的比例合成产生</span><br><span class="line">三原色</span><br></pre></td></tr></table></div></figure>



<p>C语言中堆和栈的区别</p>
<p>什么程序适合多进程，什么程序适合多线程，各举3个例子</p>
<p>一阶导，二阶导的物理意义，几何意义</p>
<p>说下网络中的主机通信流程</p>
<p>一个主机将两个端口接到网络上是否会提升吞吐量？为什么？</p>
<p>给一个数组，求huffman树的高度。</p>
<p>解释一下什么是时间复杂度；</p>
<p>用英文解释 快速排序</p>
<p>解释下快排为什么快？不要说快排的什么复杂度或者算法过程，回答为什么快。</p>
<p>因为时间局部性和空间局部性，cache比主存快，读入一个数据时，会把它周围内存地址的数据存入cache，下次访问直接就访问cache了，而快排又经常访问相邻元素，所以比较快。</p>
<p>xgboost的原理，比如正负样本不平衡如何处理</p>
<p>中断的过程</p>
<p>极大值什么时候等于最大值</p>
<p>m维线性空间的定义</p>
<p>独立性和不相关的关系</p>
<p>ping的协议是什么？</p>
<p>IP可以唯一表示地址，为什么还需要每台电脑的网卡？</p>
<p>网卡的作用</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络是通过模拟信号将信息转化为电流传播的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</span><br></pre></td></tr></table></div></figure>

<p>集合的划分 </p>
<p>集合的基 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在逻辑代数里,表示集合中元素个数的数就叫做这个集合的“基数”</span><br></pre></td></tr></table></div></figure>



<p>什么是域、环</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域表示</span><br><span class="line">环则是由两个运算符，其中加法符合交换群，乘法符合半群，乘法对加法的分配律</span><br></pre></td></tr></table></div></figure>



<p>public类中哪些成员可以被子类访问； </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public和Protect中的成员函数和成员数据都是可以访问的</span><br><span class="line">友元函数也是可以被访问的</span><br><span class="line">同时被设置为虚函数的子类可以访问或者重载</span><br></pre></td></tr></table></div></figure>



<p>c++和java都是面向对象的编程语言，他们之间有什么区别？ </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c++虽然是面向对象，但也可以面向过程编程</span><br><span class="line">c++可以多继承，但是java不行</span><br><span class="line">java没有指针,new后得到的是一个对象的引用</span><br><span class="line">java对于对象会自动回收，防止内存泄漏</span><br></pre></td></tr></table></div></figure>



<p>c++变量有哪些前缀修饰符？ </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern</span><br><span class="line">const</span><br><span class="line">static</span><br><span class="line">signed、unsigned</span><br></pre></td></tr></table></div></figure>



<p>C++的引用是什么？ </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用就是给已经存在的变量取得一个别名，而不是新定义一个变量。编译器不会为引用变量开辟新得内存空间，引用变量和引用的变量共用同一内存空间。</span><br></pre></td></tr></table></div></figure>



<p>如何求第二条最短路？ </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spfa即可</span><br><span class="line">dis1[]记录最短路， dis2[]记录第二短路</span><br><span class="line">显然有</span><br><span class="line">1、如果dis1被更新则dis2 = 旧的dis1</span><br><span class="line">2、if (dis1[v] == dis1[u] + edge[i].dis &amp;&amp; dis2[v] &gt; dis2[u] + edge[i].dis)</span><br><span class="line">dis2[v] = dis2[u] + edge[i].dis;</span><br><span class="line">3、if (dis1[v] &lt; dis1[u] + edge[i].dis &amp;&amp; dis2[v] &gt; dis1[u] + edge[i].dis) &#123;</span><br><span class="line">dis2[v] = dis1[u] + edge[i].dis;</span><br></pre></td></tr></table></div></figure>



<p>C++引用和指针的区别。 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。</span><br><span class="line">引用初始化后不能被改变，指针可以改变所指的对象。</span><br><span class="line">不存在指向空值的引用，但是存在指向空值的指针。</span><br></pre></td></tr></table></div></figure>



<p>寄存器寻址方式 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">立即数寻址方式</span><br><span class="line">寄存器寻址</span><br><span class="line">寄存器直接寻址</span><br><span class="line">寄存器间接寻址</span><br><span class="line">相对寻址</span><br><span class="line">基址加编址寻址</span><br><span class="line">相对基址加编址寻址：操作数的有效地址由于基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到。</span><br></pre></td></tr></table></div></figure>



<p>有哪些稳定的算法？ 不稳定的算法？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">稳定的算法：插入排序、折半插入排序、冒泡排序、归并排序</span><br><span class="line">不稳定的算法：快速排序、堆排序、选择排序、希尔排序</span><br></pre></td></tr></table></div></figure>



<p>算法复杂度的定义是什么？ 那O(n)的大O是什么意思 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫做渐进时间复杂度。大O符号表示程序运行时的渐进时间复杂度的上界，所以大O表示最坏情况下的时间复杂度</span><br></pre></td></tr></table></div></figure>



<p>何为系统调用？ </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS与应用进程之间的接口，它是用户程序取得OS服务的唯一途径，与一般过程调用的区别：运行在不同系统状态。调用程序运行在用户态，被调用程序运行在系统态，通过软中断机制，先由用户态转为系统态，才能转向相应的系统调用子程序。一般过程调用返回后继续执行，但对系统调用，当调用的进程仍具有最高优先权时，才返回到调用进程继续处理，否则只能等被重新调度</span><br></pre></td></tr></table></div></figure>



<p>Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别** </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） new、delete 是操作符，可以重载，只能在 C++中使用。</span><br><span class="line">（2） new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。malloc不会</span><br><span class="line">（3） new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。</span><br></pre></td></tr></table></div></figure>



<p>面向对象的三大特征** </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected， public）。</span><br><span class="line"> 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。</span><br><span class="line"> 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 这部分需要熟悉掌握原理虚函数，了解一些概念（静态多态、动态多态）等，面试时经常会问。</span><br></pre></td></tr></table></div></figure>



<p>static关键字有什么作用？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；</span><br><span class="line">修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；</span><br><span class="line">修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；</span><br><span class="line">修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；</span><br><span class="line">修饰成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。</span><br></pre></td></tr></table></div></figure>



<p>变量的声明和定义有什么区别</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</span><br><span class="line"></span><br><span class="line">说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</span><br></pre></td></tr></table></div></figure>



<p>全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；</span><br><span class="line">而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</span><br><span class="line">操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。</span><br></pre></td></tr></table></div></figure>



<p>如何避免“野指针”</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。</span><br><span class="line">指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。</span><br><span class="line">指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。</span><br></pre></td></tr></table></div></figure>



<p>选择排序和冒泡排序的区别</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择排序是每次从无序中找到一个最小的和开头进行交换</span><br><span class="line">冒泡排序是遍历无序，每次有更小的就进行交换</span><br><span class="line">选择排序每次就只能选出一个，冒泡排序可以把一系列的顺序给锊顺</span><br><span class="line">冒泡排序是稳定的，选择排序是不稳定的</span><br></pre></td></tr></table></div></figure>



<p>哈希冲突的四种解决办法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开放寻址法</span><br><span class="line">拉链法</span><br><span class="line">建立公共溢出区</span><br><span class="line">再哈希法</span><br></pre></td></tr></table></div></figure>



<p><strong>OSI和TCP&#x2F;IP模型各个层之间的协议和功能</strong> </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层：负责处理应用程序的逻辑。</span><br><span class="line">传输层：进程间通信，实现分用复用</span><br><span class="line">网络层：实现不同主机间的通信，实现数据包的选路和转发</span><br><span class="line">链路层：实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>协议三要素 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、语义是解释控制信息每个部分的意义；</span><br><span class="line">2、语法是用户数据与控制信息的结构与格式，以及数据出现的顺序；</span><br><span class="line">3、时序是对事件发生顺序的详细说明。</span><br></pre></td></tr></table></div></figure>



<p>有了IP地址为什么还要有MAC地址？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于利用原因在互联网中使用IP进行通信。IP地址一般表示的是一个网段，在互联网传输中大部分局域网都是通过防火墙后以代理IP进行数据包的发送，因此如果光使用IP地址的话无法实现如上的信息隐藏和发送代理。</span><br><span class="line">类似于寄快递，通过Ip地址可以确定送达的地方，通过MAC才能确定签收方。</span><br><span class="line">由于传输的场景不同，因此所使用的的参与也就有所不同。</span><br></pre></td></tr></table></div></figure>



<p><strong>一次HTTP请求过程</strong> </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）在浏览器中输入URL，并按下回车键；</span><br><span class="line">2）浏览器向DNS服务器发出域名解析请求并获得结果；</span><br><span class="line">3）根据目的IP地址和端口号，与服务器建立TCP连接；</span><br><span class="line">4）浏览器向服务器发送数据请求；</span><br><span class="line">5）服务器将网页数据发送给浏览器；</span><br><span class="line">6）通信完成，断开TCP连接；</span><br><span class="line">7）浏览器解析收到的数据并显示；</span><br></pre></td></tr></table></div></figure>



<p><strong>冯诺依曼体系结构</strong> </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算机主要由输入设备，输出设备，控制器，运算器，存储器该五个组成部分构成。</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>完成一条指令的四个周期 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•	取指周期</span><br><span class="line">•	间指周期</span><br><span class="line">•	执行周期</span><br><span class="line">•	中断周期</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>







</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">保研复习之线性代数</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">伴随矩阵</span><br><span class="line">奇异矩阵：非可逆矩阵</span><br><span class="line">共轭矩阵</span><br><span class="line">反对称矩阵</span><br><span class="line">增广矩阵</span><br><span class="line">行阶梯型矩阵</span><br><span class="line">行最简型矩阵</span><br><span class="line">标准型矩阵</span><br><span class="line">初等矩阵</span><br><span class="line">代数余子式</span><br><span class="line">k阶子式</span><br><span class="line">满秩矩阵</span><br><span class="line">降秩矩阵</span><br><span class="line">向量组的线性相关性</span><br><span class="line">最大线性无关向量组（最大无关组）</span><br><span class="line">向量空间的基、维度</span><br><span class="line">向量的内积</span><br><span class="line">正交向量组</span><br><span class="line">规范正交基</span><br><span class="line">正交矩阵</span><br><span class="line">特征值</span><br><span class="line">特征向量</span><br><span class="line">特征方程</span><br><span class="line">特征多项式</span><br><span class="line">正定矩阵/半正定矩阵</span><br><span class="line">相似矩阵</span><br></pre></td></tr></table></div></figure>




        <h3 id="线性代数中的线性代表的是什么？"   >
          <a href="#线性代数中的线性代表的是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性代数中的线性代表的是什么？" class="headerlink" title="线性代数中的线性代表的是什么？"></a>线性代数中的线性代表的是什么？</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://baike.baidu.com/view/300474.htm" >线性</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（linear）指量与量之间按比例、成直线的关系，在数学上可以理解为一阶<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://baike.baidu.com/view/30958.htm" >导数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>为<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://baike.baidu.com/view/122755.htm" >常数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的函数 </p>
<p><img src="https://img-blog.csdn.net/20161129141454990" alt="img"> </p>

        <h3 id="矩阵的秩的含义？"   >
          <a href="#矩阵的秩的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的秩的含义？" class="headerlink" title="矩阵的秩的含义？"></a>矩阵的秩的含义？</h3>
      <p>基本含义：矩阵的秩就是矩阵中不等于0的子式的最大阶</p>
<p>对于行阶梯矩阵来说就是非零行的行数</p>
<p>对于向量组而言就是等于列向量组和行向量组的秩，也就是表示列向量组和行向量组的最大无关向量组所含向量的个数</p>
<p>对于向量空间而言那就是等于对应矩阵的行空间的维数</p>
<p>对于线性方程组解而言，假设A的秩为$$r_a&lt;n$$,那么对应于$Ax &#x3D; 0$这个方程他的解系含有$n-r_a$个解向量</p>
<p>对于线性变换而言，一个图形通过这个矩阵进行线性变化后它能保持非零体积的最大维度</p>

        <h3 id="行列式的含义？"   >
          <a href="#行列式的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#行列式的含义？" class="headerlink" title="行列式的含义？"></a>行列式的含义？</h3>
      <p>基本概念：所有取自不同行不同列的数乘积的总和</p>
<p>本质意义：该矩阵在其对应维度的空间中所表示的图形的大小，二维表示的是面积，三维表示的是体积</p>
<p>与线性变化的关系：如果行列为0，那么说明通过该矩阵进行线性变化会丢失部分信息，可以表现为其对应空间的图形大小为0，同时该线性变化时不可逆的，将一组线性无关的矢量变成了线性相关的矢量。</p>

        <h3 id="线性相关的含义？"   >
          <a href="#线性相关的含义？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性相关的含义？" class="headerlink" title="线性相关的含义？"></a>线性相关的含义？</h3>
      <p>公式意义：$k_1\alpha _1+k_2\alpha _2+\dots +k_m\alpha _m&#x3D;0$至少存在一组非零解</p>
<p>可以理解为至少有一个向量可以由其余的向量通过线性组合表示</p>
<p>几何意义：n个向量线性无关那他们所张成的空间体积不为0</p>
<p>于是有这些线性无关向量组所构成的矩阵得到的行列式不为0，为可逆矩阵，同时矩阵的秩为n</p>

        <h3 id="矩阵的特征值与特征向量有什么关系？"   >
          <a href="#矩阵的特征值与特征向量有什么关系？" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的特征值与特征向量有什么关系？" class="headerlink" title="矩阵的特征值与特征向量有什么关系？"></a>矩阵的特征值与特征向量有什么关系？</h3>
      <p>每个特征值都有其对应的特征向量，一个特征值可能有多个对应的特征向量（表示其重数）</p>
<p>一个特征向量只有一个特征值</p>
<p>他们符合$AX&#x3D;\lambda X$这一方程</p>
<p>特征值是指矩阵A对向量X的变换相当于一个伸缩变换，没有旋转变换，即相当于一个缩放因子*向量X。那么这个缩放因子是矩阵A的本质，即AX&#x3D;tX,t即为A的特征值。</p>

        <h3 id="介绍一下正定矩阵"   >
          <a href="#介绍一下正定矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下正定矩阵" class="headerlink" title="介绍一下正定矩阵"></a>介绍一下正定矩阵</h3>
      <p>基本定义：这个矩阵所对应的所有特征值都是大于0的</p>
<p>广义定义：对于任意一个非零向量z，那么$z^TMz&gt;0$</p>
<p>判断是否为正定矩阵：①求出他的所有特征值，观察是否有小于等于0的特征值②根据两个特征值相加是正数，相乘也是正数，那么肯定特征值全部都是正数。 </p>
<p>性质：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行列式是大于0的， 是可逆矩阵，因此有一系列等价的。</span><br><span class="line">正定矩阵的逆也是正定矩阵，其逆的特征值分别都原来的倒数</span><br><span class="line">同时两个正定矩阵的和以及两个正定矩阵的积也都是正定矩阵。</span><br><span class="line">一个矩阵为正定矩阵当且仅当和单位矩阵合同</span><br><span class="line">矩阵的顺序主子式、主子式均为正</span><br></pre></td></tr></table></div></figure>






        <h3 id="矩阵行列式不为0的充要条件"   >
          <a href="#矩阵行列式不为0的充要条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵行列式不为0的充要条件" class="headerlink" title="矩阵行列式不为0的充要条件"></a>矩阵行列式不为0的充要条件</h3>
      <p>&lt;&#x3D;&#x3D;&gt;该矩阵是可逆的</p>
<p>&lt;&#x3D;&#x3D;&gt;该矩阵的秩为n</p>
<p>&lt;&#x3D;&#x3D;&gt;$Ax &#x3D; 0$只有一个零解</p>
<p>&lt;&#x3D;&#x3D;&gt;存在同阶方阵B使得$AB&#x3D;E$</p>
<p>&lt;&#x3D;&#x3D;&gt;其伴随矩阵$A^*$的秩也为n，伴随矩阵的行列式也不为0</p>
<p>&lt;&#x3D;&#x3D;&gt;$Ax &#x3D; b$有唯一解</p>
<p>&lt;&#x3D;&#x3D;&gt;该矩阵对应的行向量组和列向量组都是线性无关的</p>
<p>&lt;&#x3D;&#x3D;&gt;任意的n维向量都可以由其列向量组唯一线性表示</p>
<p>&lt;&#x3D;&#x3D;&gt;该矩阵的每个特征值都不为0</p>
<p>&lt;&#x3D;&#x3D;&gt;其等价标准形式单位矩阵</p>
<p>&lt;&#x3D;&#x3D;&gt;$A^TA$为正定矩阵</p>

        <h3 id="矩阵行列式为0的充要条件"   >
          <a href="#矩阵行列式为0的充要条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵行列式为0的充要条件" class="headerlink" title="矩阵行列式为0的充要条件"></a>矩阵行列式为0的充要条件</h3>
      <p>&lt;&#x3D;&gt; A不可逆 (又称奇异)</p>
<p>&lt;&#x3D;&gt; A的列(行)向量组<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3&spm=1001.2101.3001.7020" >线性相关</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>&lt;&#x3D;&gt; R(A)&lt;n &lt;&#x3D;&gt; AX&#x3D;0 有非零解 </p>
<p>&lt;&#x3D;&gt; A有特征值0. </p>
<p>&lt;&#x3D;&gt; A不能表示成初等矩阵的乘积 </p>
<p>&lt;&#x3D;&gt; A的等价标准形不是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020" >单位矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>

        <h3 id="求矩阵的秩"   >
          <a href="#求矩阵的秩" class="heading-link"><i class="fas fa-link"></i></a><a href="#求矩阵的秩" class="headerlink" title="求矩阵的秩"></a>求矩阵的秩</h3>
      <p>$\left(\begin{array}{cccc}a &amp; 1 &amp; \cdots &amp; 1 \1 &amp; a &amp; \cdots &amp; 1 \\vdots &amp; \vdots &amp; \ddots &amp; \vdots \1 &amp; 1 &amp; \cdots &amp; a\end{array}\right)$</p>
<p>转变成：</p>
<p>$$\left(\begin{array}{cccc}a-1 &amp; 0 &amp; \cdots &amp; 0 \0 &amp; a-1 &amp; \cdots &amp; 0 \\vdots &amp; \vdots &amp; \ddots &amp; \vdots \1 &amp; 1 &amp; \cdots &amp; 1\end{array}\right)$$</p>
<p>因此秩为n</p>

        <h3 id="矩阵求逆的过程"   >
          <a href="#矩阵求逆的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵求逆的过程" class="headerlink" title="矩阵求逆的过程"></a>矩阵求逆的过程</h3>
      <p>1.使用待定系数法去列方程组进行求解，对于维度较低的矩阵比较好用</p>
<p>2.基于$A^{-1}&#x3D;\frac{1}{|A|} A *$</p>
<p>首先计算伴随矩阵：矩阵元素所对应的代数余子式，所构成的矩阵，转置后得到的新矩阵。</p>
<p>3.初等变换求逆矩阵</p>
<p>首先，写出增广矩阵A|E，即矩阵A右侧放置一个同阶的单位矩阵，得到一个新矩阵。</p>
<p>然后进行初等行变换。使得左边变成单位矩阵</p>

        <h3 id="正定矩阵、正则矩阵、正交矩阵"   >
          <a href="#正定矩阵、正则矩阵、正交矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#正定矩阵、正则矩阵、正交矩阵" class="headerlink" title="正定矩阵、正则矩阵、正交矩阵"></a>正定矩阵、正则矩阵、正交矩阵</h3>
      <p>正定矩阵是他的特征值都大于0</p>
<p>正交矩阵是两个矩阵的内积为0</p>
<p>正则矩阵：所有矩阵经过初等行变换以后都能变成分块矩阵，其中一块是一个I矩阵，其他是0的分块矩阵，这样的分块矩阵叫做正则矩阵</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E5%BE%AE%E7%A7%AF%E5%88%86/">保研复习之微积分</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">导数</span><br><span class="line">导函数</span><br><span class="line">可导</span><br><span class="line">求导</span><br><span class="line">可微</span><br><span class="line">微分</span><br><span class="line">连续可微：函数f(x)的导数f’(x)存在且是连续函数，则f(x)连续可微。</span><br><span class="line">多元函数</span><br><span class="line">偏增量</span><br><span class="line">全增量</span><br><span class="line">偏导数</span><br><span class="line">全导数</span><br><span class="line">偏微分</span><br><span class="line">全微分</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="什么是导数和导函数？"   >
          <a href="#什么是导数和导函数？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是导数和导函数？" class="headerlink" title="什么是导数和导函数？"></a>什么是导数和导函数？</h3>
      <p>函数y &#x3D; f(x) 在点x0的某个邻域内有定义， 则当自变量x在x0处取得增量 deltax，函数输出值也相应取得增量deltay。如果deltay与deltax的比值在delta_x趋于0时的极限存在，则f(x)在x0处的导数存在，即f(x)在x0处可导。该极限即为f(x)在x0处的导数，记作f’(x0)。如果函数的自变量和取值都是实数的话，那么函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率。</p>
<p>如果函数在一段区间中每个点都是可导的，那么我们将得到的导数和对应的x值对应起来，就可以得到对应区间的一个导函数，表示的是在对应x下该函数的导数。</p>

        <h3 id="可导和可微之间的关系"   >
          <a href="#可导和可微之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#可导和可微之间的关系" class="headerlink" title="可导和可微之间的关系"></a>可导和可微之间的关系</h3>
      <p>首先可微可以推出可导</p>
<p>对于一元函数而言可微和可导是完全等价的，dy&#x3D;导数·dx</p>
<p>对于多元函数而言可微是需要在各个维度都可导才能推出的</p>

        <h3 id="介绍一下夹逼定理"   >
          <a href="#介绍一下夹逼定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下夹逼定理" class="headerlink" title="介绍一下夹逼定理"></a>介绍一下夹逼定理</h3>
      <p>有三个函数在某一区间满足A&gt;B&gt;C，在区间中某个点$x_0$有$\lim_{x \to 0} A&#x3D;\lim_{x \to 0} C&#x3D;X$则必有$\lim_{x \to 0} B&#x3D;X$</p>
<p>定理内容：</p>
<p>若函数 <img   src="https://www.zhihu.com/equation?tex=F(x)" style=""  alt="F(x)"> 和 <img   src="https://www.zhihu.com/equation?tex=G(x)" style=""  alt="G(x)"> 在 <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 的邻域连续， <img   src="https://www.zhihu.com/equation?tex=x%5Crightarrow" style=""  alt="x\rightarrow"> <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 时极限都为 <img   src="https://www.zhihu.com/equation?tex=A" style=""  alt="A"> ，即 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BF(x)%7D+=+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BG(x)%7D+=+A" style=""  alt="\lim_{x \rightarrow x_{0}}{F(x)} = \lim_{x \rightarrow x_{0}}{G(x)} = A"> ，且在该 <img   src="https://www.zhihu.com/equation?tex=x_%7B0%7D" style=""  alt="x_{0}"> 的邻域一直满足 <img   src="https://www.zhihu.com/equation?tex=F(x)%5Cleq+f(x)+%5Cleq+G(x)" style=""  alt="F(x)\leq f(x) \leq G(x)"> 。</p>
<p>则当 <img   src="https://www.zhihu.com/equation?tex=x%5Crightarrow+x_%7B0%7D" style=""  alt="x\rightarrow x_{0}"> 时也有 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BF(x)%7D%5Cleq+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D%5Cleq+%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7BG(x)%7D" style=""  alt="\lim_{x \rightarrow x_{0}}{F(x)}\leq \lim_{x \rightarrow x_{0}}{f(x)}\leq \lim_{x \rightarrow x_{0}}{G(x)}"> ，也就是 <img   src="https://www.zhihu.com/equation?tex=A%5Cleq%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D+%5Cleq+A" style=""  alt="A\leq\lim_{x \rightarrow x_{0}}{f(x)} \leq A"> ，</p>
<p>所以 <img   src="https://www.zhihu.com/equation?tex=%5Clim_%7Bx+%5Crightarrow+x_%7B0%7D%7D%7Bf(x)%7D=A" style=""  alt="\lim_{x \rightarrow x_{0}}{f(x)}=A"> .</p>

        <h3 id="介绍一下拉格朗日中值定理"   >
          <a href="#介绍一下拉格朗日中值定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下拉格朗日中值定理" class="headerlink" title="介绍一下拉格朗日中值定理"></a>介绍一下拉格朗日中值定理</h3>
      <p>定理：对于一个函数而言</p>
<p>（1）在(a,b)中可导  </p>
<p>（2）在[a,b]中连续  </p>
<p>（3）则必有一个 ξ∈(a,b)使得$f(b)-f(a)&#x3D;f’(\xi )*(b-a)$</p>
<p>几何含义：若连续曲线 y&#x3D;f(x) 在 A(a,f(a)), B(b,f(b)) 两点间的每一点处都有不垂直于x轴的切线，则曲线在 A,B 间至少存在一个点 P(c,f©)，使得该曲线在P点的切线与割线AB平行。 </p>
<p>物理含义：对于直线运动，在任意一个运动过程中至少存在一个位置（或一个时刻）的瞬时速度等于这个过程中的平均速度。</p>

        <h3 id="介绍一下凸函数"   >
          <a href="#介绍一下凸函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下凸函数" class="headerlink" title="介绍一下凸函数"></a>介绍一下凸函数</h3>
      <p>定义：对于任意的$x_1,x_2$都有$f\left(\lambda x_{1}+(1-\lambda) x_{2}\right) \leq \lambda f\left(x_{1}\right)+(1-\lambda) f\left(x_{2}\right), \forall \lambda \in(0,1)$</p>
<p>例子：指数函数$y&#x3D;e^x$</p>
<p>判断条件：$f^{\prime \prime}(x) \geq 0, \forall x$</p>
<p>重要性质：琴生不等式（定义的推广）</p>
<p>那么对于任意的 $ \left{x_{1}, x_{2}, \cdots, x_{n}\right} $ ， 以及正的权重系数 $ \left{w_{1}, w_{2}, \cdots, w_{n}\right} $, 且  $w_{1}+w_{2}+\cdots+w_{n}&#x3D;1$ , 则如下不等式成立$f\left(\sum_{k&#x3D;1}^{n} w_{k} \cdot x_{k}\right) \leq \sum_{k&#x3D;1}^{n} w_{k} \cdot f\left(x_{k}\right)$</p>

        <h3 id="你是如何理解e的？"   >
          <a href="#你是如何理解e的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你是如何理解e的？" class="headerlink" title="你是如何理解e的？"></a>你是如何理解e的？</h3>
      <p>来源命题：当增长率为100%时，让一个细胞总群能够增长的极限是扩大到e倍</p>
<p>含义：单位时间内，持续的翻倍增长所能达到的极限值</p>
<p>$lim（1+1&#x2F;x）^x $</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%95%B0%E6%8D%AE%E5%BA%93/">保研复习之数据库</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create database student;</span><br><span class="line">use student;</span><br><span class="line"></span><br><span class="line">create schema zhang;</span><br><span class="line">create table s ***;</span><br><span class="line">drop table zhang.s;</span><br><span class="line">drop schema zhang;</span><br><span class="line"></span><br><span class="line">foreign key(Cpno) reference s course(Cno);</span><br><span class="line"></span><br><span class="line">alter table student add graduation;</span><br><span class="line">alter table student unique(graduation);</span><br><span class="line">alter table student add foreign key(sno) references student(sno);</span><br><span class="line"></span><br><span class="line">order by子句：desc和asc</span><br><span class="line">distinct关键字：用于去重</span><br><span class="line">count：用于统计数量 </span><br><span class="line">sum、AVG、min、max条件用having</span><br><span class="line">group by子句：用于按属性分组		使用group by子句后，select子句的列名列表中只能出现分组属性和聚集函数</span><br><span class="line">having短语作用于组，从中选择满足条件的元组</span><br><span class="line"></span><br><span class="line">外连接：full outer join 左外连接：left outer join 右外连接:right full outer join</span><br><span class="line">**同时原先的条件where变为on</span><br><span class="line"></span><br><span class="line">并集：union 交集：intersect 差操作：except</span><br><span class="line">插入：insert 修改数据：update 删除：delete </span><br></pre></td></tr></table></div></figure>




        <h3 id="数据、数据库、数据库管系统、数据库系统"   >
          <a href="#数据、数据库、数据库管系统、数据库系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据、数据库、数据库管系统、数据库系统" class="headerlink" title="数据、数据库、数据库管系统、数据库系统"></a>数据、数据库、数据库管系统、数据库系统</h3>
      <p><strong>数据</strong>：数据库中存储的基本对象，描述一个事物的符号记录，数据和其语义不可分开说</p>
<p><strong>数据库</strong>（DB）：是长期储存在计算机内、有组织的、可共享的大量<strong>数据的集合。</strong></p>
<p><strong>数据库管理系统</strong>：一个管理数据的软件</p>
<p><strong>数据库系统</strong>：由数据库、数据库管理系统应用程序和数据库管理员（DBA）等组成的存储、管理、处理和维护数据的系统。 </p>

        <h3 id="数据库提供的功能"   >
          <a href="#数据库提供的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库提供的功能" class="headerlink" title="数据库提供的功能"></a>数据库提供的功能</h3>
      <p><strong>数据定义功能：</strong> 建表、修改表、删除表、定义数据对象</p>
<p><strong>操纵功能：</strong> 增删查改</p>
<p><strong>事务管理和运行管理：</strong> 数据库由DBMS统一管理和控制保证数据的安全，完整性、多用户对数据的并发使用、发生故障后的系统恢复 </p>
<p><strong>建立和维护功能：</strong> 数据库转存、数据库恢复、性能分析</p>

        <h3 id="数据的完整性约束条件"   >
          <a href="#数据的完整性约束条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据的完整性约束条件" class="headerlink" title="数据的完整性约束条件"></a>数据的完整性约束条件</h3>
      <p>实体完整性：具体的数据的属性信息是否完整，主键约束、唯一约束</p>
<p>参照完整性：该属性对应的值存在</p>
<p>用户定义完整性：</p>

        <h3 id="数据库系统的三级模式结构"   >
          <a href="#数据库系统的三级模式结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3>
      <p>内模式：1）是<strong>数据物理结构和存储方式的描述</strong>；2）是数据在<strong>数据库内部的表示方式</strong> </p>
<p>​		一个数据库只有一个内模式。 </p>
<p>模式：数据库中全体数据的逻辑结构和特征的描述，所有用户的公共数据视图，综合了所有用户的需求，<strong>一个数据库只有一个模式</strong> </p>
<p>外模式：模式的<strong>子集</strong>，一个数据库可以有多个，是数据库中局部数据的逻辑结构和特征的描述</p>

        <h3 id="数据库的二级映像功能与数据的独立性"   >
          <a href="#数据库的二级映像功能与数据的独立性" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的二级映像功能与数据的独立性" class="headerlink" title="数据库的二级映像功能与数据的独立性"></a>数据库的二级映像功能与数据的独立性</h3>
      <p>外模式&#x2F;模式映像：保证了数据的逻辑独立性。不唯一</p>
<p>1）当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</p>
<p>2）应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p>
<p>模式&#x2F;内模式映像：保证了数据的物理独立性。唯一</p>
<p>1）当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变，进而外模式也不发生改变</p>
<p>2）应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性</p>

        <h3 id="数据库系统的组成"   >
          <a href="#数据库系统的组成" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h3>
      <p>硬件，操作系统，数据库设计人员，数据库管理人员，数据库管理系统，用户等等。 </p>

        <h3 id="CHAR-amp-VARCHAR"   >
          <a href="#CHAR-amp-VARCHAR" class="heading-link"><i class="fas fa-link"></i></a><a href="#CHAR-amp-VARCHAR" class="headerlink" title="CHAR &amp; VARCHAR"></a>CHAR &amp; VARCHAR</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CHAR列的长度固定为创建表时声明的长度。 长度可以为从0到255的任何值。 </span><br><span class="line"></span><br><span class="line">比较时会在末尾补满空格后与现已存在的值比较。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值 </span><br><span class="line"></span><br><span class="line">VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值 </span><br><span class="line"></span><br><span class="line">VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。 </span><br></pre></td></tr></table></div></figure>




        <h3 id="关系数据库标准语言SQL"   >
          <a href="#关系数据库标准语言SQL" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL语句是结构化查询语句</span><br><span class="line">特点：综合统一、高度非过程化、面向集合、既可以是独立的语言也可以是嵌入式的语言</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="索引"   >
          <a href="#索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引" class="headerlink" title="索引"></a>索引</h3>
      <p>加入的目的是加快数据查询的速度 </p>
<p>DBA或者表的属主可以根据需要建立表的索引；但是有些DBMS可以自动建立以下索引 </p>
<p>分两种：聚簇索引和唯一性索引</p>

        <h3 id="事务ACID包括代表的是什么？"   >
          <a href="#事务ACID包括代表的是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务ACID包括代表的是什么？" class="headerlink" title="事务ACID包括代表的是什么？"></a>事务ACID包括代表的是什么？</h3>
      <p>原子性 (Atomicity)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单个事务，为一个不可分割的最小工作单元，整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性</span><br></pre></td></tr></table></div></figure>

<p>一致性(Consistency)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中， 一致性确保了，即使在执行第三、四条语句之间时系统崩潰，信用卡账户也不会损失100块，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，保证数据一致性。</span><br></pre></td></tr></table></div></figure>

<p>隔离性(Isolation) </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</span><br></pre></td></tr></table></div></figure>

<p>持久性(Durability)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</span><br></pre></td></tr></table></div></figure>




        <h3 id="范式"   >
          <a href="#范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#范式" class="headerlink" title="范式"></a>范式</h3>
      <p>范式是指符合某一种级别的关系模式的集合，是关系型数据理论的基础。</p>
<p>一般涉及到1NF、2NF、3NF</p>
<p>1NF表示的是列的原子性，即列不能够再分为其他几列</p>
<p>2NF表示完全依赖与主键，不存在某非主键列只依赖于部分主键列</p>
<p>3NF消除了传递依赖，非主键列只能依赖于主键，不能存在传递依赖</p>

        <h3 id="锁"   >
          <a href="#锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁" class="headerlink" title="锁"></a>锁</h3>
      <p>锁的类型有三种：  </p>
<p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。  </p>
<p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。  </p>
<p>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。 </p>

        <h3 id="什么是视图？"   >
          <a href="#什么是视图？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h3>
      <p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22268007494%22%7D" >多表查询</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。 </p>

        <h3 id="除了关系型数据库还有什么数据库？"   >
          <a href="#除了关系型数据库还有什么数据库？" class="heading-link"><i class="fas fa-link"></i></a><a href="#除了关系型数据库还有什么数据库？" class="headerlink" title="除了关系型数据库还有什么数据库？"></a>除了关系型数据库还有什么数据库？</h3>
      <p>层次型数据库 IBM公司的IMS</p>
<p>网状数据库</p>

        <h3 id="什么是数据库的完整性约束条件-可分为哪几类"   >
          <a href="#什么是数据库的完整性约束条件-可分为哪几类" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是数据库的完整性约束条件-可分为哪几类" class="headerlink" title="什么是数据库的完整性约束条件?可分为哪几类?"></a>什么是数据库的完整性约束条件?可分为哪几类?</h3>
      <p>完整性约束条件是指数据库中的数据应该满足的语义约束条件。一般可以分为六类:静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束。静态列级约束是对一个列的取值域的说明,包括以下几个方面: ( l )对数据类型的约束,包括数据的类型、长度、单位、精度等; ( 2 )对数据格式的约束; ( 3 )对取值范围或取值集合的约束; ( 4 )对空值的约束; ( 5 )其他约束.静态元组约束就是规定组成一个元组的各个列之间的约束关系,静态元组约束只局限在单个元组上。静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。 </p>

        <h3 id="并发操作下可能会产生并发一致性问题"   >
          <a href="#并发操作下可能会产生并发一致性问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发操作下可能会产生并发一致性问题" class="headerlink" title="并发操作下可能会产生并发一致性问题"></a><strong>并发操作下可能会产生并发一致性问题</strong></h3>
      <p>丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p>读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p>不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p>幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>

        <h3 id="概念模型-逻辑模型和物理模型"   >
          <a href="#概念模型-逻辑模型和物理模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念模型-逻辑模型和物理模型" class="headerlink" title="概念模型 逻辑模型和物理模型"></a>概念模型 逻辑模型和物理模型</h3>
      <p>概念模型是现实世界的第一层抽象 E-R图</p>
<p>逻辑模型将概念模型转化为具体的数据模型的过程 层次&#x2F;网状&#x2F;关系&#x2F;面向对象</p>
<p>物理模型针对上述逻辑模型所说的内容 , 在具体的物理介质上实现出来 </p>
<p>这三个过程 , 就是实现一个数据库设计的三个关键的步骤 , 是一个从抽象到具体的一个不断细化完善的分析 , 设计和开发的过程 ; </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">保研复习之数据结构</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="算法的基本特征"   >
          <a href="#算法的基本特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法的基本特征" class="headerlink" title="算法的基本特征"></a>算法的基本特征</h3>
      <p>有效性、确定性、有穷性、有零个或多个输入、有一个或多个输出 </p>
<p>算法是一个有穷规则的集合，这些规则确定了解决某类问题的一个运算序列。对于该类问题的任何初始输入值，它都能机械地一步一步地执行计算，经过有限步骤后终止计算并产生输出结果。归纳起来，算法具有以下基本特征： (1)有穷性：一个算法必须在执行有限个操作步骤后终止； (2)确定性：算法中每一步的含义必须是确切的，不可出现任何二义性； (3)有效性：算法中的每一步操作都应该能有效执行，一个不可执行的操作是无效的。例如，一个数被0除的操作就是无效的，应当避免这种操作。 (4)有零个或多个输入：这里的输入是指在算法开始之前所需要的初始数据。这些输入的多少取决于特定的问题。 (5)有一个或多个输出：所谓输出是指与输入有某种特定关系的量，在一个完整的算法中至少会有一个输出。</p>

        <h3 id="什么是数据结构？"   >
          <a href="#什么是数据结构？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h3>
      <p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020" >集合</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。结构包括逻辑结构和物理结构。</p>
<p><strong>数据的逻辑结构包括4种</strong></p>
<p>(1)集合：数据元素之间除了有相同的数据类型再没有其他的关系</p>
<p>(2)线性结构：数据元素之间是一对一的关系 ——线性表、栈、<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020" >队列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>(3)<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >树形结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：数据元素之间是一对多的关系</p>
<p>(4)图状结构：数据元素之间是多对多的关系。</p>
<p><strong>物理结构包括顺序存储结构和链式存储结构。</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的存储结构有：顺序、链接、索引等存储结构</span><br></pre></td></tr></table></div></figure>






        <h3 id="解释一下顺序存储与链式存储"   >
          <a href="#解释一下顺序存储与链式存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#解释一下顺序存储与链式存储" class="headerlink" title="解释一下顺序存储与链式存储"></a>解释一下顺序存储与链式存储</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >顺序存储结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是用一段连续的存储空间来存储数据元素，可以进行随机访问，访问效率较高。链式存储结构是用任意的存储空间来存储数据元素，不可以进行随机访问，访问效率较低。 </p>

        <h3 id="头指针和头结点的区别？"   >
          <a href="#头指针和头结点的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#头指针和头结点的区别？" class="headerlink" title="头指针和头结点的区别？"></a>头指针和头结点的区别？</h3>
      <p>头指针：是指向第一个节点存储位置的指针，具有标识作用，头指针是链表的必要元素，无论链表是否为空，头指针都存在。</p>
<p>头结点：是放在第一个元素节点之前，便于在第一个元素节点之前进行插入和删除的操作，头结点不是链表的必须元素，可有可无，头结点的数据域也可以不存储任何信息。</p>

        <h3 id="数组和链表的区别？"   >
          <a href="#数组和链表的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组和链表的区别？" class="headerlink" title="数组和链表的区别？"></a>数组和链表的区别？</h3>
      <p>从逻辑结构来看：数组的存储长度是固定的，它不能适应数据动态增减的情况。链表能够动态分配存储空间以适应数据动态增减的情况，并且易于进行插入和删除操作。</p>
<p>从访问方式来看：数组在内存中是一片连续的存储空间，可以通过数组下标对数组进行随机访问，访问效率较高。链表是链式<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020" >存储结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，存储空间不是必须连续的，可以是任意的，访问必须从前往后依次进行，访问效率较数组来说比较低。</p>
<p>如果从第i个位置插入多个元素，对于数组来说每一次插入都需要往后移动元素，每一次的时间复杂度都是O(n)，而单链表来说只需要在第一次寻找i的位置时时间复杂度为O(n)，其余的插入和删除操作时间复杂度均为O(1)，提高了插入和删除的效率。</p>

        <h3 id="栈和队列的区别"   >
          <a href="#栈和队列的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h3>
      <p>队列是允许在一段进行插入另一端进行删除的线性表，对于进入队列的元素按“先进先出”的规则处理，在表头进行删除在表尾进行插入。</p>
<p>栈是只能在表尾进行插入和删除操作的线性表。对于插入到栈的元素按“后进先出”的规则处理，插入和删除操作都在栈顶进行。由于进栈和出栈都是在栈顶进行，所以要有一个size变量来记录当前栈的大小，当进栈时size不能超过数组长度，size+1，出栈时栈不为空，size-1。</p>

        <h3 id="栈和堆的区别，以及为什么栈要快"   >
          <a href="#栈和堆的区别，以及为什么栈要快" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈和堆的区别，以及为什么栈要快" class="headerlink" title="栈和堆的区别，以及为什么栈要快"></a>栈和堆的区别，以及为什么栈要快</h3>
      <ul>
<li><strong>堆和栈的区别</strong>：1、堆是由低地址向高地址扩展；栈是由高地址向低地址扩展 2、堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存 3、堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片 4、堆的分配效率较低，而栈的分配效率较高</li>
<li><strong>栈的效率高的原因：</strong> 栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C&#x2F;C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</li>
</ul>

        <h3 id="介绍一下字符串匹配算法KMP算法"   >
          <a href="#介绍一下字符串匹配算法KMP算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下字符串匹配算法KMP算法" class="headerlink" title="介绍一下字符串匹配算法KMP算法"></a>介绍一下字符串匹配算法KMP算法</h3>
      <p>首先计算nextval</p>
<p>①上下子串前缀匹配</p>
<p>②找到公共前后缀（取最长且小于比较的上下字串长度）</p>
<p>③将下面的p子串前缀移动到后缀位置</p>

        <h3 id="介绍下prim算法和Kruskal算法"   >
          <a href="#介绍下prim算法和Kruskal算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下prim算法和Kruskal算法" class="headerlink" title="介绍下prim算法和Kruskal算法"></a>介绍下prim算法和Kruskal算法</h3>
      <p>目的是得到最小生成树</p>
<p><strong>普里姆(prim)算法的基本思想为：顶点集到其他点权值最小边，加入新的顶点集，再找边…直到遍历所有点</strong> </p>
<p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。 </p>
<p>1.在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code> </p>
<p>2.任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>. </p>
<p>3.重复以下操作，直到所有点都被标记为<code>visit</code>： </p>
<p><strong>克鲁斯卡尔(kruskal)算法的基本思想为：依次选择最小边，使得无环且所有点遍历结束</strong> </p>
<p>Kruskal是另一个计算最小生成树的算法，其算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。 </p>

        <h3 id="介绍下拓扑排序算法"   >
          <a href="#介绍下拓扑排序算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍下拓扑排序算法" class="headerlink" title="介绍下拓扑排序算法"></a>介绍下拓扑排序算法</h3>
      <p>每次都应当从入度为0的结点开始遍历。因为只有入度为0的结点才能够成为拓扑排序的起点。否则根据拓扑排序的定义，只要一个结点<code>v</code>的入度不为0，则至少有一条边起始于其他结点而指向<code>v</code>，那么这条边的起点在拓扑排序的顺序中应当位于<code>v</code>之前，则<code>v</code>不能成为当前遍历的起点。 </p>
<p> 拓扑排序可以用深度优先遍历或广度优先遍历算法来实现。 </p>

        <h3 id="关键路径如何确定？"   >
          <a href="#关键路径如何确定？" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键路径如何确定？" class="headerlink" title="关键路径如何确定？"></a>关键路径如何确定？</h3>
      <p>关键路径的特征是：从起点 (起点是唯一的，入度为0) 到终点 (终点是唯一的，出度为0) 的一个有向图中，该路径上的弧 (有向图的边称之为“弧”) 的权重的和最大。 </p>
<p>1.我们需要计算每个节点的earlyTime (最早开始时间)。终点的earlyTime 就是从起点到终点的最大权重和。 </p>
<p>2.如果我们从终点到起点，进行反向的计算lastTime (最晚开始时间)，如果某一条路径的每一个结点的earlyTime 与lastTime都相等，那么这条路径就是关键路径。 </p>

        <h3 id="介绍散列表处理冲突的几种方法"   >
          <a href="#介绍散列表处理冲突的几种方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍散列表处理冲突的几种方法" class="headerlink" title="介绍散列表处理冲突的几种方法"></a>介绍散列表处理冲突的几种方法</h3>
      <p><strong>开放地址法：</strong>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020" >散列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。   包括线性探测法、二次探测法、随机探测法</p>
<p><strong>再散列函数法：</strong></p>
<blockquote>
<p><strong>fi ( key ) &#x3D; RHi ( key ) (i&#x3D;1,2,…,k)</strong></p>
</blockquote>
<p>RHi 就是不同的散列函数，可以将前面说<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=104356727" >散列表查找及其函数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的除留余数、折叠、平方取中全部用上。每当出现散列地址冲突，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，但是相应地会增加计算的时间。</p>
<p><strong>链地址法</strong>：将所有关键字为同义词的记录存储在一个单链表中，我们称之为同义词子表，在<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97%E8%A1%A8&spm=1001.2101.3001.7020" >散列表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中只存储所有同义词子表的头指针。 </p>
<p><strong>公共溢出区法</strong>：当发生冲突的时候，凡是冲突的跟我走，给这些冲突找个地儿呆着。我们为所有冲突的关键字建立一个公共的溢出区来存放。 </p>

        <h3 id="排序算法知道哪些，哪个是最快的，为什么？"   >
          <a href="#排序算法知道哪些，哪个是最快的，为什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序算法知道哪些，哪个是最快的，为什么？" class="headerlink" title="排序算法知道哪些，哪个是最快的，为什么？"></a><strong>排序算法知道哪些，哪个是最快的，为什么？</strong></h3>
      <p>插入排序：简单插入、折半插入排序、希尔排序</p>
<p>交换排序：冒泡排序、快速排序</p>
<p>选择排序：</p>
<p>归并排序：</p>
<p>外部排序：</p>

        <h3 id="介绍一下B-树"   >
          <a href="#介绍一下B-树" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下B-树" class="headerlink" title="介绍一下B+树"></a>介绍一下B+树</h3>
      <p>b+树是一种树状数据结构，一般用在数据库和操作系统的文件管理中。</p>
<p>特点是支持顺序存储，能够保证数据稳定有序，是b树的一种变体。</p>
<p>1）B+树只在叶节点存放记录，其他结点只起到索引作用；B树在所有结点中保存记录</p>
<p>2）B+树的叶节点支持顺序查找，B树不支持</p>
<p>3）B+树n个结点对应n个分叉；B树n个结点对应n+1个分叉</p>

        <h3 id="AVL树和红黑树的区别？"   >
          <a href="#AVL树和红黑树的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#AVL树和红黑树的区别？" class="headerlink" title="AVL树和红黑树的区别？"></a>AVL树和红黑树的区别？</h3>
      <p>红黑树平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，红黑树的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。</p>
<p>在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于红黑树只追求大致平衡，因此红黑树至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(logn) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除红黑树更加合适。</p>

        <h3 id="如何在无序数组中查找第k小的值"   >
          <a href="#如何在无序数组中查找第k小的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何在无序数组中查找第k小的值" class="headerlink" title="如何在无序数组中查找第k小的值"></a>如何在无序数组中查找第k小的值</h3>
      <p>1.首先进行排序  然后找出下标为k-1的数，时间复杂度为O(n*logn)</p>
<p>2.建立大小为k的大顶堆，遍历数据如果大于大顶堆的顶那么先pop然后push该值，时间复杂度为O(n*logk)</p>
<p>3.基于快排找基准的方法，首先建立一个类似快排的函数，然后返回值为基准对应的下标，调用该函数，如果返回值刚好等于k-1则返回答案，如果大于k-1则递归左半部分数组，否则递归右半部分数组，时间复杂度为O(n)</p>
<p><strong>追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</strong></p>
<p>当有相同元素的时候， 首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)。 </p>

        <h3 id="海量数据如何去取最大的k个"   >
          <a href="#海量数据如何去取最大的k个" class="heading-link"><i class="fas fa-link"></i></a><a href="#海量数据如何去取最大的k个" class="headerlink" title="海量数据如何去取最大的k个"></a>海量数据如何去取最大的k个</h3>
      <p><strong>1.直接全部排序（只适用于内存够的情况）</strong> 当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。 这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出topK个数据，所以该方法并不十分高效，不建议使用。</p>
<p><strong>2.快速排序的变形 （只使用于内存够的情况）</strong> 这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。 这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index&gt;K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回TopK个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p><strong>3.最小堆法 这是一种局部淘汰法。</strong> 先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p><strong>4.分治法</strong> 将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p><strong>5.Hash法</strong> 如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>

        <h3 id="哪些图算法用到了动态规划思想"   >
          <a href="#哪些图算法用到了动态规划思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#哪些图算法用到了动态规划思想" class="headerlink" title="哪些图算法用到了动态规划思想"></a>哪些图算法用到了动态规划思想</h3>
      <p>floyd算法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int k = 1; k &lt;= n; k ++)</span><br><span class="line">    for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">        for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">             d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br></pre></td></tr></table></div></figure>




        <h3 id="判断链表是否有环"   >
          <a href="#判断链表是否有环" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>
      <p>使用双指针法，一个慢指针每次往后走一个单位，一个快指针每次往后走两个长度，如果在慢指针遍历完成之前没有相遇，则没有环，如果相遇了那么证明有环。</p>
<p>如果要找到成环的开头，可以让一个指针从开头开始走，每次往后一个单位，当它与慢指针相遇时得到便是那个开头。</p>

        <h3 id="介绍一下深度优先搜索和广度优先搜索是如何实现的？"   >
          <a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？" class="headerlink" title="介绍一下深度优先搜索和广度优先搜索是如何实现的？"></a>介绍一下深度优先搜索和广度优先搜索是如何实现的？</h3>
      <p>深度优先搜索：(1)访问起始点v0(2)若v0的第一个邻接点没有被访问过，则深度遍历该邻接点；(3)若v0的第一个邻接点已经被访问，则访问其第二个邻接点，进行深度遍历；重复以上步骤直到所有节点都被访问过为止</p>
<p>广度优先搜索：(1)访问起始点v0(2)依次遍历v0的所有未访问过得邻接点 (3)再依次访问下一层中未被访问过得邻接点；重复以上步骤，直到所有的顶点都被访问过为止</p>

        <h3 id="哈希表的概念、构造方法、冲突的解决办法？"   >
          <a href="#哈希表的概念、构造方法、冲突的解决办法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希表的概念、构造方法、冲突的解决办法？" class="headerlink" title="哈希表的概念、构造方法、冲突的解决办法？"></a>哈希表的概念、构造方法、冲突的解决办法？</h3>
      <p>哈希表又称为散列表，是根据关键字码的值直接进行访问的数据结构，即它通过把关键码的值映射到表中的一个位置以加快查找速度，其中映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希函数的构造方法包括：直接定址法，除留余数法，数字分析法，平方取中法，折叠法，随机数法</p>
<p>(1)直接定址法：取关键字的某个线性函数值作为散列地址，H(key)&#x3D;a*key+b。</p>
<p>(2)除留余数法：取关键字对p取余的值作为散列地址，其中p</p>
<p>(3)数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列的地址，适用于所有关键字都已知的情况。</p>
<p>(4)平方取中法：对关键字求平方，再取结果中的中间几位作为散列地址。</p>
<p>(5)折叠法：将关键字分为位数相同的几部分，然后取这几部分的叠加和作为散列地址。适用于关键字位数较多，且关键字中每一位上数字分布大致均匀。</p>
<p>(6)随机数法：选择一个随机函数，把关键字的随机函数值作为散列地址。适合于关键字的长度不相同时。</p>
<p>哈希冲突的解决方法包括：开放定址法和拉链法，当冲突发生时，使用某种探测技术形成一个探测序列，然后沿此序列逐个单单元查找，直到找到该关键字或者碰到一个开放的地址为止，探测到开放的地址表明该表中没有此关键字，若要插入，则探测到开放地址时可将新节点插入该地址单元。其中开放定址法包括：线性探查法，二次探查法，双重散列法</p>
<p>(1)线性探查法：基本思想，探查时从地址d开始，首先探查T[d],在探查T[d+1]…直到查到T[m-1]，此后循环到T[0],T[1]…直到探测到T[d-1]为止。</p>
<p>(2)二次探查法：基本思想，探查时从地址d开始，首先探查T[d],再探查T[d+12],T[d+22]…等，直到探查到有空余地址或者探查到T[d-1]为止，缺点是无法探查到整个散列空间。</p>
<p>(3)双重散列法：基本思想，使用两个散列函数来确定地址，探查时从地址d开始，首先探查T[d],再探查T[d+h1(d)],T[d+2*h1(d)]…</p>
<p>链接法：将所有关键字为同义词的节点链接在同一个单链表中，若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组，凡是散列地址为i的节点均插入到头指针为i的单链表中。</p>

        <h3 id="各种排序算法"   >
          <a href="#各种排序算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#各种排序算法" class="headerlink" title="各种排序算法"></a>各种排序算法</h3>
      <p>内部排序包括：插入排序、选择排序、交换排序、归并排序、基数排序。其中插入排序包括：直接插入排序、折半插入排序、希尔排序；选择排序包括：简单选择排序，堆排序；交换排序包括：冒泡排序、快速排序。</p>
<p>(1)直接插入排序(稳定)：基本思想为：将序列分为有序部分和无序部分，从无序部分依次选择元素与有序部分比较找到合适的位置，将原来的元素往后移，将元素插入到相应位置上。时间复杂度为：O(n^2),空间复杂度为O(1)</p>
<p>(2)折半插入排序(稳定)：基本思想为：设置三个变量low high mid，令mid&#x3D;(low+high)&#x2F;2,若a[mid]&gt;key,则令high&#x3D;mid-1,否则令low&#x3D;mid+1,直到low&gt;high时停止循环，对序列中的每个元素做以上处理，找到合适位置将其他元素后移进行插入。比较次数为O(nlog2n),但是因为要后移，因此时间复杂度为O(n^2),空间复杂度为O(1)。 优点是：比较次数大大减少。</p>
<p>(3)希尔排序(不稳定)：基本思想为：先将序列分为若干个子序列，对各子序列进行直接插入排序，等到序列基本有序时再对整个序列进行一次直接插入排序。优点是：让关键字值小的元素能够很快移动到前面，且序列基本有序时进行直接插入排序时间效率会提升很多，空间复杂度为O(1)。</p>
<p>(4)简单选择排序(不稳定)：基本思想为：将序列分为2部分，每经过一趟就在无序部分找到一个最小值然后与无序部分的第一个元素交换位置。优点是：实现简单，缺点是：每一趟只能确定一个元素的位置，时间效率低。时间复杂度为O(n^2)，空间复杂度为O(1)。</p>
<p>(5)堆排序(不稳定)：设有一个任意序列，k1,k2,…,kn，当满足下面特点时称之为堆：让此序列排列成完全二叉树，该树具有以下特点，该树中任意节点均大于或小于其左右孩子，此树的根节点为最大值或者最小值。优点是：对大文件效率明显提高，但对小文件效率不明显。时间复杂度为O(nlog2n),空间复杂度为O(1)。</p>
<p>(6)冒泡排序(稳定)：基本思路为：每一趟都将元素进行两两比较，并且按照“前小后大”的规则进行交换。优点是：每一趟不仅能找到一个最大的元素放到序列后面，而且还把其他元素理顺，如果下一趟排序没有发生交换则可以提前结束排序。时间复杂度为O(n^2),空间复杂度为O(1)。</p>
<p>(7)快速排序(不稳定)：基本思路为：在序列中任意选择一个元素作为中心，比它大的元素一律向后移动，比它小的元素一律向前移动，形成左右两个子序列，再把子序列按上述操作进行调整，直到所有的子序列中都只有一个元素时序列即为有序。优点是：每一趟不仅能确定一个元素，时间效率较高。时间复杂度为O(nlog2n),空间复杂度为O(log2n).</p>
<p>(8)归并排序(稳定)：基本思想为：把两个或者两个以上的有序表合并成一个新的有序表。时间复杂度为O(nlogn),空间复杂度和待排序的元素个数相同。</p>
<p>(9)基数排序：时间复杂度为：对于n个记录进行链式基数排序的时间复杂度为O(d(n+rd)),其中每一趟分配的时间复杂度为O(n),回收的时间复杂度为O(rd)。</p>
<p>“前小后大”的规则进行交换。优点是：每一趟不仅能找到一个最大的元素放到序列后面，而且还把其他元素理顺，如果下一趟排序没有发生交换则可以提前结束排序。时间复杂度为O(n^2),空间复杂度为O(1)。</p>
<p>(7)快速排序(不稳定)：基本思路为：在序列中任意选择一个元素作为中心，比它大的元素一律向后移动，比它小的元素一律向前移动，形成左右两个子序列，再把子序列按上述操作进行调整，直到所有的子序列中都只有一个元素时序列即为有序。优点是：每一趟不仅能确定一个元素，时间效率较高。时间复杂度为O(nlog2n),空间复杂度为O(log2n).</p>
<p>(8)归并排序(稳定)：基本思想为：把两个或者两个以上的有序表合并成一个新的有序表。时间复杂度为O(nlogn),空间复杂度和待排序的元素个数相同。</p>
<p>(9)基数排序：时间复杂度为：对于n个记录进行链式基数排序的时间复杂度为O(d(n+rd)),其中每一趟分配的时间复杂度为O(n),回收的时间复杂度为O(rd)。</p>

        <h3 id="贪心算法和动态规划以及分治法的区别"   >
          <a href="#贪心算法和动态规划以及分治法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法和动态规划以及分治法的区别" class="headerlink" title="贪心算法和动态规划以及分治法的区别"></a>贪心算法和动态规划以及分治法的区别</h3>
      <p>贪心算法：局部最优，划分的每个子问题都最优，得到全局最优，但是不能保证是全局最优解，所以对于贪心算法来说，解是从上到下的，一步一步最优，直到最后。</p>
<p>动态规划：将问题分解成重复的子问题，每次都寻找左右子问题解中最优的解，一步步得到全局的最优解.重复的子问题可以通过记录的方式，避免多次计算。所以对于动态规划来说，解是从小到上，从底层所有可能性中找到最优解，再一步步向上。</p>
<p>分治法：和动态规划类似，将大问题分解成小问题，但是这些小问题是独立的，没有重复的问题。独立问题取得解，再合并成大问题的解。</p>

        <h3 id="用循环比递归的效率高吗？"   >
          <a href="#用循环比递归的效率高吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#用循环比递归的效率高吗？" class="headerlink" title="用循环比递归的效率高吗？"></a><strong>用循环比递归的效率高吗？</strong></h3>
      <p>循环和递归两者是可以互换的，不能决定性的说循环的效率比递归高。</p>
<p><strong>递归</strong></p>
<p>【优点】：代码简洁清晰，容易检查正确性；</p>
<p>【缺点】：当递归调用的次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，对执行效率有一定的影响。</p>
<p><strong>循环</strong></p>
<p>【优点】：结构简单，速度快；</p>
<p>【缺点】：它并不能解决全部问题，有的问题适合于用递归来解决不适合用循环。</p>

        <h3 id="如何区分循环队列是队空还是队满？"   >
          <a href="#如何区分循环队列是队空还是队满？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何区分循环队列是队空还是队满？" class="headerlink" title="如何区分循环队列是队空还是队满？"></a><strong>如何区分循环队列是队空还是队满？</strong></h3>
      <p><strong>普通情况</strong>下，</p>
<p><strong>循环队列</strong>队空和队满的判定条件是一样的，都是<strong>Q.front &#x3D;&#x3D; Q.rear。</strong></p>
<p><em>ps:队头指针指向第一个数；队尾指针指向最后一个数的下一个位置，即将要入队的位置。</em></p>
<blockquote>
<p>方法一：<strong>牺牲一个单元</strong>来区分队空和队满，这个时候**(Q.rear+1)%MaxSize &#x3D;&#x3D; Q.front**才是队满标志 。</p>
</blockquote>
<blockquote>
<p>方法二：类型中<strong>增设表示元素个数的数据成员</strong>。这样，队空的条件为Q.size &#x3D;&#x3D; 0;队满的条件为Q.size &#x3D;&#x3D; MaxSize。</p>
</blockquote>

        <h3 id="快排存在的问题，如何优化"   >
          <a href="#快排存在的问题，如何优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#快排存在的问题，如何优化" class="headerlink" title="快排存在的问题，如何优化"></a>快排存在的问题，如何优化</h3>
      <p>时间复杂度最快平均是O（nlogn）,最慢的时候是O(n2); </p>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序 原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排 </p>
<p>优化2：随机选取分割位置； 当分割位置不理想时，考虑是否重新选取分割位置； </p>
<p>优化3：优化递归操作 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化</p>

        <h3 id="队列在计算机系统中的应用？"   >
          <a href="#队列在计算机系统中的应用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列在计算机系统中的应用？" class="headerlink" title="队列在计算机系统中的应用？"></a><strong>队列在计算机系统中的应用？</strong></h3>
      <p>队列在计算机系统中的应用非常广泛，以下仅从两个方面来简述队列在计算机系统中的作用：</p>
<p>第一个方面是解决<strong>主机与外部设备之间速度不匹配</strong>的问题</p>
<p>第二个方面是解决由<strong>多用户引起的资源竞争</strong>问题。</p>
<blockquote>
<p>（对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的 数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。</p>
<p>对于第二个方面， CPU (即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型 的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU 各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU 的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU 分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU 分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU 能够正常运行。）</p>
</blockquote>

        <h3 id="矩阵的压缩存储"   >
          <a href="#矩阵的压缩存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a><strong>矩阵的压缩存储</strong></h3>
      <p>数据结构中，提供针对某些<strong>特殊矩阵</strong>的压缩存储结构。这里所说的特殊矩阵，主要分为以下两类：</p>
<ul>
<li>含有大量<strong>相同数据元素</strong>的矩阵，比如对称矩阵；</li>
<li>含有<strong>大量 0 元素的矩阵</strong>，比如稀疏矩阵、上（下）三角矩阵；</li>
</ul>
<p>针对以上两类矩阵，数据结构的<strong>压缩存储思想</strong>是：矩阵中的<strong>相同数据元素（包括元素 0）只存储一个</strong>。</p>

        <h3 id="线索二叉树的概念？"   >
          <a href="#线索二叉树的概念？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线索二叉树的概念？" class="headerlink" title="线索二叉树的概念？"></a><strong>线索二叉树的概念？</strong></h3>
      <p>对于<strong>n个结点</strong>的二叉树，在二叉链存储结构中有<strong>n+1个空链域</strong>，利用这些空链域存放在某种遍历次序下该结点的<strong>前驱结点和后继结点</strong>的指针，这些指针称为<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>。</p>
<p>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为<strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种。</p>
<p><strong>注意：</strong>线索链表解决了<strong>无法直接找到该结点在某种遍历序列中的前驱和后继结点</strong>的问题，解决了二叉链表找左、右孩子困难的问题。</p>

        <h3 id="树的存储结构？"   >
          <a href="#树的存储结构？" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的存储结构？" class="headerlink" title="树的存储结构？"></a><strong>树的存储结构？</strong></h3>
      <p><strong>双亲表示法</strong></p>
<p>这种存储方式采用<strong>一组连续空间</strong>来存储每个结点，同时在每个结点中增设一个<strong>伪指针</strong>，指示其<strong>双亲结点在数组中的位置</strong>。</p>
<p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iY2Y1ZjhlNi02ODhmLTRhZmUtOTQxYS03NjQzMjhkNDNjNjAucG5n?x-oss-process=image/format,png" style=""  alt="img"></p>
<p>该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。</p>
<p><strong>孩子表示法</strong></p>
<p>孩子表示法是将<strong>每个结点</strong>的<strong>孩子结点</strong>都用<strong>单链表</strong>链接起来形成一个线性结构，此时n 个结点就有n 个孩子链表（叶子结点的孩子链表为空表）</p>
<p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83ZDQzNDA3NC1hOGRiLTQwYTYtOWI0Yy04NGFjYWNjYzQ5YTcucG5n?x-oss-process=image/format,png" style=""  alt="img"></p>
<p>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。</p>
<p><strong>孩子兄弟表示法</strong></p>
<p>孩子兄弟表示法又称<strong>二叉树表示法</strong>，即以<strong>二叉链表</strong>作为树的存储结构。孩子兄弟表示法使<strong>每个结点</strong>包括三部分内容：<strong>结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针</strong>（沿此域可以找到结点的所有兄弟结点）</p>
<p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83OTU0NmU3Zi0wZDdiLTRmYmQtOGQyMi00ZDg1ZDUwMzFiY2IucG5n?x-oss-process=image/format,png" style=""  alt="img"></p>
<p>这种存储表示法比较灵活，其最大的优点是可以方便地实现<strong>树转换为二叉树</strong>的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。</p>

        <h3 id="什么是哈夫曼编码"   >
          <a href="#什么是哈夫曼编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是<strong>哈夫曼编码</strong></h3>
      <p>在数据通信中，若对每个字符用<strong>相等长度的二进制位</strong>表示，称这种编码方式为<strong>固定长度编码</strong>。 若允许对不同字符用<strong>不等长的二进制位</strong>表示，则这种编码方式称为<strong>可变长度编码</strong>。</p>
<p><strong>可变长度编码</strong>比固定长度编码要好得多，其<strong>特点</strong>是对<strong>频率高</strong>的字符赋以<strong>短编码</strong>，而对<strong>频率较低</strong>的字符则赋以<strong>较长一些的编码</strong>，从而可以使字符的平均编码长度减短，起到<strong>压缩数据</strong>的效果。</p>
<p>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。若<strong>没有一个编码是另一个编码的前缀</strong>，则称这样的编码为<strong>前缀编码</strong>。</p>
<p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为<strong>从根至该字符的路径上边标记的序列</strong>，其中<strong>边标记****为0</strong> 表示“转向<strong>左孩子</strong>”，<strong>标记为1</strong> 表示“转向<strong>右孩子</strong>“ </p>

        <h3 id="图的存储结构"   >
          <a href="#图的存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h3>
      <p><strong>邻接矩阵法</strong></p>
<p>所谓邻接矩阵存储，是指用一个<strong>一维数组</strong>存储图中<strong>顶点的信息</strong>用一个<strong>二维数组</strong>存储图中<strong>边的信息</strong>（即各顶点之间的邻接关系），存储<strong>顶点之间邻接关系</strong>的二维数组称为<strong>邻接矩阵</strong>。</p>
<p>适合<strong>稠密图</strong>。</p>
<p><strong>邻接表法</strong></p>
<p>当一个图为<strong>稀疏图</strong>时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了<strong>顺序存储</strong>和<strong>链式存储</strong>方法，大大减少了这种不必要的浪费。</p>
<p>所谓<strong>邻接表</strong>，是指对图G 中的每个<strong>顶点V建立一个单链表</strong>，第i个单链表中的结点表示依附于顶点v, 的边（对于有向图则是以顶点v, 为尾的弧），这个单链表就称为顶点vi 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：<strong>顶点表结点</strong>和<strong>边表结点</strong>。 </p>
<p><strong>十字链表法</strong></p>
<p>十字链表法是<strong>有向图</strong>的一种<strong>链式存储结构</strong>。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p>
<p><strong>邻接多重表</strong></p>
<p>邻接多重表是<strong>无向图</strong>的另一种<strong>链式</strong>存储结构。 在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示。</p>
<p><img   src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80MWVkYTg1NS01ZjkyLTQxODEtODdmYi0zZjUyN2ExYThlMDQucG5n?x-oss-process=image/format,png" style=""  alt="img"></p>

        <h3 id="海量数据问题"   >
          <a href="#海量数据问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#海量数据问题" class="headerlink" title="海量数据问题"></a>海量数据问题</h3>
      <p>目前关于海量数据想到的解决办法： 1.bitmap 2.桶排序，外部排序，将需要排序的放到外存上，不用全部放到内存上 </p>

        <h3 id="反转链表"   >
          <a href="#反转链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void translateLinklist(Linklist&amp; L) //三指针法实现链表的反转</span><br><span class="line">&#123;</span><br><span class="line">	Linklist pre;	// 记录之前的结点</span><br><span class="line">	Linklist cur;	// 记录当前的结点</span><br><span class="line">	Linklist r;		// 记录剩下的结点</span><br><span class="line"></span><br><span class="line">	pre = NULL;		 //要先pre指针置为空</span><br><span class="line">	cur = L-&gt;next;   //指向第一个结点</span><br><span class="line">	while (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		r = cur-&gt;next;  //这样r不会成为野指针,且这一步一定要在最前面。即当cur不为空的时候才指向下一个</span><br><span class="line">		cur-&gt;next = pre; //转方向</span><br><span class="line">		pre = cur;      //往后移</span><br><span class="line">		cur = r;</span><br><span class="line">	&#125;</span><br><span class="line">	//结束后cur为空，所以L-&gt;next要指向pre;</span><br><span class="line">	L-&gt;next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="两个栈实现队列"   >
          <a href="#两个栈实现队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h3>
      <p>①输入的时候先让B都进A，然后输入到A中</p>
<p>②输出的时候A都进到B，然后B输出栈顶</p>

        <h3 id="两个队列实现栈"   >
          <a href="#两个队列实现栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3>
      <p>①输入的时候直接输入到队列中</p>
<p>②输出的时候A往B走，当A只有一个时输出，然后B再进回A</p>
<ul>
<li>寻找数组中第二小的元素</li>
<li>找到数组中第一个不重复出现的整数</li>
<li>合并两个有序数组</li>
<li>重新排列数组中的正值和负值</li>
<li>使用栈计算后缀表达式</li>
<li>对栈的元素进行排序</li>
<li>判断表达式是否括号平衡</li>
<li>使用队列表示栈</li>
<li>对队列的前k个元素倒序</li>
<li>使用队列生成从1到n的二进制数</li>
<li>反转链表</li>
<li>检测链表中的循环</li>
<li>返回链表倒数第N个节点</li>
<li>删除链表中的重复项</li>
<li>实现广度和深度优先搜索</li>
<li>检查图是否为树</li>
<li>计算图的边数</li>
<li>找到两个顶点之间的最短路径</li>
<li>求二叉树的高度</li>
<li>在二叉搜索树中查找第k个最大值</li>
<li>查找与根节点距离k的节点</li>
<li>在二叉树中查找给定节点的祖先节点</li>
<li>计算字典树中的总单词数</li>
<li>打印存储在字典树中的所有单词</li>
<li>使用字典树对数组的元素进行排序</li>
<li>使用字典树从字典中形成单词</li>
<li>在数组中查找对称键值对</li>
<li>追踪遍历的完整路径</li>
<li>查找数组是否是另一个数组的子集</li>
<li>检查给定的数组是否不相交</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E6%97%A5%E5%B8%B8/">保研复习之日常提问</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="有什么兴趣爱好"   >
          <a href="#有什么兴趣爱好" class="heading-link"><i class="fas fa-link"></i></a><a href="#有什么兴趣爱好" class="headerlink" title="有什么兴趣爱好"></a>有什么兴趣爱好</h3>
      
        <h3 id="遇到过什么挫折-怎么解决"   >
          <a href="#遇到过什么挫折-怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到过什么挫折-怎么解决" class="headerlink" title="遇到过什么挫折?怎么解决?"></a>遇到过什么挫折?怎么解决?</h3>
      
        <h3 id="你认为机器学习方法和数学建模方法有什么不同吗？"   >
          <a href="#你认为机器学习方法和数学建模方法有什么不同吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#你认为机器学习方法和数学建模方法有什么不同吗？" class="headerlink" title="你认为机器学习方法和数学建模方法有什么不同吗？"></a>你认为机器学习方法和数学建模方法有什么不同吗？</h3>
      
        <h3 id="房价预测用的什么模型"   >
          <a href="#房价预测用的什么模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#房价预测用的什么模型" class="headerlink" title="房价预测用的什么模型"></a>房价预测用的什么模型</h3>
      
        <h3 id="你参加过什么社会实践活动"   >
          <a href="#你参加过什么社会实践活动" class="heading-link"><i class="fas fa-link"></i></a><a href="#你参加过什么社会实践活动" class="headerlink" title="你参加过什么社会实践活动?"></a>你参加过什么社会实践活动?</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E5%AF%86%E7%A0%81%E5%AD%A6/">保研复习之密码学</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="DES加密算法"   >
          <a href="#DES加密算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2>
      <p>分组加密算法，对称加密算法</p>
<p>以64bit的单位称为分组</p>
<p>DES的基本结构是Feistel网络</p>
<p>在Feistel网络中，加密的各个步骤称为<strong>轮</strong>（round），整个加密过程就是进行若干次轮的循环。</p>
<ul>
<li>加密：将64 6464bit的数据分为两部分，每部分32 3232bit，分别对应“左侧”和“右侧”。重复多轮，两轮之间左右对调。</li>
<li>解密：使用与加密时相反的子密钥。 </li>
<li>子密钥：每一轮都需要使用一个不同的密钥，因为它只是一个局部密钥，所以称为<strong>子密钥</strong>（subkey）。</li>
<li>轮函数：根据“右侧”和子密钥生成对“左侧”进行加密的比特序列。</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轮数可以任意增加。</span><br><span class="line">加密时使用任何函数作为轮函数都可以正确解密，即使该函数不存在反函数。</span><br><span class="line">加密和解密可以用完全相同的结构来实现。</span><br></pre></td></tr></table></div></figure>




        <h2 id="三重DES"   >
          <a href="#三重DES" class="heading-link"><i class="fas fa-link"></i></a><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h2>
      <p>由于现在DES已经可以在短时间内被暴力破解，所以三重DES出于这个目的被开发出来了。<strong>三重DES</strong>（triple-DES，3DES）是将DES重复3次得到的一种密码算法。</p>
<ul>
<li>加密：使用3个DES密钥，进行DES加密-&gt;<strong>解密</strong>-&gt;加密的过程。</li>
<li>解密：与加密过程相反。 </li>
<li>特点<ul>
<li>向下兼容：当密钥1 11、2 22、3 33相同时，三重DES就等同于普通的DES。</li>
<li>处理速度慢，除了特别重视向下兼容的情况以外，很少被用于新用途。</li>
</ul>
</li>
</ul>

        <h2 id="ECB模式"   >
          <a href="#ECB模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h2>
      <p><strong>ECB模式</strong>（Electronic CodeBook）非常简单，但由于存在弱点因此通常不会被使用。ECB将明文分组加密后的结果直接变成密文分组：<br><img   src="https://img-blog.csdnimg.cn/cb94014aca3440c0a63fc09a8f0cc174.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="ECB模式"></p>
<ul>
<li>当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行<strong>填充</strong>（padding）。</li>
<li>特点<ul>
<li>由于明文分组与密文分组一一对应，因此根据密文就知道明文中存在怎样的重复组合，可以以此为线索来破译密码。</li>
<li>由于每个明文分组都独立地加密解密，所以密文分组的顺序改变会导致相应的明文分组的顺序改变，因此<strong>攻击者Mallory无需破译密码就能操纵明文</strong>。</li>
</ul>
</li>
</ul>

        <h2 id="CBC模式"   >
          <a href="#CBC模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2>
      <p><strong>CBC模式</strong>（Cipher Block Chaining）将前一个密文分组与当前明文分组进行异或运算，然后再进行加密，这样可以避免ECB模式的弱点：<br><img   src="https://img-blog.csdnimg.cn/083cc694756e481faec10e6d5a510eea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="CBC模式"></p>
<ul>
<li>由于第一个明文分组不存在“前一个密文分组”，因此通常需要随机产生一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为<strong>初始化向量</strong>（Initialization Vector），通常缩写为<strong>IV</strong>。</li>
<li>特点<ul>
<li>由于明文分组在加密前会与“前一个密文分组“进行异或运算，因此即便明文分组1 11和2 22的值是相等的，密文分组1 11和2 22的值也不一定是相等的。</li>
<li>假设CBC模式的密文分组中有一个密文分组<strong>损坏</strong>（分组的长度不变，值变）了，此时解密时最多只有2 22个分组收到影响（即损坏的分组和损坏分组的下一个分组）。</li>
<li>假设CBC模式的密文分组中有一些比特<strong>缺失</strong>（分组的长度改变）了，那么缺失比特之后的密文分组就无法解密了。</li>
<li>当初始化向量被篡改时，CBC模式的第一个明文分组会受到影响。使用消息认证码可以判断数据是否被篡改。</li>
</ul>
</li>
</ul>
<p><img   src="https://img-blog.csdnimg.cn/de9ed933916047c99f2e9e5527155820.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBA5rW35bCG5rKz5o6o6LWw,size_20,color_FFFFFF,t_70,g_se,px;"  alt="img"> </p>

        <h2 id="解决密钥配送问题的方法"   >
          <a href="#解决密钥配送问题的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决密钥配送问题的方法" class="headerlink" title="解决密钥配送问题的方法"></a>解决密钥配送问题的方法</h2>
      <p>公钥密码无法解决的问题：</p>
<ul>
<li>会受到中间人攻击。</li>
<li>处理速度慢，只有对成密码的几百分之一。</li>
</ul>

        <h2 id="RSA算法"   >
          <a href="#RSA算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">取两个大质数p、q；</span><br><span class="line"></span><br><span class="line">计算公共模数n=p*q；</span><br><span class="line"></span><br><span class="line">计算n的欧拉函数f(n)=(p-1)*(q-1);</span><br><span class="line"></span><br><span class="line">任取公钥e大于1小于f(n)且与f(n)互质；</span><br><span class="line"></span><br><span class="line">根据ed mod f(n) =1算出私钥d；</span><br><span class="line"></span><br><span class="line">公钥（e，n) C=M^e mod n；</span><br><span class="line"></span><br><span class="line">私钥（d，n) M=C^d mod n；</span><br><span class="line"></span><br><span class="line">RSA大于等于124bit比较安全。</span><br></pre></td></tr></table></div></figure>




        <h2 id="对称加密算法与非对称加密算法区别与优缺点"   >
          <a href="#对称加密算法与非对称加密算法区别与优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#对称加密算法与非对称加密算法区别与优缺点" class="headerlink" title="对称加密算法与非对称加密算法区别与优缺点"></a>对称加密算法与非对称加密算法区别与优缺点</h2>
      <p>对称加密与非对称加密的主要区别在于密钥的个数。</p>
<p>对称加密，双方用相同密钥，加密速度快、高效、适用于大量数据的加密场景 ，但是无法解决密钥管理、无法确认消息来源。</p>
<p>非对称加密，公钥私钥，能提供身份验证、数字签名，但是加密速度慢、算法复杂。</p>

        <h2 id="HASH算法和SHA-1算法？"   >
          <a href="#HASH算法和SHA-1算法？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HASH算法和SHA-1算法？" class="headerlink" title="HASH算法和SHA-1算法？"></a>HASH算法和SHA-1算法？</h2>
      <p>hash算法就是一个散列函数对于输入的变长信息产生一个定长的散列码。</p>
<p>即已知c好求散列值，但由散列值不好求c。</p>
<p><strong>SHA-1 secure hash algorithm 安全哈希算法</strong></p>
<p>MD-5                                                              输出128bit</p>
<p>SHA-1报文最长2^ 64           80轮运算            输出160 bit</p>
<p>SHA-256                                                        输出256 bit</p>
<p>SHA-512                                                        输出512 bit</p>

        <h2 id="分组加密算法与序列加密算法区别"   >
          <a href="#分组加密算法与序列加密算法区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#分组加密算法与序列加密算法区别" class="headerlink" title="分组加密算法与序列加密算法区别"></a>分组加密算法与序列加密算法区别</h2>
      <p>分组加密每次处理特定长度的快数据，输出定长密文。扩散性好，插入敏感，但处理速度慢。</p>
<p>序列加密&#x2F;流加密对数据流进行连续处理，明密文长度相同。速度快，低错误传播 但扩散性差，插入不敏感。</p>

        <h2 id="加密攻击有哪些工作模式-x2F-威胁模型？"   >
          <a href="#加密攻击有哪些工作模式-x2F-威胁模型？" class="heading-link"><i class="fas fa-link"></i></a><a href="#加密攻击有哪些工作模式-x2F-威胁模型？" class="headerlink" title="加密攻击有哪些工作模式&#x2F;威胁模型？"></a>加密攻击有哪些工作模式&#x2F;威胁模型？</h2>
      <p>唯密文攻击        只知道密文或密文的一部分 ，可通过统计学方法破密。</p>
<p>已知明文攻击      同一密钥的几个明-密文对</p>
<p>选择明文攻击      攻击者可选明文获得密文</p>
<p>选择密文攻击      攻击者可选密文获得明文</p>

        <h2 id="AES-x2F-DES加密"   >
          <a href="#AES-x2F-DES加密" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES-x2F-DES加密" class="headerlink" title="AES&#x2F;DES加密"></a>AES&#x2F;DES加密</h2>
      <p>DES data encryption standard 对称密码 分组密码&#x2F;块加密</p>
<p> IP置换 16轮迭代 IP逆置换    64bit&#x2F;块   密钥64bit</p>
<p>每64位</p>
<p>先进行IP置换，64位分成左右两个32位部分</p>
<p>在密钥的参与下进行16轮迭代，48E扩展、与密钥异或、32S压缩等</p>
<p>16轮后，左右两部分交换并连接，再进行逆置换。</p>
<p><img   src="https://img-blog.csdnimg.cn/1d46a37329cd4c86bb68a1a90d05ed04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"><img   src="https://img-blog.csdnimg.cn/c2de879ef1604343a70e2e1b40aed41b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"></p>
<p> AES advanced encryption standard 对称密码 分组密码&#x2F;块加密</p>
<p> AES      128bit&#x2F;块  密钥每多64位多两轮   128-10  192-12  256-14</p>
<p>先进行一次明文与子密钥矩阵异或初始变换，</p>
<p>再进行 9轮运算，具体是字节代换，行列变换、轮密钥加密等，</p>
<p>最后进行一次最终轮变换（无列变换）。</p>
<p><img   src="https://img-blog.csdnimg.cn/98aa5c31fc2e49949c286b343c2a2175.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hvY29jb2xhdGU=,size_20,color_FFFFFF,t_70,g_se,x_16" style="width: image/watermark,type_d3F5LXplbmhlaQ,shadow_50,tepx;height: t_Q1NETiBAY2hvY29jb2px;"  alt="img"></p>

        <h2 id="数字签名"   >
          <a href="#数字签名" class="heading-link"><i class="fas fa-link"></i></a><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2>
      <p>主要是防止抵赖、认证、防篡改的技术，一般先hash处理。</p>
<p>私钥加密 公钥解密</p>

        <h2 id="密码学攻击"   >
          <a href="#密码学攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#密码学攻击" class="headerlink" title="密码学攻击"></a>密码学攻击</h2>
      <p><strong>主动攻击</strong></p>
<p>在主动攻击中，攻击者尝试修改信息。 由于修改，由于可见性，可以容易地检测到这种攻击。比如重放、篡改等。</p>
<p><strong>被动攻击</strong></p>
<p>在被动攻击中，攻击者尝试获取信息而不修改信息。 因此，这些类型的攻击很难进行攻击，因为在数据中看不到任何干预迹象。比如窃听等。</p>

        <h2 id="密码学安全性"   >
          <a href="#密码学安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#密码学安全性" class="headerlink" title="密码学安全性"></a><strong>密码学安全性</strong></h2>
      <p>密码学中的安全性可以分为两种：理论安全性与计算安全性。</p>
<p>理论安全性：当攻击者拥有无限时间和资源还是不能破译密码时，称其为理论安全，也叫做无条件安全。</p>
<p>计算安全性：如果一个密码算法在给定时间和资源内无法被攻破，则称其为计算安全的。</p>
<p><strong>评估某密码算法的安全性，我们一般会通过数学证明得到。</strong></p>
<p>在密码学中其被称为可证明安全性，它可以证明某个密码方案至少和解决另一个已知的困难问题是同等困难的，只要困难问题仍然存在，那么方案就是安全的，这种证明方式被称为规约，其来自复杂性理论。</p>

        <h2 id="MAC消息认证码-message-authentication-code"   >
          <a href="#MAC消息认证码-message-authentication-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#MAC消息认证码-message-authentication-code" class="headerlink" title="MAC消息认证码 message authentication code"></a>MAC消息认证码 message authentication code</h2>
      <p>是一种确认完整性并进行认证的技术。</p>
<p>通过消息认证码可以确认自己收到的消息是否就是发送者的本意，也就是说可以判断消息是否被篡改，是否有人伪装成发送者发送了这条消息。</p>
<p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享密钥。输出固定长度的数据，输出的数据就是 MAC 值。</p>
<p>消息认证码是一种与密钥相关联的单向散列函数。</p>
<p>单向散列函数保证消息的一致性，完整性，没有被篡改。</p>
<p>消息认证码保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装。</p>
<p>数字签名保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装，并且能防止抵赖。</p>

        <h2 id="重放攻击"   >
          <a href="#重放攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h2>
      <p>窃听者不直接破解消息认证码，而是把它保存起来，反复利用，这种攻击就叫做重放攻击(replay attack)。</p>
<p>防止重放攻击的3种方法：</p>
<ol>
<li>加入序列号</li>
<li>加入时间戳</li>
<li>加入随机数</li>
</ol>

        <h2 id="生日攻击"   >
          <a href="#生日攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2>
      <p>生日攻击不是真实的一个攻击，而是一种概率的结果。生日攻击是以概率论中的生日问题为数据基础的一种密码学攻击方法。</p>
<p>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。对于60人以上，这种概率要大于99%。70人为99%，严格意义上，这并不是一个悖论，称之为悖论是由于跟人们的常识相悖。</p>
<p>所以由生日悖论结论可以看出来：<strong>产生哈希冲突所需的输入样本数量，远低于所有可能哈希值的全集数量。</strong></p>

        <h2 id="信息熵"   >
          <a href="#信息熵" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2>
      <p>香农在信息论中提出了信息熵的概念 </p>
<p>熵是表示随机变量不确定性的度量</p>
<p>从直观上，信息熵越大，变量包含的信息量越大，变量的不确定性也越大。</p>

        <h2 id="什么是哈希碰撞"   >
          <a href="#什么是哈希碰撞" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是哈希碰撞" class="headerlink" title="什么是哈希碰撞"></a>什么是哈希碰撞</h2>
      <p>两个不同的输入，经过哈希算法后，得到了同样的哈希值，就叫做哈希碰撞。</p>
<p>产生原因：</p>
<p>一个空间较大的集合(输入)通过哈希算法映射到一个空间较小的集合(哈希值)，必然会造成多个输入映射到一个哈希值上。</p>
<p>避免方法：</p>
<p>避免哈希碰撞的主要手段是，根据输入集合的数量级，<strong>选取输出合适哈希值长度的哈希函数</strong>，将哈希碰撞的概率降为“几乎不可能”</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">保研复习之离散数学</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="关键词："   >
          <a href="#关键词：" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3>
      <ul>
<li><input disabled="" type="checkbox"> 命题、主析取范式、主合取范式、极小项、极大项</li>
<li><input disabled="" type="checkbox"> 个体词、谓词、量词 </li>
<li><input disabled="" type="checkbox"> P规则、T规则、CP规则</li>
<li><input disabled="" type="checkbox"> 辖域、自由变元、约束变元</li>
<li><input disabled="" type="checkbox"> 环和、环积，幂集，补集，对称差集，笛卡尔乘积，文氏图</li>
<li><input disabled="" type="checkbox"> 关系的定义域、值域、域、逆、合成、限制和像 </li>
<li><input disabled="" type="checkbox"> 自反、对称、传递、偏序关系 </li>
<li><input disabled="" type="checkbox"> 闭包、自反闭包、对称闭包、传递闭包</li>
<li><input disabled="" type="checkbox"> 覆盖、划分、等价关系、等价类</li>
<li><input disabled="" type="checkbox"> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%88%E6%96%AF%E5%9B%BE&spm=1001.2101.3001.7020" >哈斯图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、上下界、偏序</li>
<li><input disabled="" type="checkbox"> 幺元、零元、逆元</li>
<li><input disabled="" type="checkbox"> 代数、半群、独异点、群、阿贝尔群、循环独异点、生成元</li>
<li><input disabled="" type="checkbox"> 简单图、平凡图、多重图、线图、子图、补图、出度、入度、同构</li>
<li><input disabled="" type="checkbox"> 出度、入度、度、同构、子图、真子图、生成子图、有向完全图、无向完全图、补图</li>
<li><input disabled="" type="checkbox"> 连通图、单向连通图、弱连通图、强连通图、基图、连通分图、点连通度、边连通度</li>
<li><input disabled="" type="checkbox"> 基本路径、基本回路、简单路径、简单回路</li>
<li><input disabled="" type="checkbox"> 欧拉路径、欧拉回路、欧拉图、哈密顿路径、哈密顿回路、哈密顿图、哈密尔顿图、欧拉公式</li>
<li><input disabled="" type="checkbox"> 树、无向树、平凡树、森林、连通分支、树叶、分支点、生成树、树枝、弦、余树、Kruskal</li>
</ul>

        <h3 id="主析取范式和主合取范式"   >
          <a href="#主析取范式和主合取范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#主析取范式和主合取范式" class="headerlink" title="主析取范式和主合取范式"></a>主析取范式和主合取范式</h3>
      <p>极小项是若命题变元或其否定的合取∧；</p>
<p>极大项是若命题变元或其否定的析取∨； </p>
<p><img src="C:\Users\86150\AppData\Local\Temp\1656988084687.png" alt="1656988084687"></p>

        <h3 id="推理规则"   >
          <a href="#推理规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3>
      <p>P规则：就是直接利用推理中给出的前提，即前提引入。</p>
<p>T规则：就是由某一个或几个前提可以通过等价、蕴含得到其他命题公式，即推理规则。 </p>
<p>I表示在T规则中通过蕴含式推出其他命题公式，即推理规则中的蕴含推理。</p>
<p>E表示在T规则中通过等价式推出其他命题公式，即推理规则中的置换规则。 </p>
<p>CP(Conditional Proof)规则，若证明AB→C, B可作为附加前提引入。通俗点说，就是咱在做证明题时，看到待证结论是B→C这样的，把B当作前提来用，这就是CP规则。 </p>

        <h3 id="代数、半群、独异点、群、阿贝尔群之间的关系"   >
          <a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#代数、半群、独异点、群、阿贝尔群之间的关系" class="headerlink" title="代数、半群、独异点、群、阿贝尔群之间的关系"></a>代数、半群、独异点、群、阿贝尔群之间的关系</h3>
      <p><img src="C:\Users\86150\AppData\Local\Temp\1657009248374.png" alt="1657009248374"></p>

        <h3 id="欧拉图和哈密顿图"   >
          <a href="#欧拉图和哈密顿图" class="heading-link"><i class="fas fa-link"></i></a><a href="#欧拉图和哈密顿图" class="headerlink" title="欧拉图和哈密顿图"></a>欧拉图和哈密顿图</h3>
      <p>欧拉回路：若存在一条从起点S出发的路径，每条边恰好只走一次，最终回到起点S的路径被称为欧拉路径。</p>
<p>欧拉通路：若存在一条从起点S出发的路径，经过每条边一次，但是不要求回到起点S的路径被称作欧拉通路。</p>
<p>哈密顿路径：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级路径</p>
<p>哈密顿回路：在无向图 <img   src="https://www.zhihu.com/equation?tex=G" style=""  alt="[公式]"> 中包含其所有顶点的初级回路</p>
<p>哈密顿图：具有哈密顿回路的无向图</p>
<p>欧拉公式：n-m+k&#x3D;2</p>

        <h3 id="离散数学讲了什么"   >
          <a href="#离散数学讲了什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#离散数学讲了什么" class="headerlink" title="离散数学讲了什么"></a>离散数学讲了什么</h3>
      <p>数理逻辑，二元关系，群与环，数论什么的，是一门比较抽象的学科，主要作用是建立相关的数学模型，把实际问题抽象成为计算机能够理解的逻辑结构，并且用计算机的思维去解决实际问题，往往实际用的不多，主要是训练思维。</p>

        <h3 id="什么是完全图？"   >
          <a href="#什么是完全图？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是完全图？" class="headerlink" title="什么是完全图？"></a>什么是完全图？</h3>
      <p>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图<br>在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图</p>

        <h3 id="什么是群？"   >
          <a href="#什么是群？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是群？" class="headerlink" title="什么是群？"></a>什么是群？</h3>
      <p>代数系统封闭性 结合律 他就是 半群 含有单位元 就是含幺半群 有逆元就是 群</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/%E8%AE%A1%E7%BD%91/">保研复习之计算机网络</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>[TOC]</p>

        <h3 id="TCP-x2F-IP-网络模型有哪几层？"   >
          <a href="#TCP-x2F-IP-网络模型有哪几层？" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h3>
      <p>4层：应用层、传输层、网络层、网络套接层</p>

        <h3 id="流量控制和拥塞控制有什么区别？"   >
          <a href="#流量控制和拥塞控制有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制和拥塞控制有什么区别？" class="headerlink" title="流量控制和拥塞控制有什么区别？"></a>流量控制和拥塞控制有什么区别？</h3>
      <p>流量控制解决的是发送方和接收方速率不匹配的问题；流量控制是通过滑动窗口来实现的；</p>
<p>拥塞控制解决的是避免网络资源被耗尽的问题;拥塞控制是通过拥塞窗口来实现的。 </p>

        <h3 id="https和http相比有什么区别"   >
          <a href="#https和http相比有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#https和http相比有什么区别" class="headerlink" title="https和http相比有什么区别"></a>https和http相比有什么区别</h3>
      <ol>
<li>建立连接时候：https 比 http多了 TLS 的握手过程；</li>
<li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li>
</ol>

        <h3 id="TCP-和-UDP-区别："   >
          <a href="#TCP-和-UDP-区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-和-UDP-区别：" class="headerlink" title="TCP 和 UDP 区别："></a><strong>TCP 和 UDP 区别：</strong></h3>
      <p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。慢开始、拥塞避免、快重传、快恢复 </li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>

        <h3 id="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"   >
          <a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次握手是可以携带数据的，前两次握手是不可以携带数据的" class="headerlink" title="第三次握手是可以携带数据的，前两次握手是不可以携带数据的"></a><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></h3>
      <ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>

        <h3 id="不使用「两次握手」和「四次握手」的原因："   >
          <a href="#不使用「两次握手」和「四次握手」的原因：" class="heading-link"><i class="fas fa-link"></i></a><a href="#不使用「两次握手」和「四次握手」的原因：" class="headerlink" title="不使用「两次握手」和「四次握手」的原因："></a>不使用「两次握手」和「四次握手」的原因：</h3>
      <p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。 </p>
<p>（1）三次握手目的是确认双方的接收与发送能力是否正常，同步连接双方的初始化序列号 ISN，为后面的可靠性传输做准备。而两次握手只有服务端对客户端的起始序列号做了确认，但客户端却没有对服务端的初始序列号做确认，不能保证传输的可靠性。</p>
<p>（2）三次握手可以防止已失效的连接请求报文段突然又传送到了服务端，导致服务器错误地建立连接，浪费服务端的连接资源。</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>

        <h3 id="为什么需要-TIME-WAIT-状态"   >
          <a href="#为什么需要-TIME-WAIT-状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h3>
      <p>TIME_WAIT 状态持续 2MSL（最大报文存活时间），约4分钟才转换成CLOSE状态。由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接，TIME_WAIT 的主要作用有：</p>
<p>（1）重发丢失的 ACK 报文，保证连接可靠的关闭：</p>
<blockquote>
<p>由于网络等原因，无法保证最后一次挥手的 ACK 报文一定能传送给对方，如果 ACK 丢失，对方会超时重传 FIN，主动关闭端会再次响应ACK过去；如果没有 TIME_WAIT 状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。同时，服务器就因为接收不到客户端的信息而无法正常关闭。</p>
</blockquote>
<p>（2）保证本次连接的重复数据段从网络中消失：</p>
<blockquote>
<p>如果存在两个连接，第一个连接正常关闭，第二个相同的连接紧接着建立；如果第一个连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达，则会干扰第二连接，等待 2MSL 可以让上次连接的报文数据消逝在网络中。</p>
</blockquote>

        <h3 id="为什么需要四次挥手"   >
          <a href="#为什么需要四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3>
      <p>TCP 是全双工模式，并且支持半关闭特性，提供了连接的一端在结束发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>

        <h3 id="什么是拆包粘包："   >
          <a href="#什么是拆包粘包：" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是拆包粘包：" class="headerlink" title="什么是拆包粘包："></a><strong>什么是拆包粘包：</strong></h3>
      <p>拆包粘包在数据链路层、网络层以及传输层都可能存在。而在传输层中，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。 </p>

        <h3 id="网络层-IP数据报分片："   >
          <a href="#网络层-IP数据报分片：" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层-IP数据报分片：" class="headerlink" title="网络层 - IP数据报分片："></a><strong>网络层 - IP数据报分片：</strong></h3>
      <p>​	 MTU 是数据链路层中的网络对数据帧的一个限制（以太网中 MTU 为1500个字节），一个 IP 数据报在以太网中传输，如果它的长度大于 MTU 值，就要进行分片传输，使得每片数据报的长度小于 MTU。而分片传输的 IP 数据报不一定按序到达，但 IP 首部中的信息能让这些数据报片按序组装，IP数据报的分片与重组是在网络层进完成的。</p>
<p>​        前面提到，MSS 是 TCP 数据包每次能够传输的最大数据分段，TCP 报文段的长度大于 MSS 时，要进行分段传输。TCP 在建立连接时通常会协商双方的 MSS 值（MSS 选项只出现在 SYN 报文段中，即 TCP 三次握手的前两次）。MSS 的值一般为 MTU 值减去两个首部大小（IP 数据包包头的大小 20 Bytes 和 TCP 数据段的包头 20 Bytes），TCP报文段的分段与重组是在传输层完成的。</p>
<blockquote>
<p>如果用链路层以太网，MSS的值往往为1460。而 Internet 上标准的 MTU（最小的 MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。</p>
</blockquote>
<p>​        到这里我们就能看出，TCP 分段的原因是 MSS，IP 分片的原因是 MTU，由于一直有 MSS &lt;&#x3D; MTU，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了，因此TCP报文段很少会发生IP分片的情况。</p>
<p>​        而由于 UDP 数据报不会自己进行分段，因此当长度超过了 MTU 时，会在网络层进行 IP 分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p>​        所以，总的来说，UDP 不会分段，就由 IP 来分，TCP会分段，当然就不用 IP 来分了！</p>

        <h3 id="IPv4和IPv6首部的差异"   >
          <a href="#IPv4和IPv6首部的差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4和IPv6首部的差异" class="headerlink" title="IPv4和IPv6首部的差异"></a>IPv4和IPv6首部的差异</h3>
      <p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>

        <h3 id="TCP-如何保证可靠性传输："   >
          <a href="#TCP-如何保证可靠性传输：" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-如何保证可靠性传输：" class="headerlink" title="TCP 如何保证可靠性传输："></a>TCP 如何保证可靠性传输：</h3>
      <ul>
<li>（1）三次握手</li>
<li>（2）应答机制与超时重传：TCP接收端收到发送端的数据时，它将发送一个确认。当TCP发送端发出一个报文段后，它会启动一个定时器，等待接收端的确认报文段，如果不能及时收到一个确认，将重发这个报文段。</li>
<li>（3）数据包校验与丢弃重复数据：TCP会检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP会超时重发数据；对于重复数据，则进行丢弃；</li>
<li>（4）对失序数据包进行重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>（5）流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li>（6）拥塞控制：网络拥塞时，减少数据的发送。</li>
</ul>

        <h3 id="交换机和路由器的区别"   >
          <a href="#交换机和路由器的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3>
      <p>（1）工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层；</p>
<p>（2）寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址；</p>
<p>（3）转发速不同：交换机的转发速度快，路由器转发速度相对较慢。</p>
<p>（4）交换机用于连接局域网，路由器用于连接外网和局域网</p>

        <h3 id="集线器和交换机的区别"   >
          <a href="#集线器和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器和交换机的区别" class="headerlink" title="集线器和交换机的区别"></a><strong>集线器和交换机的区别</strong></h3>
      <p>集线器和交换机都是工作在TCP&#x2F;IP协议的最后一层，数据链路（物理层），都是连接多个设备形成局域网的。<br>集线器会把接收到的数据包每次都广播给局域网局域网的所有计算机，而交换机只有首次在MAC地址表找不到记录才广播，其他时候是直接单独发送给对应MAC地址的计算机。交换机可以说是集线器的升级改良版，在集线器的基础上多了MAC地址表，可以分割冲突域，更加智能化。</p>
<p>集线器的数据传输方式是广播方式，而交换机的数据传输是有目的的，数据只对目的节点发送，只是在自己的MAC地址表中找不到的情况下第一次使用广播方式发送，然后因为交换机具有MAC地址学习功能，第二次以后就不再是广播发送了，又是有目的的发送。这样的好处是数据传输效率提高，不会出现广播风暴，在安全性方面也不会出现其它节点侦听的现象</p>

        <h3 id="网桥和交换机的区别"   >
          <a href="#网桥和交换机的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#网桥和交换机的区别" class="headerlink" title="网桥和交换机的区别"></a><strong>网桥和交换机的区别</strong></h3>
      <ul>
<li>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个输出输入端口，而交换机具有高密度的端口。所以一般的交换机，网桥就有桥接作用。</li>
<li>网桥主要由软件实现，交换机主要由硬件实现</li>
</ul>
<p>网桥也可以理解成只有两个端口的交换机，交换机可以理解成由多个网桥组成的 </p>

        <h3 id="介绍一下TCP的拥塞控制："   >
          <a href="#介绍一下TCP的拥塞控制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下TCP的拥塞控制：" class="headerlink" title="介绍一下TCP的拥塞控制："></a>介绍一下<strong>TCP的拥塞控制：</strong></h3>
      <p>拥塞控制就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。发送方维持一个拥塞窗口cwnd 的状态变量。拥塞窗口的大小动态变化，取决于网络的拥塞程度，发送方让自己的发送窗口等于拥塞窗口。只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 拥塞控制的方法主要有以下几种：慢启动、拥塞避免、快重传和快恢复。 </p>
<p><strong>（1）慢开始算法：</strong>当发送主机开始发送数据时，不要一开始就发送大量的数据，因为不清楚网络的拥塞情况，而是试探一下网络的拥塞情况，由小到大逐渐增大发送窗口。</p>
<p><strong>（2）拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p><strong>（3）快重传：</strong>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（使发送方及早知道有报文段没有到达对方）而不必等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><strong>（4）快恢复：</strong>与快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减少”算法，把ssthresh门限设置为拥塞窗口cwnd的一半，但是接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法：因为如果网络出现拥塞的话，就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以此时并不执行慢开始算法，而是执行拥塞避免算法。</p>

        <h3 id="拥塞控制和流量控制的差别："   >
          <a href="#拥塞控制和流量控制的差别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制和流量控制的差别：" class="headerlink" title="拥塞控制和流量控制的差别："></a>拥塞控制和流量控制的差别：</h3>
      <p>（1）相同点：拥塞控制和流量控制的相同点都是控制丢包现象，实现机制都是让发送方发得慢一点。</p>
<p>（2）不同点：</p>
<p>① 拥塞控制是一个全局性的过程，防止过多的数据注入到网络中，造成网络拥塞</p>
<p>② 流量控制指点对点通信量的控制，要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
<p>如何判断多个数据包是属于同一个信息？以及他们的先后次序？</p>
<p>为什么网络传输中会出现丢包？</p>

        <h3 id="Ip协议中用来分片和重组的依据"   >
          <a href="#Ip协议中用来分片和重组的依据" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ip协议中用来分片和重组的依据" class="headerlink" title="Ip协议中用来分片和重组的依据"></a>Ip协议中用来分片和重组的依据</h3>
      <p>标志：根据DF来判断是否可以进行分片</p>
<p>标识：根据标识来判断原始报文和分片报文的关系</p>
<p>偏移量：收集所有的分片</p>
<p><img   src="https://img-blog.csdnimg.cn/2021063021002750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>
<p>一个表示网段地址、一个表示广播地址</p>
<p>网络号是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的第一个地址，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80" >广播地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E6%AE%B5&spm=1001.2101.3001.7020" >网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的最后一个地址，这两个地址是不能配置在计算机<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" >主机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的。 </p>

        <h3 id="DHCP协议"   >
          <a href="#DHCP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名称：动态主机配置协议</span><br><span class="line">作用：当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址</span><br><span class="line">协议：基于UDP</span><br><span class="line">工作方式：客户/服务段模式	C/S模式</span><br><span class="line">端口号：服务器在67号  客户端在68号</span><br><span class="line">过程：DHCPDISCOVER-&gt;DHCPOFFER-&gt;DHCPREQUEST-&gt;DHCPACK</span><br><span class="line">协议层：网络层</span><br></pre></td></tr></table></div></figure>




        <h3 id="ARP协议"   >
          <a href="#ARP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">名称：地址解析协议</span><br><span class="line">作用：根据IP地址获取物理地址的一个TCP/IP协议</span><br><span class="line">协议层：网络层</span><br><span class="line">过程：</span><br><span class="line">	A已知B的IP地址，需要获得B的MAC地址（物理地址）</span><br><span class="line">    如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取</span><br><span class="line">    如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组</span><br><span class="line">    在局域网上的所有节点都可以接收到ARP query</span><br><span class="line">    B接收到ARP query分组后，将自己的MAC地址发送给A</span><br><span class="line">    A在ARP表中缓存B的IP地址和MAC地址的映射关系</span><br><span class="line">    超时时删除</span><br></pre></td></tr></table></div></figure>




        <h3 id="ICMP协议"   >
          <a href="#ICMP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：互联网控制报文协议</span><br><span class="line">作用：ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</span><br><span class="line">ICMP 报文携带在IP 数据报中： IP上层协议号为1</span><br><span class="line">类型：差错报告报文、询问报文</span><br></pre></td></tr></table></div></figure>




        <h3 id="路由选择协议RIP"   >
          <a href="#路由选择协议RIP" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议RIP" class="headerlink" title="路由选择协议RIP"></a>路由选择协议RIP</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于：距离矢量算法</span><br><span class="line">衡量标准：跳数、即距离近</span><br><span class="line">基本思想：①只与邻居路由器交换信息②交换的是整个路由表</span><br><span class="line">特点：算法简单、收敛慢</span><br><span class="line">适用场景：中小网络</span><br></pre></td></tr></table></div></figure>




        <h3 id="BGP-外部网关路由协议"   >
          <a href="#BGP-外部网关路由协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#BGP-外部网关路由协议" class="headerlink" title="BGP-外部网关路由协议"></a>BGP-外部网关路由协议</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对于：内部网关路由协议IGP：比如RIP、OSPF等</span><br><span class="line">适用于：不同的自治域间的路由协议</span><br><span class="line">交换信息：路径通告</span><br><span class="line">基于：TCP连接用于交换BGP报文</span><br><span class="line">两类报文：eBGP用于相邻的AS，iBGP用于AS内的全部路由器（即内部）</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="路由器中三种典型的交换结构"   >
          <a href="#路由器中三种典型的交换结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器中三种典型的交换结构" class="headerlink" title="路由器中三种典型的交换结构"></a>路由器中三种典型的交换结构</h3>
      <p>共享内、共享总线、纵横式 crossbar</p>
<p><img   src="https://img-blog.csdnimg.cn/20210701184819348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpx;"  alt="img"> </p>

        <h3 id="远程登录Telnet"   >
          <a href="#远程登录Telnet" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程登录Telnet" class="headerlink" title="远程登录Telnet"></a>远程登录Telnet</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用：定义客户进程与远程服务器进程之间的交互过程</span><br><span class="line">基于：TCP协议</span><br><span class="line">协议层：应用层协议</span><br><span class="line">传输数据格式：NVT网络虚拟终端（定义的一组通用字符集）</span><br><span class="line">工作过程：①建立TCP连接 </span><br><span class="line">②将本地终端上输入的用户名和口令及以后输入的任何命令或字符以网络虚拟终端NVT格式传输给远程主机</span><br><span class="line">③将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果</span><br><span class="line">④本地终端对远程主机撤销连接，从而结束 Telnet远程登录过程</span><br></pre></td></tr></table></div></figure>




        <h3 id="文件传输协议FTP"   >
          <a href="#文件传输协议FTP" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a><strong>文件传输协议FTP</strong></h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限</span><br><span class="line">实现方式：C/S模式</span><br><span class="line">协议层：应用层协议</span><br><span class="line">基于：TCP协议（21号端口）</span><br><span class="line">两个端口与两个连接：21号端口用于控制连接  20号端口用于数据连接</span><br></pre></td></tr></table></div></figure>




        <h3 id="传输层是干嘛的？"   >
          <a href="#传输层是干嘛的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层是干嘛的？" class="headerlink" title="传输层是干嘛的？"></a>传输层是干嘛的？</h3>
      <p>为主机的进程之间提供通信，是两个主机通信中第一个端对端的层次，具有缓冲作用。由于一个主机有多个进程，因此传输层具有分用复用的功能。传输层在终端用户中进行透明的数据传输，向上层提供可靠的数据传输服务。当网络层服务质量不能满足要求时（比如无法保证可靠传输）它可以将服务质量提高到达需要的要求。通过流量控制、分段&#x2F;重组、差错控制来保证数据传输的可靠性。</p>
<p>在传输层上又两个经常用到的协议：TCP和UDP，TCP可以保证可靠传输协议，它是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手来建立连接，四次挥手来中断连接。它具有拥塞控制和流量控制机制。UDP是尽最大努力交付的协议，比较的简单，没有那么多机制，对于那些数据质量要求不高但是时效性要求高的应用经常使用。</p>

        <h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"   >
          <a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3>
      <p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>

        <h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"   >
          <a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3>
      <p>主要原因有三：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p>当历史连接由于网络拥塞导致其在客户端重新请求之后，新请求达到之前先一步到达客户端，那么客户端发送的ACK便是历史的连接请求，此时客户端发现后便需要RST中断连接，但此时服务端已经是established因此会发送数据造成浪费，主要原因是两次握手「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</p>
<p>除此之外通过三次握手才能约定客户端和服务段双方的初始化序列号，如果两次的话只能确定客户端的初始化序列号。</p>
<p>如果是两次握手，当网络拥挤时由于SYN报文的丢失，会导致服务端手段多个重复的SYN，由于经过了一段时间的传输因此可能会造成多余连接的建立，造成资源浪费。</p>
<p>每次都是接收到数据包的一方可以得到对方的状态，发送的一方其实没有任何头绪。因此至少需要三次握手才能使得双方都确定对方已经完成发送数据的准备。</p>

        <h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"   >
          <a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3>
      <p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>

        <h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"   >
          <a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3>
      <p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。 </p>

        <h3 id="说下网络中的主机通信流程"   >
          <a href="#说下网络中的主机通信流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说下网络中的主机通信流程" class="headerlink" title="说下网络中的主机通信流程"></a>说下网络中的主机通信流程</h3>
      <p>主机A和主机B在同一个二层网络中，直接走二层交换</p>
<p>主机A和主机B不在同一个网络中，走三层路由</p>

        <h3 id="介绍一下Socket"   >
          <a href="#介绍一下Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Socket" class="headerlink" title="介绍一下Socket"></a>介绍一下Socket</h3>
      <p>Socket是一组编程接口（API）。介于传输层和应用层，向应用层提供统一的编程接口。应用层不必了解TCP&#x2F;IP协议细节。直接通过对Socket接口函数的调用完成数据在IP网络的传输。</p>
<p>套接字&#x3D;IP地址+网络协议+端口号</p>

        <h3 id="HTTP和HTTPS"   >
          <a href="#HTTP和HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3>
      <p>他们都是应用层协议</p>
<p>HTTP协议是超文本传输协议，最初的目的是为了提供一种发布和接收HTML页面的方法</p>
<p>HTTPS是HTTP协议的安全版本，将其传输过程中的数据使用SSL&#x2F;TLS进行了加密，并且他是需要申请证书的</p>
<p>他们使用的端口号不同，HTTP为80端口，HTTPS为443端口</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）https是基于tcp协议的，首先客户端会和服务端发起链接建立</span><br><span class="line">（2）服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息</span><br><span class="line">（3）客户端通过浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</span><br><span class="line">（4）客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</span><br><span class="line">（5）客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</span><br></pre></td></tr></table></div></figure>





        <h3 id="CSMA-x2F-CD协议"   >
          <a href="#CSMA-x2F-CD协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3>
      <p>载波监听多点接入&#x2F;碰撞检测协议  三大特点</p>
<p>1.多点接入：作用在总线型网络中，许多计算机以多点接入的方式连接在同一个总线上</p>
<p>2.载波监听：每个站在发送数据前都会先检测总线上是否有其他站在发送数据，如果有则先等待</p>
<p>3.碰撞检测：边发送边监听，通过监听电压值的变化来判断是否和其他站发送进行了冲突，一段时间后无冲突则不再检测，如果发送冲突则停止发送数据，等待一段空闲时间后再次发送。</p>
<p>碰撞不可能完全避免，CSMA&#x2F;CD只能减少碰撞。</p>

        <h3 id="如何扩充局域网？"   >
          <a href="#如何扩充局域网？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何扩充局域网？" class="headerlink" title="如何扩充局域网？"></a>如何扩充局域网？</h3>
      <p>在物理层：通过集线器将多个计算机进行互联</p>
<p>链路层：通过交换机来进行扩展，相当于多接口的网桥</p>
<p>网络层：通过虚拟局域网VLAN</p>

        <h3 id="私有地址的范围"   >
          <a href="#私有地址的范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#私有地址的范围" class="headerlink" title="私有地址的范围"></a>私有地址的范围</h3>
      <p>A类：10.0.0.0-10.255.255.255</p>
<p>B类：172.16.0.0-172.31.255.255</p>
<p>C类：192.168.0.0-192.168.255.255</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用</p>

        <h3 id="介绍一下虚电路"   >
          <a href="#介绍一下虚电路" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下虚电路" class="headerlink" title="介绍一下虚电路"></a>介绍一下虚电路</h3>
      <p>虚电路是分组交换的两种传输方式中的一种，另一种是电路交换</p>
<p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p>
<p>提前定义好一条路径，可以改进性能，并且消除了帧和分组对头的需求，从而增加了吞吐率</p>

        <h3 id="电路交换、报文交换、分组交换"   >
          <a href="#电路交换、报文交换、分组交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3>
      <p>电路交换：在使用电路交换进行通话之前，必须先拨号建立一条连接，也就是一条专用的物理通路，这条通路在通话中只允许通话的两个用户使用，而不允许其他人使用。</p>
<p>优点：实现简单</p>
<p>缺点：建立大型网络时资源利用率不高，当用户比较多时，可能会出现通路短缺的情况。</p>
<p>报文交换：报文是通信链路中一次要发送的数据，报文交换就是把整个报文完整的发送到链路中，在某个节点存储下来之后再发送到下一个节点。</p>
<p>优点：相比电路交换，来说更加灵活。不需要事先建立连接之后再进行通信。</p>
<p>缺点：当每个报文的数据量较大时，每次在节点处转发再存储的话时延较大。</p>
<p>分组交换：分组交换采用转发存储技术，将一个完整的报文，分成若干个分组，再进行转发，而且每个分组之间经过哪一个节点，与上一个分组完全没有关系，这一点在某些网络节点发生网络阻塞时会显得尤其重要。</p>
<p>优点：发送数据更加灵活，时延更下。</p>
<p>缺点：发送设备和接收设备就更加复杂。</p>

        <h3 id="什么是SYN洪泛"   >
          <a href="#什么是SYN洪泛" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SYN洪泛" class="headerlink" title="什么是SYN洪泛"></a>什么是SYN洪泛</h3>
      <p> SYN 洪泛是指利用 TCP 需要三次握手的特性，攻击者伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 ACK 应答，但之后攻击者不再对该响应进行应答，造成一个半连接。假设攻击者发送大量这样的报文，那么被攻击主机就会造成大量的半连接，耗尽其资源，导致正常的 SYN 请求因为队列满而被丢弃，使得正常用户无法访问。</p>
<blockquote>
<p>半连接队列：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。</p>
</blockquote>

        <h3 id="cookie-和-session-的区别："   >
          <a href="#cookie-和-session-的区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#cookie-和-session-的区别：" class="headerlink" title="cookie 和 session 的区别："></a><strong>cookie 和 session 的区别：</strong></h3>
      <p>1）保存位置与安全性：cookie保存在客户端，session保存在服务端，所以在安全性上面，cookie存在安全隐患，可以通过拦截或本地文件找到cookie后进行攻击，而session相对更加安全。因此，可以将登陆信息等重要信息存放为session中；其他信息如果需要保留，可以放在cookie中。</p>
<p>（2）存储容量：单个cookie最大只允许4KB，一个站点最多保存20个Cookie；session没有大小限制，个数只跟服务器的内存大小有关。</p>
<p>（3）有效期与实现机制：cookie可长期有效存在；session依赖于cookie，过期时间默认为-1，只需关闭窗口该 session 就会失效。每个客户端对应一个session ，客户端之间的 session  相互独立；</p>

        <h3 id="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"   >
          <a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个完整的http请求是怎么样？即从输入网址到获得页面的过程" class="headerlink" title="一个完整的http请求是怎么样？即从输入网址到获得页面的过程"></a>一个完整的http请求是怎么样？即从输入网址到获得页面的过程</h3>
      <p>（1）解析url，获取 url 中包含的域名；</p>
<p>（2）通过DNS系统查询域名对应的IP；</p>
<p>（3）浏览器得到域名对应的IP地址之后，向服务器发起三次握手请求建立TCP链接；</p>
<p>（4）TCP链接链接建立起来后，浏览器向服务器发送http请求，如果 html文件在缓存里，浏览器则直接返回， 如果没有，则去后台拿；</p>
<p>（5）服务器接收到请求后，根据路径参数映射到特定的处理器进行处理，并将处理结果以及相应的视图返回给浏览器。</p>
<p>（6）浏览器解析视图，并根据请求到的资源、数据进行渲染页面，最终向用户呈现一个完整的页面。</p>

        <h3 id="http的长连接和短连接？"   >
          <a href="#http的长连接和短连接？" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的长连接和短连接？" class="headerlink" title="http的长连接和短连接？"></a><strong>http的长连接和短连接？</strong></h3>
      <p>http的长连接和短连接本质上是TCP长连接和短连接。从http1.1开始就默认使用长连接。</p>
<p>短链接是指客户端与服务端每进行一次请求操作，就建立一次TCP连接，收到服务器响应后，就断开连接。</p>
<p>长连接是指客户端和服务建立TCP连接后，它们之间的连接会持续存在，不会因为一次HTTP请求后关闭，后续的请求也是用这个连接进行通信，使用长连接的HTTP协议，会在响应头有加入：Connection:keep-alive。长连接可以省去每次TCP建立和关闭的握手和挥手操作，节约时间提高效率。但在长连接下，客户端一般不会主动关闭连接，如果客户端和服务端之间的连接一直不关闭的话，随着连接数越来越多，会对服务端造成压力。</p>
<p>所以长连接多用于频繁请求资源，而且连接数不能太多的情况，例如数据库的连接用长连接。而像Web网站这种并发量大，但是每个用户无需频繁操作的场景，一般都使用短连接，因为长连接对服务端来说会耗费一定的资源。</p>

        <h3 id="get和-post-请求的区别"   >
          <a href="#get和-post-请求的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#get和-post-请求的区别" class="headerlink" title="get和 post 请求的区别"></a><strong>get和 post 请求的区别</strong></h3>
      <ul>
<li>（1）功能：get一般用来从服务器上面获取资源，post一般用来更新服务器上面的资源。</li>
<li>（2）幂等性：get 是幂等的，post 为非幂等的</li>
<li>（3）安全性：get 请求的参数会明文附加在URL之后，而 post 请求提交的数据则被封装到请求体中，相对更安全。</li>
<li>（4）传输数据量的大小：get请求允许发送的数据量比较小，大多数浏览器都会限制请求的url长度在2048个字节，而大多数服务器最多处理64K大小的url；而post请求提交的数据量则是没有大小限制的。</li>
<li>（5）参数的数据类型：GET只接受ASCII字符，而POST没有限制。</li>
<li>（6）GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>（7）get请求可以被缓存，可以被保留在浏览器的历史记录中；post请求不会被缓存，不会被保留在浏览器的历史记录中。</li>
</ul>

        <h3 id="Http-常见的状态码"   >
          <a href="#Http-常见的状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-常见的状态码" class="headerlink" title="Http 常见的状态码"></a><strong>Http 常见的状态码</strong></h3>
      <p>（1）1xx：请求处理中，请求已被接受，正在处理。</p>
<p>（2）2xx：请求成功，请求被成功处理。</p>
<p>（3）3xx：重定向，要完成请求必须进一步处理。</p>
<p>（4）4xx：客户端错误，请求不合法。</p>
<ul>
<li>404：未找到请求的资源</li>
</ul>
<p>（5）5xx：服务端错误，服务端不能处理合法请求。</p>
<ul>
<li>500：服务器内部错误。</li>
</ul>

        <h3 id="DNS-为什么用-UDP"   >
          <a href="#DNS-为什么用-UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h3>
      <p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>

        <h3 id="保活计时器的作用？"   >
          <a href="#保活计时器的作用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#保活计时器的作用？" class="headerlink" title="保活计时器的作用？"></a>保活计时器的作用？</h3>
      <p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>

        <h3 id="UDP-如何实现可靠传输？"   >
          <a href="#UDP-如何实现可靠传输？" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-如何实现可靠传输？" class="headerlink" title="UDP 如何实现可靠传输？"></a>UDP 如何实现可靠传输？</h3>
      <p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">time_cool</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/timecool-cpu" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/shi-guang-85-73-85" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">17</div><div class="sidebar-ov-state-item__name">归档</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>水水水</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@1.0.1/dist/quicklink.umd.js"></script><script>function initQuicklink() {
  quicklink({
    timeout: '10000',
    priority: true,
    ignores: [uri => uri.includes('#'), uri => uri === 'http://example.com/', /\/api\/?/,uri => uri.includes('.xml'),uri => uri.includes('.zip'),(uri, el) => el.hasAttribute('nofollow'),(uri, el) => el.hasAttribute('noprefetch')]
  });
}

if (false || false) {
  initQuicklink();
} else {
  window.addEventListener('DOMContentLoaded', initQuicklink, false);
}</script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>